{"version":3,"sources":["webpack://Dastal/webpack/universalModuleDefinition","webpack://Dastal/./src/array/utils.ts","webpack://Dastal/./src/heap/binaryHeap.ts","webpack://Dastal/./src/tree/utils.ts","webpack://Dastal/./src/heap/skewHeap.ts","webpack://Dastal/./src/heap/utils.ts","webpack://Dastal/./src/list/arrayList.ts","webpack://Dastal/./src/list/doublyLinkedList.ts","webpack://Dastal/./src/list/linkedList.ts","webpack://Dastal/./src/list/utils.ts","webpack://Dastal/./src/queue/arrayQueue.ts","webpack://Dastal/./src/queue/linkedQueue.ts","webpack://Dastal/./src/stack/arrayStack.ts","webpack://Dastal/./src/stack/linkedStack.ts","webpack://Dastal/webpack/bootstrap","webpack://Dastal/webpack/runtime/compat get default export","webpack://Dastal/webpack/runtime/define property getters","webpack://Dastal/webpack/runtime/hasOwnProperty shorthand","webpack://Dastal/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","self","MAX_ARRAY_LENGTH","Symbol","iterator","BinaryHeap","compareFn","elements","this","compare","array","addAll","length","element","RangeError","push","heapify","indexOf","index","last","pop","sinkDown","bubbleUp","value","heap","size","dump","undefined","a","b","curElement","newElement","preOrderTraverse","clone","node","out","Object","assign","stack","LinkedStack","left","right","toBinaryTree","n","nodes","Array","i","par","SkewHeap","key","skewMerge","parentIndex","Math","floor","parent","childIndex","child","heaps","list","LinkedList","sort","shift","next","ArrayList","from","splice","batch","items","lists","min","max","cwrap","copyWithin","fill","callback","temp","prev","slice","start","count","clamp","unshift","arguments","len","DoublyLinkedList","_addAll","_get","nodeA","nodeB","tail","head","view","mergeSort","_copyWithin","nodeC","nodeD","remove","deleted","newTail","add","to","iterable","f","num","pivot","wrap","isDoubly","lens","ceil","heads","tails","mergeSorted","ArrayQueue","LinkedQueue","clear","get","ArrayStack","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","d","definition","o","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","r","toStringTag"],"mappings":"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","file":"dastal.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Dastal\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Dastal\"] = factory();\n\telse\n\t\troot[\"Dastal\"] = factory();\n})(self, function() {\nreturn ","/**\n * The maximum length of an array.\n *\n * According to [ECMA-262](https://tc39.es/ecma262/#array-index):\n *     0 <= array.length <= 2^32 - 1\n */\nexport const MAX_ARRAY_LENGTH = 4294967295;\n","import { MAX_ARRAY_LENGTH } from 'src/array/utils';\nimport { CompareFn } from '..';\nimport { Heap } from './heap';\nimport { SkewHeap } from './skewHeap';\nimport { bubbleUp, heapify, sinkDown } from './utils';\n\n/**\n *\n */\nexport class BinaryHeap<T> implements Heap<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * Instantiate a heap.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>) {\n        this.compare = compareFn;\n        this.array = [];\n        this.addAll(elements ?? []);\n    }\n\n    addAll(elements: Iterable<T>): number {\n        const array = this.array;\n\n        // Add new elements\n        const length = array.length;\n        for (const element of elements) {\n            if (array.length >= MAX_ARRAY_LENGTH) {\n                throw new RangeError('Invalid heap length');\n            }\n            array.push(element);\n        }\n\n        // Update the heap\n        if (length < array.length) {\n            heapify(this.compare, array);\n        }\n\n        return array.length;\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        return this.array.indexOf(element) >= 0;\n    }\n\n    delete(element: T): boolean {\n        const index = this.array.indexOf(element);\n        if (index < 0) {\n            return false;\n        }\n\n        // If deleting the last value\n        const last = this.array.pop()!;\n        if (index >= this.array.length) {\n            return true;\n        }\n\n        // Add the last value to the\n        // deleted index and update the heap\n        this.array[index] = last;\n        sinkDown(index, this.compare, this.array);\n        bubbleUp(index, this.compare, this.array);\n        return true;\n    }\n\n    *dump(): Iterable<T> {\n        for (const value of this.array) {\n            yield value;\n        }\n    }\n\n    merge(heap: Heap<T>): this {\n        const array = this.array;\n\n        if (heap.size < 1) {\n            return this;\n        }\n        if (array.length + heap.size > MAX_ARRAY_LENGTH) {\n            throw new RangeError('Invalid heap length');\n        }\n\n        const elements = heap instanceof BinaryHeap ? heap.array : heap.dump();\n        for (const element of elements) {\n            array.push(element);\n        }\n\n        heapify(this.compare, array);\n        return this;\n    }\n\n    peek(): T | undefined {\n        return this.array.length > 0 ? this.array[0] : undefined;\n    }\n\n    pop(): T | undefined {\n        if (this.array.length < 1) {\n            return undefined;\n        }\n\n        // Get the root and the last value\n        const value = this.array[0];\n        const last = this.array.pop();\n\n        // If value != last\n        if (this.array.length > 0) {\n            // Move the last value to the root and update the heap\n            this.array[0] = last!;\n            sinkDown(0, this.compare, this.array);\n        }\n\n        return value;\n    }\n\n    push(value: T): number {\n        // Add new value to the end of the heap\n        this.array.push(value);\n\n        // Update the heap\n        bubbleUp(this.array.length - 1, this.compare, this.array);\n        return this.size;\n    }\n\n    pushPop(value: T): T {\n        // If empty or value is <= to root\n        if (this.array.length < 1 || this.compare(value, this.array[0]) <= 0) {\n            return value;\n        }\n\n        // Swap the root and value\n        const root = this.array[0];\n        this.array[0] = value;\n        sinkDown(0, this.compare, this.array);\n        return root;\n    }\n\n    replace(value: T): T | undefined {\n        // If empty\n        if (this.array.length < 1) {\n            this.array.push(value);\n            return undefined;\n        }\n\n        // Swap the root with value\n        const root = this.array[0];\n        this.array[0] = value;\n        value = root;\n\n        // Update the heap\n        sinkDown(0, this.compare, this.array);\n        return value;\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Iterate through the heap in sorted order.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the heap.\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        if (this.array.length < 1) {\n            return;\n        }\n        const array = this.array;\n        const heap = new BinaryHeap<number>((a, b) => this.compare(array[a], array[b]), [0]);\n        do {\n            let index = heap.pop()!;\n            if (index < array.length) {\n                yield array[index];\n                index = 2 * index + 1;\n                index < array.length && heap.push(index);\n                ++index < array.length && heap.push(index);\n            }\n        } while (heap.size > 0);\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        const index = this.array.indexOf(curElement);\n        if (index < 0) {\n            return false;\n        }\n        this.array[index] = newElement;\n        sinkDown(index, this.compare, this.array);\n        bubbleUp(index, this.compare, this.array);\n        return true;\n    }\n}\n","import { LinkedStack } from 'src/stack';\nimport { BinaryTreeNode } from '.';\n\n/**\n *\n * @param node\n *\n * @returns\n *\n * @internal\n */\nexport function clone<T>(node: BinaryTreeNode<T> | undefined): BinaryTreeNode<T> | undefined {\n    if (node == null) {\n        return undefined;\n    }\n    const out: BinaryTreeNode<T> = Object.assign({}, node);\n    const stack = new LinkedStack<BinaryTreeNode<T>>([out]);\n    do {\n        node = stack.pop()!;\n        if (node.left) {\n            stack.push((node.left = Object.assign({}, node.left)));\n        } else if (node.right) {\n            stack.push((node.right = Object.assign({}, node.right)));\n        }\n    } while (stack.size > 0);\n    return out;\n}\n/**\n *\n * @param elements\n *\n * @returns\n *\n * @internal\n */\nexport function toBinaryTree<T>(elements: T[] | undefined): BinaryTreeNode<T> | undefined {\n    if (elements == null || elements.length < 1) {\n        return undefined;\n    }\n    const n = elements.length;\n    const nodes = new Array(n);\n    nodes[0] = { value: elements[0] };\n    for (let i = 1; i < n; ++i) {\n        const par = nodes[(i - 1) >>> 1];\n        const node = { value: elements[i] };\n        nodes[i] = node;\n        if (i & 1) {\n            par.left = node;\n        } else {\n            par.right = node;\n        }\n    }\n    return nodes[0];\n}\n/**\n *\n * @param node\n *\n * @returns\n *\n * @internal\n */\nexport function* inOrderTraverse<T>(\n    node: BinaryTreeNode<T> | undefined,\n): Iterable<BinaryTreeNode<T>> {\n    const stack = new LinkedStack<BinaryTreeNode<T>>();\n\n    while (node != null) {\n        stack.push(node);\n        node = node.left;\n    }\n\n    while (stack.size > 0) {\n        node = stack.pop()!;\n        yield node;\n        node = node.right;\n        while (node != null) {\n            stack.push(node);\n            node = node.left;\n        }\n    }\n}\n/**\n *\n * @param node\n *\n * @returns\n *\n * @internal\n */\nexport function* postOrderTraverse<T>(\n    node: BinaryTreeNode<T> | undefined,\n): Iterable<BinaryTreeNode<T>> {\n    interface Meta {\n        seen: boolean;\n        node?: BinaryTreeNode<T>;\n    }\n    const stack = new LinkedStack<Meta>([{ seen: false, node }]);\n    do {\n        const meta = stack.pop()!;\n        if (meta.node != null) {\n            if (meta.seen) {\n                yield meta.node;\n            } else {\n                meta.seen = true;\n                stack.push(meta);\n                stack.push({ seen: false, node: meta.node.right });\n                stack.push({ seen: false, node: meta.node.left });\n            }\n        }\n    } while (stack.size > 0);\n}\n/**\n *\n * @param node\n *\n * @returns\n *\n * @internal\n */\nexport function* preOrderTraverse<T>(\n    node: BinaryTreeNode<T> | undefined,\n): Iterable<BinaryTreeNode<T>> {\n    const stack = new LinkedStack<BinaryTreeNode<T> | undefined>([node]);\n    do {\n        node = stack.pop()!;\n        if (node != null) {\n            yield node;\n            stack.push(node.right);\n            stack.push(node.left);\n        }\n    } while (stack.size > 0);\n}\n","import { BinaryTreeNode } from 'src/tree';\nimport { clone, preOrderTraverse, toBinaryTree } from 'src/tree/utils';\nimport { CompareFn } from '..';\nimport { BinaryHeap } from './binaryHeap';\nimport { Heap } from './heap';\nimport { skewMerge } from './utils';\n\n/**\n *\n */\nexport class SkewHeap<T> implements Heap<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The node at the \"top\" of the heap.\n     */\n    protected root: BinaryTreeNode<T> | undefined;\n    /**\n     * Instantiate a heap.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>) {\n        this.compare = compareFn;\n        this.length = 0;\n        this.addAll(elements ?? []);\n    }\n\n    addAll(elements: Iterable<T>): number {\n        for (const element of elements) {\n            this.push(element);\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.root = undefined;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        for (const node of preOrderTraverse(this.root)) {\n            if (element === node.value) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    delete(element: T): boolean {\n        if (this.root == null) {\n            return false;\n        }\n        if (this.root.value === element) {\n            this.pop()!;\n            return true;\n        }\n        for (const par of preOrderTraverse(this.root)) {\n            const key: keyof BinaryTreeNode<T> | undefined =\n                par.left && par.left.value === element\n                    ? 'left'\n                    : par.right && par.right.value === element\n                    ? 'right'\n                    : undefined;\n            if (key != null) {\n                const node = par[key]!;\n                par[key] = skewMerge(this.compare, [node.left, node.right]);\n                --this.length;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    *dump(): Iterable<T> {\n        for (const node of preOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n\n    merge(heap: Heap<T>): this {\n        if (heap instanceof SkewHeap) {\n            this.root = skewMerge(this.compare, [this.root, clone(heap.root)]);\n            this.length += heap.size;\n        } else if (heap instanceof BinaryHeap) {\n            this.root = skewMerge(this.compare, [this.root, toBinaryTree(heap['array'])!]);\n            this.length += heap.size;\n        } else {\n            this.addAll(heap.dump());\n        }\n        return this;\n    }\n\n    peek(): T | undefined {\n        return this.root?.value;\n    }\n\n    pop(): T | undefined {\n        if (this.root == null) {\n            return undefined;\n        }\n        const value = this.root.value;\n        this.root = skewMerge(this.compare, [this.root.left, this.root.right]);\n        --this.length;\n        return value;\n    }\n\n    push(value: T): number {\n        this.root = skewMerge(this.compare, [this.root, { value }]);\n        return ++this.length;\n    }\n\n    pushPop(value: T): T {\n        this.push(value);\n        return this.pop()!;\n    }\n\n    replace(value: T): T | undefined {\n        if (this.root == null) {\n            this.root = { value };\n            this.length = 1;\n            return undefined;\n        }\n        const out = this.root.value;\n        this.root = skewMerge(this.compare, [this.root.left, this.root.right, { value }]);\n        return out;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n    /**\n     * Iterate through the heap in sorted order.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the heap.\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        if (this.root == null) {\n            return;\n        }\n        const heap = new SkewHeap<BinaryTreeNode<T>>((a, b) => this.compare(a.value, b.value), [\n            this.root,\n        ]);\n        do {\n            const node = heap.pop()!;\n            yield node.value;\n            node.left && heap.push(node.left);\n            node.right && heap.push(node.right);\n        } while (heap.size > 0);\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.root == null) {\n            return false;\n        }\n        if (this.root.value === curElement) {\n            this.root = skewMerge(this.compare, [\n                this.root.left,\n                this.root.right,\n                { value: newElement },\n            ]);\n            return true;\n        }\n        for (const par of preOrderTraverse(this.root)) {\n            const key: keyof BinaryTreeNode<T> | undefined =\n                par.left && par.left.value === curElement\n                    ? 'left'\n                    : par.right && par.right.value === curElement\n                    ? 'right'\n                    : undefined;\n            if (key != null) {\n                const node = par[key]!;\n                par[key] = undefined;\n                this.root = skewMerge(this.compare, [\n                    this.root,\n                    node.left,\n                    node.right,\n                    { value: newElement },\n                ]);\n                return true;\n            }\n        }\n        return false;\n    }\n}\n","import { LinkedList } from 'src/list';\nimport { BinaryTreeNode } from 'src/tree';\nimport { CompareFn } from '..';\n\n/**\n * @internal\n */\nexport function bubbleUp<T>(index: number, compareFn: CompareFn<T>, array: Array<T>): void {\n    const value = array[index];\n\n    // Until we reach the top of the heap\n    while (index > 0) {\n        // Get the parent\n        const parentIndex = Math.floor((index + 1) / 2) - 1;\n        const parent = array[parentIndex]!;\n\n        // If the parent is above or equal to value, the heap is in order\n        if (compareFn(parent, value) <= 0) {\n            break;\n        }\n\n        // Swap the parent with value and continue\n        array[parentIndex] = value;\n        array[index] = parent;\n        index = parentIndex;\n    }\n}\n/**\n * @internal\n */\nexport function heapify<T>(compareFn: CompareFn<T>, array: T[]): void {\n    for (let i = (array.length + 1) >>> 1; i > 0; sinkDown(--i, compareFn, array)) {}\n}\n/**\n * @internal\n */\nexport function sinkDown<T>(index: number, compareFn: CompareFn<T>, array: Array<T>): void {\n    const n = array.length;\n    const value = array[index];\n    do {\n        // Compute the left child's index\n        let childIndex = 2 * index + 1;\n\n        // If no children exist\n        if (childIndex >= n) {\n            break;\n        }\n\n        // Decide which child to compare with\n        let child = array[childIndex];\n        if (childIndex + 1 < n && compareFn(array[childIndex + 1], child) <= 0) {\n            child = array[++childIndex]!;\n        }\n\n        // If value <= child\n        if (compareFn(value, child) <= 0) {\n            break;\n        }\n\n        // Swap value and child\n        array[index] = child;\n        array[childIndex] = value;\n        index = childIndex;\n    } while (true);\n}\n/**\n * See: https://en.wikipedia.org/wiki/Skew_heap#Merging_two_heaps\n *\n * @param compareFn - A function used to determine the order of the heap.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n * @param heaps - An iterable of heaps to merge\n *\n * @returns The new heap\n */\nexport function skewMerge<T>(\n    compareFn: CompareFn<T>,\n    heaps: Iterable<BinaryTreeNode<T> | undefined>,\n): BinaryTreeNode<T> | undefined {\n    // Sanitize inputs\n    const list = new LinkedList<BinaryTreeNode<T>>();\n    for (const node of heaps) {\n        if (node != null) {\n            list.push(node);\n        }\n    }\n    if (list.size < 2) {\n        return list.pop()!;\n    }\n\n    // Split each heap into subtrees by cutting every path.\n    // (From the root node, sever the right node and make the right\n    // child its own subtree.) This will result in a set of trees\n    // in which the root either only has a left child or no children at all.\n    for (const node of list) {\n        if (node.right != null) {\n            list.push(node.right);\n            node.right = undefined;\n        }\n    }\n\n    // Sort the subtrees in descending order based on the\n    // value of the root node of each subtree.\n    list.sort((a, b) => compareFn(b.value, a.value));\n\n    // While there are still multiple subtrees, iteratively recombine\n    // the first two (from left to right). If the root of the second-to-first\n    // subtree has a left child, swap it to be the right child. Link the root\n    // of the last subtree as the left child of the second-to-first subtree.\n    let heap = list.shift()!;\n    do {\n        const next = list.shift()!;\n        next.right = next.left;\n        next.left = heap;\n        heap = next;\n    } while (list.size > 0);\n\n    return heap;\n}\n","import { CompareFn } from '..';\nimport { List } from './list';\nimport { batch, clamp, cwrap } from './utils';\n\n/**\n * An implementation of the {@link List} interface using an array\n */\nexport class ArrayList<T> implements List<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: Array<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    add(index: number, element: T): number {\n        if (index >= 0 && index <= this.size) {\n            this.array.splice(index, 0, element);\n        }\n        return this.size;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.size) {\n            for (const items of batch(10000, elements)) {\n                this.array.splice(index, 0, ...items);\n                index += items.length;\n            }\n        }\n        return this.size;\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    concat(...lists: Iterable<T>[]): ArrayList<T> {\n        const out = new ArrayList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        index = cwrap(index ?? 0, 0, this.size);\n        min = cwrap(min ?? 0, 0, this.size);\n        max = cwrap(max ?? this.size, 0, this.size);\n        this.array.copyWithin(index, min, max);\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.size);\n        max = cwrap(max ?? this.size, 0, this.size);\n        this.array.fill(element, min, max);\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array[index];\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        let value: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            value = this.array[index];\n            this.array[index] = callback(value);\n        }\n        return value;\n    }\n\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n\n    push(element: T): number {\n        return this.array.push(element);\n    }\n\n    remove(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array.splice(index, 1)[0];\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.size);\n        max = cwrap(max ?? this.size, 0, this.size) - 1;\n        while (min < max) {\n            const temp = this.array[min];\n            this.array[min++] = this.array[max];\n            this.array[max--] = temp;\n        }\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        let prev: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            prev = this.array[index];\n            this.array[index] = element;\n        }\n        return prev;\n    }\n\n    shift(): T | undefined {\n        return this.array.shift();\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    slice(min?: number, max?: number): ArrayList<T> {\n        return new ArrayList(this.array.slice(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = cwrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n        const list = new ArrayList(this.array.splice(start, count));\n        for (const items of batch(10000, elements ?? [])) {\n            this.array.splice(start, 0, ...items);\n            start += items.length;\n        }\n        return list;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        this.array.sort(compareFn);\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n\n    unshift(element: T): number {\n        return this.array.unshift(element);\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = cwrap((min as number) ?? 0, 0, this.size);\n        max = cwrap((max as number) ?? this.size, 0, this.size);\n        while (min < max) {\n            this.array[min] = callback(this.array[min], min);\n            ++min;\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = cwrap(min ?? 0, 0, this.size);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.size;\n        } else if (max >= 0) {\n            len = () => Math.min(max, this.size);\n        } else {\n            len = () => this.size + max;\n        }\n\n        while (min < len()) {\n            yield this.array[min++];\n        }\n    }\n}\n","import { CompareFn } from '..';\nimport { List } from './list';\nimport { clamp, mergeSort, cwrap } from './utils';\n\n/**\n * A doubly-linked node version of the {@link LinkedNode} interface.\n *\n * Each node links to its neighbors on the left (prev) and right (next) of it.\n */\nexport interface DoublyLinkedNode<T> {\n    /**\n     * A link to the node's next (right) neighbor\n     */\n    next?: DoublyLinkedNode<T>;\n    /**\n     * A link to the node's previous (left) neighbor\n     */\n    prev?: DoublyLinkedNode<T>;\n    /**\n     * The value of the node\n     */\n    value: T;\n}\n/**\n * A (circular) doubly-linked list implementation of the {@link List} interface.\n *\n * Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.\n */\nexport class DoublyLinkedList<T> implements List<T> {\n    /**\n     * The number of elements in the list\n     */\n    protected length: number;\n    /**\n     * The sentinel node at the fron of the list\n     */\n    protected root: DoublyLinkedNode<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as DoublyLinkedNode<T>;\n        this.root.prev = this.root.next = this.root;\n        this._addAll(this.root, elements ?? []);\n    }\n\n    add(index: number, value: T): number {\n        if (index < 0 || index > this.length) {\n            return this.length;\n        }\n        const prev = this._get(index - 1);\n        const node = { next: prev.next, prev, value };\n        prev.next = node;\n        node.next!.prev = node;\n        return ++this.length;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.length) {\n            this._addAll(this._get(index), elements);\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.root.prev = this.root.next = this.root;\n    }\n\n    concat(...lists: Iterable<T>[]): DoublyLinkedList<T> {\n        const out = new DoublyLinkedList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to the same section\n        index = cwrap(index, 0, this.length);\n        min = cwrap(min ?? 0, 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = cwrap(max ?? this.length, 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Check for overlap edge case\n        if (min < index && index < max) {\n            let nodeA = this._get(max);\n            let nodeB = this._get(index + (max - min));\n            do {\n                nodeA = nodeA.prev!;\n                nodeB = nodeB.prev!;\n                nodeB.value = nodeA.value;\n            } while (++min < max);\n            return this;\n        }\n\n        // Copy the section to the destination\n        let nodeA = this._get(min);\n        let nodeB = this._get(index);\n        do {\n            nodeB.value = nodeA.value;\n            nodeA = nodeA.next!;\n            nodeB = nodeB.next!;\n        } while (++min < max);\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.length);\n        max = cwrap(max ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.length ? undefined : this._get(index).value;\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const tail = this.root.prev!;\n        tail.prev!.next = this.root;\n        this.root.prev = tail.prev;\n        --this.length;\n        return tail.value;\n    }\n\n    push(value: T): number {\n        const prev = this.root.prev!;\n        const node = { next: this.root, prev, value };\n        prev.next = this.root.prev = node;\n        return ++this.length;\n    }\n\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        node.prev!.next = node.next;\n        node.next!.prev = node.prev;\n        --this.length;\n        return node.value;\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.length);\n        max = cwrap(max ?? this.length, 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        const tail = root.next!;\n        let node = tail;\n        do {\n            const temp = node.next!;\n            node.next = node.prev;\n            node.prev = temp;\n            root.next = node;\n            node = temp;\n        } while (++min < max);\n        tail.next = node;\n        node.prev = tail;\n        root.next!.prev = root;\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n\n    shift(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const head = this.root.next!;\n        head.next!.prev = this.root;\n        this.root.next = head.next;\n        --this.length;\n        return head.value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    slice(min?: number, max?: number): DoublyLinkedList<T> {\n        return new DoublyLinkedList(this.view(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = cwrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n\n        // If not modifying the list\n        const list = new DoublyLinkedList<T>();\n        if (elements == null && count < 1) {\n            return list;\n        }\n\n        // Delete elements\n        let node = this._get(start);\n        while (count-- > 0) {\n            list.push(node.value);\n            node.prev!.next = node.next!;\n            node.next!.prev = node.prev!;\n            node = node.next!;\n            --this.length;\n        }\n\n        // Add elements\n        this._addAll(node, elements ?? []);\n\n        return list;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        if (this.length > 1) {\n            const [head, tail] = mergeSort(this.root.next!, this.length, true, compareFn);\n            this.root.next = head;\n            tail.next!.prev = tail;\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let node = this.root.next!; node !== this.root; node = node.next!) {\n            yield node.value;\n        }\n    }\n\n    unshift(value: T): number {\n        const head = this.root.next!;\n        const node = { next: head, prev: this.root, value };\n        this.root.next = head.prev = node;\n        return ++this.length;\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = cwrap((min as number) ?? 0, 0, this.length);\n        max = cwrap((max as number) ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = cwrap(min ?? 0, 0, this.length);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.length;\n        } else if (max >= 0) {\n            len = () => max;\n        } else {\n            len = () => this.length + max;\n        }\n\n        if (min < len()) {\n            let node = this._get(min);\n            do {\n                yield node.value;\n                node = node.next!;\n            } while (++min < len() && node !== this.root);\n        }\n    }\n    /**\n     *\n     */\n    protected _addAll(next: DoublyLinkedNode<T>, elements: Iterable<T>): void {\n        let prev = next.prev!;\n        for (const value of elements) {\n            const node = { prev, value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        next.prev = prev;\n    }\n    /**\n     * A helper method to iterate and return the node at the given index.\n     *\n     * Depending on the index, the list will be traversed from beginning or end; whichever is closest to the specified index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number): DoublyLinkedNode<T> {\n        let node = this.root;\n        if (index < this.length / 2) {\n            while (index-- >= 0) {\n                node = node.next!;\n            }\n        } else {\n            for (index = this.length - index; index > 0; --index) {\n                node = node.prev!;\n            }\n        }\n        return node;\n    }\n}\n","import { CompareFn } from '..';\nimport { List } from './list';\nimport { clamp, mergeSort, cwrap } from './utils';\n\n/**\n * A linked node interface.\n *\n * Each node links to its next neighbor.\n */\nexport interface LinkedNode<T> {\n    /**\n     * A link to the node's neighbor\n     */\n    next?: LinkedNode<T>;\n    /**\n     * The value of the node\n     */\n    value: T;\n}\n/**\n * A (circular) linked list implementation of the {@link List} interface.\n */\nexport class LinkedList<T> implements List<T> {\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The sentinel node at the fron of the list.\n     */\n    protected root: LinkedNode<T>;\n    /**\n     * The last node of the list.\n     */\n    protected tail: LinkedNode<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as LinkedNode<T>;\n        this.root.next = this.root;\n        this.tail = this._addAll(this.root, elements ?? []);\n    }\n\n    add(index: number, value: T): number {\n        if (index >= 0 && index < this.length) {\n            const prev = this._get(index - 1);\n            prev.next = { value, next: prev.next };\n            ++this.length;\n        } else if (index === this.length) {\n            this.push(value);\n        }\n        return this.length;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index < this.length) {\n            this._addAll(this._get(index - 1), elements);\n        } else if (index === this.length) {\n            this.tail = this._addAll(this.tail, elements);\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.tail = this.root.next = this.root;\n    }\n\n    concat(...lists: Iterable<T>[]): LinkedList<T> {\n        const out = new LinkedList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to itself\n        index = cwrap(index, 0, this.length);\n        min = cwrap(min ?? 0, 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = cwrap(max ?? this.length, 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Copy to earlier in the list\n        if (index < min) {\n            const node = this._get(index - 1);\n            this._copyWithin(this._get(min - index - 1, node), node, max - min);\n            return this;\n        }\n\n        // Copy to later in the list\n        if (index > max) {\n            const node = this._get(min - 1);\n            this._copyWithin(node, this._get(index - min - 1, node), max - min);\n            return this;\n        }\n\n        // Copy to overlapping destination\n        const nodeA = this._get(min - 1);\n        const nodeC = this._get(max - min - 1, nodeA);\n        const nodeD = this._copyWithin(nodeA, nodeC, index - min);\n        if (index + (max - min) >= this.length) {\n            this.tail = nodeC;\n        }\n        const temp = nodeA.next;\n        nodeA.next = nodeC.next;\n        nodeC.next = nodeD.next;\n        nodeD.next = temp;\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.length);\n        max = cwrap(max ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        return index < this.length - 1 ? this._get(index).value : this.tail.value;\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = index < this.length - 1 ? this._get(index) : this.tail;\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const value = this.tail.value;\n        this.tail = this._get(this.length - 2);\n        this.tail.next = this.root;\n        --this.length;\n        return value;\n    }\n\n    push(value: T): number {\n        const tail: LinkedNode<T> = { next: this.root, value };\n        this.tail.next = tail;\n        this.tail = tail;\n        return ++this.length;\n    }\n\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const prev = this._get(index - 1);\n        const node = prev.next!;\n        prev.next = node.next;\n        if (index === --this.length) {\n            this.tail = prev;\n        }\n        return node.value;\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.length);\n        max = cwrap(max ?? this.length, 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        this.tail = max >= this.length ? root.next! : this.tail;\n        const tail = root.next!;\n        let prev = tail;\n        let node = tail.next!;\n        while (++min < max) {\n            const next = node.next!;\n            node.next = prev;\n            prev = node;\n            node = next;\n        }\n        root.next = prev;\n        tail.next = node;\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n\n    shift(): T | undefined {\n        return this.remove(0);\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    slice(min?: number, max?: number): LinkedList<T> {\n        return new LinkedList(this.view(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = cwrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n\n        // If not modifying the list\n        const deleted = new LinkedList<T>();\n        if (elements == null && count < 1) {\n            return deleted;\n        }\n\n        // Delete elements\n        let prev = this._get(start - 1);\n        const newTail = start + count >= this.size;\n        while (count-- > 0) {\n            const node = prev.next!;\n            deleted.push(node.value);\n            prev.next = node.next;\n            --this.length;\n        }\n\n        // Add elements\n        prev = this._addAll(prev, elements ?? []);\n        this.tail = newTail ? prev : this.tail;\n\n        return deleted;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        if (this.length > 1) {\n            const [head, tail] = mergeSort(this.root.next!, this.length, false, compareFn);\n            this.root.next = head;\n            this.tail = tail;\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let node = this.root.next!; node !== this.root; node = node.next!) {\n            yield node.value;\n        }\n    }\n\n    unshift(value: T): number {\n        return this.add(0, value);\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = cwrap((min as number) ?? 0, 0, this.length);\n        max = cwrap((max as number) ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = cwrap(min ?? 0, 0, this.length);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.length;\n        } else if (max >= 0) {\n            len = () => max;\n        } else {\n            len = () => this.length + max;\n        }\n\n        if (min < len()) {\n            let node = this._get(min);\n            do {\n                yield node.value;\n                node = node.next!;\n            } while (++min < len() && node !== this.root);\n        }\n    }\n\n    protected _addAll(prev: LinkedNode<T>, elements: Iterable<T>): LinkedNode<T> {\n        const next = prev.next!;\n        for (const value of elements) {\n            const node = { value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        return prev;\n    }\n    /**\n     * Copy values from 'from' to 'to'.\n     *\n     * @param from - The initial node to copy from\n     * @param prev - The root of the initial node to copy to\n     * @param count - The number of values to copy\n     */\n    protected _copyWithin(from: LinkedNode<T>, to: LinkedNode<T>, count: number): LinkedNode<T> {\n        while (count-- > 0) {\n            from = from.next!;\n            to = to.next!;\n            to.value = from.value;\n        }\n        return to;\n    }\n    /**\n     * Get the node at the given index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number, root: LinkedNode<T> = this.root): LinkedNode<T> {\n        let node = root!;\n        while (index-- >= 0) {\n            node = node.next!;\n        }\n        return node;\n    }\n}\n","import { CompareFn } from '..';\nimport { DoublyLinkedNode } from './doublyLinkedList';\nimport { LinkedNode } from './linkedList';\n\n/**\n * Groups an iterable into batches of a given size.\n *\n * @param size - The maximum batch size\n * @param iterable - The iterable to batch\n *\n * @returns An iterable of batches\n *\n * @internal\n */\nexport function* batch<T>(\n    size: number,\n    iterable: Iterable<T>,\n): Generator<T[], void, number | undefined> {\n    let array: T[] = [];\n    for (const value of iterable) {\n        if (array.push(value) >= size) {\n            size = (yield array) ?? size;\n            array = [];\n        }\n    }\n    if (array.length > 0) {\n        yield array;\n    }\n}\n/**\n * Limits a number to be within a given range.\n *\n * f(x, min, max) = y, where min <= y <= max\n *\n * @param num - The number to clamp\n * @param min - The minimum result value, inclusive\n * @param max - The maximum result value, inclusive\n *\n * @returns The clamped number\n *\n * @internal\n */\nexport function clamp(num: number, min: number, max: number): number {\n    return Math.min(max, Math.max(min, num));\n}\n/**\n * Wraps and then clamps a number within a given range.\n *\n * @param num - The number to wrap and then clamp\n * @param min - The minimum result value, inclusive\n * @param max - The wrap pivot and maximum result value, inclusive\n *\n * @returns The crwapped number\n *\n * @internal\n */\nexport function cwrap(num: number, min: number, max: number): number {\n    return clamp(wrap(num, max), min, max);\n}\n/**\n * Sorts a list in place.\n *\n * Works on complete lists as well as sublists and circular lists:\n * - Linked lists will keep the link to the next node beyond the sorted section\n * - Doubly linked lists will keep links to the prev and next nodes outside the sorted section\n *\n * @param node - The head of the list\n * @param len - The length of the list beginning from node\n * @param isDoubly - Whether node is a doubly linked node\n * @param compareFn - A function used to determine the order of elements.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n *\n * @returns The new head and tail of the sorted list\n *\n * @internal\n */\nexport function mergeSort<T, Node extends LinkedNode<T>>(\n    node: Node,\n    len: number,\n    isDoubly: boolean,\n    compareFn: CompareFn<T>,\n): [Node, Node] {\n    // Base case\n    if (len < 2) {\n        return [node, node];\n    }\n\n    // Split the list into two halves and sort them\n    len = len / 2;\n    const lens: [number, number] = [Math.ceil(len), Math.floor(len)];\n    const heads = mergeSort(node, lens[0], isDoubly, compareFn);\n    const tails = mergeSort(heads[1].next as Node, lens[1], isDoubly, compareFn);\n\n    // Group the heads and tails together\n    node = heads[1];\n    heads[1] = tails[0];\n    tails[0] = node;\n    tails[0].next = tails[1].next;\n\n    // Merge the sorted halves\n    const prev = (heads[0] as DoublyLinkedNode<T>).prev;\n    node = mergeSorted(heads, lens, isDoubly, compareFn);\n    isDoubly && ((node as DoublyLinkedNode<T>).prev = prev);\n\n    // Return the head and tail\n    return [node, tails[+(lens[0] < 1)]];\n}\n/**\n * Merges two sorted lists.\n *\n * @param nodes - The heads of the lists\n * @param lens - The lengths of the lists\n * @param isDoubly - Whether the lists are a doubly linked\n * @param compareFn - A function used to determine the order of elements.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n *\n * @returns The new head of the sorted list\n *\n * @internal\n */\nexport function mergeSorted<T, Node extends LinkedNode<T>>(\n    heads: [Node, Node],\n    lens: [number, number],\n    isDoubly: boolean,\n    compareFn: CompareFn<T>,\n): Node {\n    const root = {} as Node;\n\n    let node = root;\n    do {\n        const index = +(compareFn(heads[0].value, heads[1].value) > 0);\n        node.next = heads[index];\n        isDoubly && ((node.next as DoublyLinkedNode<T>).prev = node);\n        node = node.next as Node;\n        heads[index] = node.next as Node;\n        --lens[index];\n    } while (lens[0] > 0 && lens[1] > 0);\n\n    // Add any remaining nodes\n    node.next = heads[+(lens[0] < 1)];\n    isDoubly && node.next && ((node.next as DoublyLinkedNode<T>).prev = node);\n    return root.next as Node;\n}\n/**\n * Moves a given number of spaces forward in a list\n *\n * @param head - The head of the list\n * @param len - The number of spaces to move\n *\n * @returns - The node len spaces ahead from head\n *\n * @internal\n */\nexport function next<T, Node extends LinkedNode<T>>(head: Node, len: number): Node {\n    while (len-- > 0) {\n        head = head.next as Node;\n    }\n    return head;\n}\n/**\n * Wraps a number around a pivot\n *\n * f(x, min, pivot) = {\n *    x, where x >= 0\n *    pivot + x, where x < 0\n * }\n *\n * @param num - The number to wrap\n * @param pivot - The number to pivot on\n *\n * @returns - The wrapped number\n *\n * @internal\n */\nexport function wrap(num: number, pivot: number): number {\n    return num < 0 ? pivot + num : num;\n}\n","import { Queue } from './queue';\n\n/**\n * An implementation of the {@link Queue} interface using an array\n */\nexport class ArrayQueue<T> implements Queue<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * Instantiate the queue.\n     *\n     * @param elements - A set of elements to initialize the queue with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    dequeue(): T | undefined {\n        return this.size < 1 ? undefined : this.array.shift();\n    }\n\n    enqueue(element: T): number {\n        return this.array.push(element);\n    }\n\n    peek(): T | undefined {\n        return this.size < 1 ? undefined : this.array[0];\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Queue } from './queue';\n\n/**\n * A linked list implementation of the {@link Queue} interface\n */\nexport class LinkedQueue<T> implements Queue<T> {\n    /**\n     * The list containing every element.\n     */\n    protected list: List<T>;\n    /**\n     * Instantiate the queue.\n     *\n     * @param elements - A set of elements to initialize the queue with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList(elements);\n    }\n\n    clear(): void {\n        this.list.clear();\n    }\n\n    dequeue(): T | undefined {\n        return this.list.shift();\n    }\n\n    enqueue(element: T): number {\n        return this.list.push(element);\n    }\n\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","import { Stack } from './stack';\n\n/**\n * An implementation of the {@link Stack} interface using an array\n */\nexport class ArrayStack<T> implements Stack<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * Instantiate the stack.\n     *\n     * @param elements - A set of elements to initialize the stack with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    peek(): T | undefined {\n        return this.array[this.array.length - 1];\n    }\n\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n\n    push(element: T): number {\n        return this.array.push(element);\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        const array = this.array;\n        for (let i = array.length; i > 0; yield array[--i]) {}\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Stack } from './stack';\n\n/**\n * A linked list implementation of the {@link Stack} interface\n */\nexport class LinkedStack<T> implements Stack<T> {\n    /**\n     * The list containing every element.\n     */\n    protected list: List<T>;\n    /**\n     * Instantiate the stack.\n     *\n     * @param elements - A set of elements to initialize the stack with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList();\n        for (const element of elements || []) {\n            this.push(element);\n        }\n    }\n\n    clear(): void {\n        this.list.clear();\n    }\n\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n\n    pop(): T | undefined {\n        return this.list.shift();\n    }\n\n    push(element: T): number {\n        return this.list.unshift(element);\n    }\n\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}