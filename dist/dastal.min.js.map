{"version":3,"sources":["webpack://Dastal/webpack/universalModuleDefinition","webpack://Dastal/webpack/bootstrap","webpack://Dastal/webpack/runtime/define property getters","webpack://Dastal/webpack/runtime/hasOwnProperty shorthand","webpack://Dastal/webpack/runtime/make namespace object","webpack://Dastal/./src/collection/iteratorUtils.ts","webpack://Dastal/./src/math/numberUtils.ts","webpack://Dastal/./src/collection/arrayUtils.ts","webpack://Dastal/./src/collection/index.ts","webpack://Dastal/./src/heap/utils.ts","webpack://Dastal/./src/heap/binaryHeap.ts","webpack://Dastal/./src/tree/binaryTreeUtils.ts","webpack://Dastal/./src/heap/skewHeap.ts","webpack://Dastal/./src/list/arrayList.ts","webpack://Dastal/./src/list/utils.ts","webpack://Dastal/./src/list/doublyLinkedList.ts","webpack://Dastal/./src/list/linkedList.ts","webpack://Dastal/./src/math/u32.ts","webpack://Dastal/./src/queue/arrayQueue.ts","webpack://Dastal/./src/queue/linkedQueue.ts","webpack://Dastal/./src/segmentTree/inOrderSegmentTree.ts","webpack://Dastal/./src/segmentTree/levelOrderSegmentTree.ts","webpack://Dastal/./src/stack/arrayStack.ts","webpack://Dastal/./src/stack/linkedStack.ts","webpack://Dastal/./src/tree/aaTree.ts","webpack://Dastal/./src/tree/avlTree.ts"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","always","fn","next","done","fill","length","undefined","first","n","iterator","res","join","iterators","res2","never","once","skip","bind","split","iter","clamp","num","min","max","Math","wrapLeft","wrapRight","wrap","MAX_ARRAY_LENGTH","MAX_SAFE_ARGUMENT_LENGTH","isArray","Array","isTypedArray","TypedArray","getPrototypeOf","Uint8Array","splice","array","start","count","elements","maxStepSize","stepSize","maxElems","out","RangeError","isCollection","bubbleUp","index","compareFn","parentIndex","floor","parent","heapify","i","sinkDown","childIndex","child","skewMerge","heaps","lists","push","list","tree","right","compare","a","b","tail","pop","mergeKSorted","heap","node","left","BinaryHeap","this","addAll","element","indexOf","last","size","curElement","newElement","inOrderTraverse","preOrderTraverse","removeStack","stack","dir","edge","to","temp","successorStack","predecessorStack","from","label","clone","assign","leftmost","leftmostStack","rightmostStack","rightmost","search","comp","searchStack","dupeWeight","paths","toBinaryTree","nodes","par","SkewHeap","merge","comparator","ArrayList","copyWithin","callback","prev","shift","slice","sort","unshift","arguments","len","linkedMergeSort","isDoubly","lens","ceil","heads","tails","linkedMergeSorted","DoublyLinkedList","_addAll","_get","nodeA","nodeB","head","view","LinkedList","_copyWithin","nodeC","nodeD","remove","deleted","newTail","add","bitsSet","invert","msp","u32","isPow2","lsb","lsp","lsps","msb","msps","reverse","ArrayQueue","LinkedQueue","clear","InOrderSegmentTree","combine","build","mask","MAX_SIZE","set","offset","operation","dc","dp","LevelOrderSegmentTree","level","shrink","grow","aggregate","cap","ArrayStack","LinkedStack","AATree","allowDuplicates","sentinel","skew","removed","delete","AVLTree","balanceFactor","balance","rotateR","rotateL","P","R","L"],"mappings":"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","file":"dastal.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Dastal\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Dastal\"] = factory();\n\telse\n\t\troot[\"Dastal\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Get an iterator that always returns a given value.\n */\nexport function always<T = any>(fn: () => T): Iterator<T> {\n    return { next: () => ({ done: false, value: fn() }) };\n}\n/**\n * Get an iterator that returns a value a given amount of times.\n */\nexport function fill<T = any>(length: number, fn: () => T): Iterator<T> {\n    return {\n        next: () => {\n            if (length < 1) {\n                return { done: true, value: undefined };\n            }\n            --length;\n            return { done: false, value: fn() };\n        },\n    };\n}\n/**\n * Iterate through the first num elements of an iterator.\n *\n * @param n - The number of elements to iterate.\n * @param iterator - The iterator.\n *\n * @returns - An iterator limited to the next n elements.\n */\nexport function first<T = any>(n: number, iterator: Iterator<T>): Iterator<T> {\n    return {\n        next: () => {\n            if (n < 1) {\n                return { done: true, value: undefined };\n            }\n            const res = iterator.next();\n            n = res.done ? 0 : n - 1;\n            return res;\n        },\n    };\n}\n/**\n * Join multiple iterators into one.\n *\n * @param iterators - The iterators to join.\n */\nexport function join<T = any>(iterators: Iterator<Iterator<T>>): Iterator<T> {\n    let iterator: Iterator<T> | undefined = { next: () => ({ done: true, value: undefined }) };\n    return {\n        next: () => {\n            if (iterator == null) {\n                return { done: true, value: undefined };\n            }\n            let res = iterator.next();\n            while (res.done) {\n                const res2 = iterators.next();\n                if (res2.done) {\n                    iterator = undefined;\n                    return { done: true, value: undefined };\n                }\n                iterator = res2.value;\n                res = iterator.next();\n            }\n            return res;\n        },\n    };\n}\n/**\n * Get an empty iterator.\n */\nexport function never<T = any>(): Iterator<T> {\n    return { next: () => ({ done: true, value: undefined }) };\n}\n/**\n * Wrap a value in an iterator.\n */\nexport function once<T = any>(fn: () => T): Iterator<T> {\n    let done = false;\n    return {\n        next: () => {\n            const res = { done, value: fn() };\n            done = true;\n            fn = () => undefined!;\n            return res;\n        },\n    };\n}\n/**\n * Skip the next num elements of an iterator.\n *\n * @param n - The number of elements to skip.\n * @param iterator - The iterator.\n *\n * @returns - The iterator after skipping n elements.\n */\nexport function skip<T = any>(n: number, iterator: Iterator<T>): Iterator<T> {\n    let fn = () => {\n        let res: IteratorResult<T> = { done: false, value: undefined! };\n        while (n-- > 0 && !res.done) {\n            res = iterator.next();\n        }\n        fn = iterator.next.bind(iterator);\n        return res;\n    };\n    return { next: () => fn() };\n}\n/**\n * Split an iterator into multiple iterators of a given length.\n *\n * @param length - The length of each iterator.\n * @param iterator - The iterator to split.\n *\n * @returns - An iterator of the resulting iterators.\n */\nexport function split<T = any>(length: number, iterator: Iterator<T>): Iterator<Iterator<T>> {\n    if (length < 1) {\n        return { next: () => ({ done: true, value: undefined }) };\n    }\n    let done = false;\n    return {\n        next: () => {\n            if (done) {\n                return { done, value: undefined };\n            }\n            const iter = first(length, iterator);\n            const res = iter.next();\n            if (res.done) {\n                done = true;\n                return { done, value: undefined };\n            }\n            return { done, value: join([once(() => res.value), iter][Symbol.iterator]()) };\n        },\n    };\n}\n","/**\n * Limits a number to be within a given range.\n *\n * f(x, min, max) = y, where min <= y <= max\n *\n * @param num - The number to clamp\n * @param min - The minimum result value, inclusive\n * @param max - The maximum result value, inclusive\n *\n * @returns The clamped number\n */\nexport function clamp(num: number, min: number, max: number): number {\n    return Math.min(max, Math.max(min, num));\n}\n/**\n * Wraps a number if below a given range\n *\n * f(x, min, max) = {\n *    x, where x >= min\n *    max - (min - x), where x < min\n * }\n *\n * @param num - The number to wrap\n * @param min - The minimum result value, inclusive\n * @param max - The maximum result value, inclusive\n *\n * @returns - The wrapped number\n */\nexport function wrapLeft(num: number, min: number, max: number): number {\n    return num < min ? max - min + num : num;\n}\n/**\n * Wraps a number if above a given range\n *\n * f(x, min, max) = {\n *    x, where x <= max\n *    min + (x - max), where x > max\n * }\n *\n * @param num - The number to wrap\n * @param min - The minimum result value, inclusive\n * @param max - The maximum result value, inclusive\n *\n * @returns - The wrapped number\n */\nexport function wrapRight(num: number, min: number, max: number): number {\n    return num > max ? min + (num - max) : num;\n}\n/**\n * Wraps a number if outside a given range\n *\n * @param num - The number to wrap\n * @param min - The minimum result value, inclusive\n * @param max - The maximum result value, inclusive\n *\n * @returns - The wrapped number\n */\nexport function wrap(num: number, min: number, max: number): number {\n    return num < min ? max - min + num : wrapRight(num, min, max);\n}\n","import { first } from 'src/collection/iteratorUtils';\nimport { clamp, wrapLeft } from 'src/math/numberUtils';\n\n/**\n * The maximum length of an array.\n *\n * According to the [ECMA-262](https://tc39.es/ecma262/#array-index):\n *     0 <= array.length <= 2^32 - 1\n *\n * If this value should be updated, please\n * submit a pull request with details supporting a new max length.\n */\nexport const MAX_ARRAY_LENGTH = 4294967295;\n/**\n * The maximum number of arguments that can be safely accepted by a function.\n *\n * According to the [ECMA-262](https://tc39.es/ecma262/#sec-list-and-record-specification-type), there is no maximum. In practice, different\n * environments impose their own limit ([source](https://stackoverflow.com/questions/22747068/is-there-a-max-number-of-arguments-javascript-functions-can-accept)).\n *\n * This value was chosen through research, local testing and iteration. The actual number of arguments\n * accepted in an environment may be larger but hopefully not smaller. If errors are raised,\n * please submit a bug with your environment details and a new max length.\n */\nexport const MAX_SAFE_ARGUMENT_LENGTH = 32767;\n/**\n * Check if a value is an Array or TypedArray.\n *\n * @param obj - The value to check.\n *\n * @returns `true` if an Array or TypedArray, otherwise `false`.\n */\nexport function isArray<T = any>(obj: unknown): obj is T[] {\n    return obj instanceof Array || isTypedArray(obj);\n}\n/**\n * Check if a value is a TypedArray.\n *\n * See [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)\n * for more details.\n *\n * @param obj - The value to check.\n *\n * @returns `true` if a TypedArray, otherwise `false`.\n */\nexport const isTypedArray = (() => {\n    const TypedArray = Object.getPrototypeOf(Uint8Array);\n    return function isTypedArray<T = any>(obj: unknown): obj is T[] {\n        return obj instanceof TypedArray;\n    };\n})();\n/**\n * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n *\n * Contrary to Array.splice, this will not throw an error if too many new elements are given as arguments.\n *\n * @param array - The array to splice.\n * @param start - The zero-based location in the array from which to start removing elements.\n * @param count - The number of elements to remove.\n * @param elements - The new elements to splice in.\n *\n * @returns - An array containing the elements that were deleted.\n */\nexport function splice<T>(array: T[], start?: number, count?: number, elements?: Iterable<T>): T[] {\n    start = clamp(wrapLeft(start ?? 0, 0, array.length), 0, array.length);\n    count = clamp(count ?? array.length, 0, array.length - start);\n\n    // Base case\n    if (elements == null) {\n        return array.splice(start, count);\n    }\n\n    const maxStepSize = MAX_SAFE_ARGUMENT_LENGTH - 2;\n    const iterator = elements[Symbol.iterator]();\n\n    // Perform the initial splice\n    let stepSize = array.length - count;\n    const maxElems = MAX_ARRAY_LENGTH - stepSize;\n    let n = Math.min(maxStepSize, maxElems);\n    const out = array.splice(start, count, ...{ [Symbol.iterator]: () => first(n, iterator) });\n    stepSize = array.length - stepSize;\n    start += stepSize;\n\n    // Splice in new elements as long as there is space in the array\n    for (n = maxElems - stepSize; n >= maxStepSize && stepSize >= maxStepSize; n -= stepSize) {\n        stepSize = array.length;\n        array.splice(start, 0, ...{ [Symbol.iterator]: () => first(maxStepSize, iterator) });\n        stepSize = array.length - stepSize;\n        start += stepSize;\n    }\n    if (n > 0 && stepSize >= maxStepSize) {\n        array.splice(start, 0, ...{ [Symbol.iterator]: () => first(n, iterator) });\n    }\n\n    // If maximum array capacity reached\n    if (iterator.next().done != true) {\n        throw new RangeError('Invalid array length');\n    }\n\n    return out;\n}\n","import { Collection } from './collection';\n\nexport * as ArrayUtils from './arrayUtils';\nexport * from './collection';\nexport * as IteratorUtils from './iteratorUtils';\n\n/**\n * Check if a value is a {@link Collection}.\n *\n * @param obj - The value to check.\n *\n * @returns - `true` if obj is a Collection, `false` otherwise.\n */\nexport function isCollection(obj: any): obj is Collection<unknown> {\n    return (\n        obj != null && typeof obj['size'] === 'number' && typeof obj[Symbol.iterator] === 'function'\n    );\n}\n","import { LinkedNode } from 'src/list';\nimport { BinaryTreeNode } from 'src/tree/binaryTreeNode';\nimport { CompareFn } from '..';\n\n/**\n * @internal\n */\nexport function bubbleUp<T>(index: number, compareFn: CompareFn<T>, array: Array<T>): void {\n    const value = array[index];\n\n    // Until we reach the top of the heap\n    while (index > 0) {\n        // Get the parent\n        const parentIndex = Math.floor((index + 1) / 2) - 1;\n        const parent = array[parentIndex]!;\n\n        // If the parent is above or equal to value, the heap is in order\n        if (compareFn(parent, value) <= 0) {\n            break;\n        }\n\n        // Swap the parent with value and continue\n        array[parentIndex] = value;\n        array[index] = parent;\n        index = parentIndex;\n    }\n}\n/**\n * @internal\n */\nexport function heapify<T>(compareFn: CompareFn<T>, array: T[]): void {\n    for (let i = (array.length + 1) >>> 1; i > 0; sinkDown(--i, compareFn, array)) {}\n}\n/**\n * @internal\n */\nexport function mergeKSorted<T>(compareFn: CompareFn<T>, lists: LinkedNode<T>[]): LinkedNode<T> {\n    // Heapify the list of lists based on\n    // the value at the head of each list.\n    const compare: CompareFn<LinkedNode<T>> = (a, b) => compareFn(a.value, b.value);\n    heapify(compare, lists);\n\n    // Combine the lists into a single list.\n    const list: LinkedNode<T> = lists[0];\n    for (let tail = list; lists.length > 1; tail = tail.next) {\n        lists[0] = lists[0].next ?? lists.pop()!;\n        sinkDown(0, compare, lists);\n        tail.next = lists[0];\n    }\n\n    return list;\n}\n/**\n * @internal\n */\nexport function sinkDown<T>(index: number, compareFn: CompareFn<T>, array: Array<T>): void {\n    const n = array.length;\n    const value = array[index];\n    do {\n        // Compute the left child's index\n        let childIndex = 2 * index + 1;\n\n        // If no children exist\n        if (childIndex >= n) {\n            break;\n        }\n\n        // Decide which child to compare with\n        let child = array[childIndex];\n        if (childIndex + 1 < n && compareFn(array[childIndex + 1], child) <= 0) {\n            child = array[++childIndex]!;\n        }\n\n        // If value <= child\n        if (compareFn(value, child) <= 0) {\n            break;\n        }\n\n        // Swap value and child\n        array[index] = child;\n        array[childIndex] = value;\n        index = childIndex;\n    } while (true);\n}\n/**\n * See: https://en.wikipedia.org/wiki/Skew_heap#Merging_two_heaps\n *\n * @param compareFn - A function used to determine the order of the heap.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n * @param heaps - An iterable of heaps to merge\n *\n * @returns The new heap\n */\nexport function skewMerge<T>(\n    compareFn: CompareFn<T>,\n    heaps: (BinaryTreeNode<T> | undefined)[],\n): BinaryTreeNode<T> | undefined {\n    // Remove undefineds and initialize a list for each heap\n    const lists: LinkedNode<BinaryTreeNode<T>>[] = [];\n    for (let i = 0; i < heaps.length; ++i) {\n        if (heaps[i] != null) {\n            lists.push({ value: heaps[i]! });\n        }\n    }\n\n    // Check if nothing to merge with\n    if (lists.length < 2) {\n        return lists[0]?.value;\n    }\n\n    // Split each heap into subheaps by cutting every right path; From the root\n    // node, sever the right node to make the right child its own heap. Repeat\n    // until you can't go right. This will turn each heap into a list of heaps\n    // where the root either only has a left child or no children at all. The\n    // lists of heaps will be in desc order (from bottom to top).\n    for (let i = 0; i < lists.length; ++i) {\n        let list = lists[i];\n        let tree: BinaryTreeNode<T> | undefined = list.value;\n        while ((tree = tree.right)) {\n            list = { next: list, value: tree };\n        }\n        lists[i] = list;\n    }\n\n    // Combine the lists into a single list in desc order\n    let list: LinkedNode<BinaryTreeNode<T>> | undefined = mergeKSorted(\n        (a, b) => compareFn(b.value, a.value),\n        lists,\n    );\n\n    // While there are still multiple heaps, iteratively combine\n    // the first two (from left to right). If the root of the second-to-first\n    // subtree has a left child, swap it to be the right child. Link the root\n    // of the last subtree as the left child of the second-to-first subtree.\n    let heap = list.value;\n    while ((list = list.next)) {\n        const node = list.value;\n        node.right = node.left;\n        node.left = heap;\n        heap = node;\n    }\n\n    return heap;\n}\n","import { isArray, MAX_ARRAY_LENGTH } from 'src/collection/arrayUtils';\nimport { CompareFn } from '..';\nimport { Heap } from './heap';\nimport { bubbleUp, heapify, sinkDown } from './utils';\n\n/**\n * A binary heap is a heap implemented as a binary tree with an additional shape property\n * ([source](https://en.wikipedia.org/wiki/Binary_heap)).\n *\n * **Shape property**: Must be a complete binary tree. This means all levels of the tree\n * (except possibly the last one) are fully filled. If the last level of the tree is incomplete,\n * the nodes of that level are filled from left to right.\n *\n * #### Complexity\n *\n * | Property | Average | Worst |\n * | :------- | :------ | :---- |\n * | Space    | O(n)    | O(n)\n * | Push     | O(1)    | O(log n)\n * | Peek     | O(1)\t| O(1)\n * | Pop      | O(log n)| O(log n)\n * | Search   | O(n)    | O(n)\n */\nexport class BinaryHeap<T> implements Heap<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * Instantiate a heap.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>) {\n        this.compare = compareFn;\n        this.array = [];\n        this.addAll(elements ?? []);\n    }\n\n    addAll(elements: Iterable<T>): number {\n        const array = this.array;\n        const length = array.length;\n\n        if (isArray(elements)) {\n            if (array.length + elements.length > MAX_ARRAY_LENGTH) {\n                throw new RangeError('Invalid heap length');\n            }\n            for (let i = 0; i < elements.length; ++i) {\n                array.push(elements[i]);\n            }\n        } else {\n            for (const element of elements) {\n                if (array.length >= MAX_ARRAY_LENGTH) {\n                    throw new RangeError('Invalid heap length');\n                }\n                array.push(element);\n            }\n        }\n\n        // Update the heap\n        if (length < array.length) {\n            heapify(this.compare, array);\n        }\n\n        return array.length;\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        return this.array.indexOf(element) >= 0;\n    }\n\n    delete(element: T): boolean {\n        const index = this.array.indexOf(element);\n        if (index < 0) {\n            return false;\n        }\n\n        // If deleting the last value\n        const last = this.array.pop()!;\n        if (index >= this.array.length) {\n            return true;\n        }\n\n        // Add the last value to the\n        // deleted index and update the heap\n        this.array[index] = last;\n        sinkDown(index, this.compare, this.array);\n        bubbleUp(index, this.compare, this.array);\n        return true;\n    }\n\n    merge(heap: Heap<T>): this {\n        const array = this.array;\n\n        if (heap.size < 1) {\n            return this;\n        }\n\n        if (array.length + heap.size > MAX_ARRAY_LENGTH) {\n            throw new RangeError('Invalid heap length');\n        }\n\n        for (const element of heap) {\n            array.push(element);\n        }\n\n        heapify(this.compare, array);\n        return this;\n    }\n\n    peek(): T | undefined {\n        return this.array.length > 0 ? this.array[0] : undefined;\n    }\n\n    pop(): T | undefined {\n        if (this.array.length < 1) {\n            return undefined;\n        }\n\n        // Get the root and the last value\n        const value = this.array[0];\n        const last = this.array.pop();\n\n        // If value != last\n        if (this.array.length > 0) {\n            // Move the last value to the root and update the heap\n            this.array[0] = last!;\n            sinkDown(0, this.compare, this.array);\n        }\n\n        return value;\n    }\n\n    push(value: T): number {\n        // Add new value to the end of the heap\n        this.array.push(value);\n\n        // Update the heap\n        bubbleUp(this.array.length - 1, this.compare, this.array);\n        return this.size;\n    }\n\n    pushPop(value: T): T {\n        // If empty or value is <= to root\n        if (this.array.length < 1 || this.compare(value, this.array[0]) <= 0) {\n            return value;\n        }\n\n        // Swap the root and value\n        const root = this.array[0];\n        this.array[0] = value;\n        sinkDown(0, this.compare, this.array);\n        return root;\n    }\n\n    replace(value: T): T | undefined {\n        // If empty\n        if (this.array.length < 1) {\n            this.array.push(value);\n            return undefined;\n        }\n\n        // Swap the root with value\n        const root = this.array[0];\n        this.array[0] = value;\n        value = root;\n\n        // Update the heap\n        sinkDown(0, this.compare, this.array);\n        return value;\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    *sorted(): Iterable<T> {\n        if (this.array.length < 1) {\n            return;\n        }\n        const array = this.array;\n        const heap = new BinaryHeap<number>((a, b) => this.compare(array[a], array[b]), [0]);\n        do {\n            let index = heap.pop()!;\n            if (index < array.length) {\n                yield array[index];\n                index = 2 * index + 1;\n                index < array.length && heap.push(index);\n                ++index < array.length && heap.push(index);\n            }\n        } while (heap.size > 0);\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        const index = this.array.indexOf(curElement);\n        if (index < 0) {\n            return false;\n        }\n        this.array[index] = newElement;\n        sinkDown(index, this.compare, this.array);\n        bubbleUp(index, this.compare, this.array);\n        return true;\n    }\n}\n","import { LinkedNode } from 'src/list';\nimport { CompareFn } from '..';\nimport { BinaryTreeNode } from './binaryTreeNode';\n\n/**\n * @internal\n */\nexport interface Edge<Node extends BinaryTreeNode<unknown>> {\n    label?: 'left' | 'right';\n    from?: Node;\n    to?: Node;\n}\n/**\n * [source](https://stackoverflow.com/questions/51419176/how-to-get-a-subset-of-keyof-t-whose-value-tk-are-callable-functions-in-typ)\n * \n * @internal\n *\nexport type KeyOfType<T, U> = {[K in keyof T]: T[K] extends U ? K: never}[keyof T];\n*/\n/**\n * @internal\n */\nexport function debug<N extends BinaryTreeNode<T>, T = any>(\n    root: N | undefined,\n    mapFn?: (node: N) => any,\n): void {\n    mapFn = mapFn == null ? (n) => n.value : mapFn;\n\n    // Turn the tree into an array in level-order\n    const array: string[] = [];\n    for (const node of levelOrderTraverse(root, true)) {\n        array.push(node ? `${mapFn(node)}` : '?');\n    }\n\n    // If empty\n    if (array.length < 1) {\n        console.log('<empty>\\n');\n        return;\n    }\n\n    // Find the longest value string\n    const lenV = array.reduce((p, c) => Math.max(p, c.length), 0);\n\n    // Pad each value\n    for (let i = 0; i < array.length; ++i) {\n        array[i] = pad(array[i], lenV, ' ');\n    }\n\n    // Split values into levels\n    const levels = [];\n    for (let n = 1; array.length > 0; n *= 2) {\n        levels.push(array.splice(0, n));\n    }\n\n    // Initialize formatting variables\n    let branch = '_'.repeat(1 + lenV / 2);\n    let offset = '';\n    const offsetOffset = ' '.repeat(branch.length);\n    let separator = ' '.repeat(1 + ((lenV - 1) & 1));\n    const separatorOffset = ' '.repeat(lenV);\n\n    // Build the last level\n    array.length = levels.length;\n    array[array.length - 1] = levels.pop()!.join(separator);\n\n    // Build remaining levels in reverse\n    for (let n = levels.length - 1; n >= 0; --n) {\n        const level = levels.pop()!;\n        for (let j = 0; j < level.length; ++j) {\n            level[j] = branch + level[j] + branch;\n        }\n        array[n] = offset + level.join(separator);\n        branch += branch;\n        offset += offset + offsetOffset;\n        separator += separator + separatorOffset;\n    }\n\n    // Output\n    console.log(array.join('\\n'), '\\n');\n}\n/**\n * @internal\n */\nexport function removeStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n    dir = true,\n): LinkedNode<Edge<Node>> {\n    let edge = stack.value;\n    let node = edge.to;\n\n    // Input check\n    if (node == null) {\n        return stack;\n    }\n\n    // Find the replacement\n    if (node.right == null) {\n        // If no right child, replace with left\n        node = node.left;\n    } else if (node.left == null) {\n        // If no left child, replace with right\n        node = node.right;\n    } else if (dir) {\n        // Replace with the successor\n        stack = successorStack(stack);\n        edge = stack.value;\n        const temp = edge.to!;\n        node.value = temp.value;\n        node = temp.right;\n    } else {\n        // Replace with the predecessor\n        stack = predecessorStack(stack);\n        edge = stack.value;\n        const temp = edge.to!;\n        node.value = temp.value;\n        node = temp.left;\n    }\n\n    // Make the replacement / update the tree\n    edge.to = node;\n    if (edge.from) {\n        edge.from[edge.label!] = edge.to = node;\n    }\n\n    return stack;\n}\n/**\n * @internal\n */\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: undefined): undefined;\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: Node): Node;\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: Node | undefined): Node | undefined;\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: Node | undefined): Node | undefined {\n    if (node == null) {\n        return undefined;\n    }\n    const out: Node = Object.assign({}, node);\n    let stack: LinkedNode<Node> | undefined = { value: out };\n    do {\n        node = stack.value;\n        stack = stack.next;\n        if (node.left) {\n            stack = { next: stack, value: (node.left = Object.assign({}, node.left)) };\n        }\n        if (node.right) {\n            stack = { next: stack, value: (node.right = Object.assign({}, node.right)) };\n        }\n    } while (stack);\n    return out;\n}\n/**\n * @internal\n */\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(node: undefined): undefined;\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(node: Node): Node;\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined;\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined {\n    if (node == null) {\n        return undefined;\n    }\n    while (node.left) {\n        node = node.left;\n    }\n    return node;\n}\n/**\n * @internal\n */\nexport function leftmostStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    let node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    while (node.left) {\n        stack = { next: stack, value: { label: 'left', from: node, to: node.left } };\n        node = node.left;\n    }\n    return stack;\n}\n/**\n * @internal\n */\nexport function* inOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    let stack: LinkedNode<Node> | undefined = undefined;\n\n    while (node) {\n        stack = { next: stack, value: node };\n        node = node.left;\n    }\n\n    while (stack) {\n        node = stack.value;\n        stack = stack.next;\n        yield node;\n        node = node.right;\n        while (node) {\n            stack = { next: stack, value: node };\n            node = node.left;\n        }\n    }\n}\n/**\n * @internal\n */\nexport function levelOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n    padded?: false,\n): Generator<Node>;\nexport function levelOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n    padded: true,\n): Generator<Node | undefined>;\nexport function* levelOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n    padded = false,\n): Generator<Node | undefined> {\n    const nil = {} as LinkedNode<Node | undefined>;\n    let head: LinkedNode<Node | undefined> = { value: node };\n    let tail = head;\n    for (let cont = node != null; cont; head = head.next!) {\n        tail = tail.next = nil;\n        for (cont = false; head !== nil; head = head.next!) {\n            node = head.value;\n            if (node) {\n                yield node;\n                cont ||= node.left != null || node.right != null;\n                tail = tail.next = { value: node.left };\n                tail = tail.next = { value: node.right };\n            } else if (padded) {\n                yield undefined;\n                tail = tail.next = { value: undefined };\n                tail = tail.next = { value: undefined };\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nfunction pad(str: string, maxLen: number, fillString: string): string {\n    const len = str.length;\n    if (len >= maxLen) {\n        return str;\n    }\n    const diff = maxLen - len;\n    return str.padStart(len + diff / 2, fillString).padEnd(len + diff, fillString);\n}\n/**\n * @internal\n */\nexport function* postOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    interface Meta {\n        seen: boolean;\n        node?: Node;\n    }\n    let stack: LinkedNode<Meta> | undefined = { value: { seen: false, node } };\n    do {\n        const meta = stack.value;\n        stack = stack.next;\n        if (meta.node) {\n            if (meta.seen) {\n                yield meta.node;\n            } else {\n                meta.seen = true;\n                stack = { next: stack, value: meta };\n                stack = { next: stack, value: { seen: false, node: meta.node.right } };\n                stack = { next: stack, value: { seen: false, node: meta.node.left } };\n            }\n        }\n    } while (stack);\n}\n/**\n * @internal\n */\nexport function predecessor<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined {\n    return node == null ? undefined : rightmost(node.left);\n}\n/**\n * @internal\n */\nexport function predecessorStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    const node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    stack = { next: stack, value: { label: 'left', from: node, to: node.left } };\n    return rightmostStack(stack);\n}\n/**\n * @internal\n */\nexport function* preOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    let stack: LinkedNode<Node | undefined> | undefined = { value: node };\n    do {\n        node = stack.value;\n        stack = stack.next;\n        if (node) {\n            yield node;\n            stack = { next: stack, value: node.right };\n            stack = { next: stack, value: node.left };\n        }\n    } while (stack);\n}\n/**\n * @internal\n */\nexport function reverse<Node extends BinaryTreeNode<unknown>>(root?: Node): void {\n    if (root == null) {\n        return;\n    }\n    for (const node of preOrderTraverse(root)) {\n        const left = node.left;\n        node.left = node.right;\n        node.right = left;\n    }\n}\n/**\n * @internal\n */\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(node: undefined): undefined;\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(node: Node): Node;\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined;\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined {\n    if (node == null) {\n        return undefined;\n    }\n    while (node.right) {\n        node = node.right;\n    }\n    return node;\n}\n/**\n * @internal\n */\nexport function rightmostStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    let node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    while (node.right) {\n        stack = { next: stack, value: { label: 'right', from: node, to: node.right } };\n        node = node.right;\n    }\n    return stack;\n}\n/**\n * Assumes sorted by compareFn\n * @internal\n */\nexport function search<T, Node extends BinaryTreeNode<T>>(\n    element: T,\n    node: Node | undefined,\n    compareFn: CompareFn<T>,\n): Node | undefined {\n    while (node) {\n        const comp: number = compareFn(element, node.value);\n        if (comp == 0) {\n            break;\n        }\n        node = comp < 0 ? node.left : node.right;\n    }\n    return node;\n}\n/**\n * Assumes sorted by compareFn\n * @internal\n */\nexport function searchStack<T, Node extends BinaryTreeNode<T>>(\n    element: T,\n    stack: LinkedNode<Edge<Node>>,\n    compareFn: CompareFn<T>,\n    dupeWeight = 0,\n): LinkedNode<Edge<Node>> {\n    const paths: ['left', 'right'] = ['left', 'right'];\n    let node = stack.value.to;\n    while (node) {\n        const comp: number = compareFn(element, node.value) || dupeWeight;\n        if (comp === 0) {\n            break;\n        }\n        const label = paths[+(comp > 0)];\n        stack = { next: stack, value: { label, from: node, to: node[label] } };\n        node = node[label]!;\n    }\n    return stack;\n}\n/**\n * @internal\n */\nexport function successor<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined {\n    return node == null ? undefined : leftmost(node.right);\n}\n/**\n * @internal\n */\nexport function successorStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    const node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    stack = { next: stack, value: { label: 'right', from: node, to: node.right } };\n    return leftmostStack(stack);\n}\n/**\n * Turn an array into a binary tree. Assumes elements are in level-order.\n *\n * @internal\n */\nexport function toBinaryTree<T>(\n    elements: (T | undefined)[] | undefined,\n): BinaryTreeNode<T> | undefined {\n    if (elements == null || elements.length < 1 || elements[0] == null) {\n        return undefined;\n    }\n    const n = elements.length;\n    const nodes: BinaryTreeNode<T>[] = new Array(n);\n    nodes[0] = { value: elements[0] };\n    for (let i = 1; i < n; ++i) {\n        if (elements[i] == null) {\n            continue;\n        }\n        const par = nodes[(i - 1) >>> 1];\n        const node = { value: elements[i]! };\n        nodes[i] = node;\n        if (i & 1) {\n            par.left = node;\n        } else {\n            par.right = node;\n        }\n    }\n    return nodes[0];\n}\n","import { isArray } from 'src/collection/arrayUtils';\nimport { BinaryTreeNode } from 'src/tree/binaryTreeNode';\nimport { clone, preOrderTraverse, toBinaryTree } from 'src/tree/binaryTreeUtils';\nimport { CompareFn } from '..';\nimport { BinaryHeap } from './binaryHeap';\nimport { Heap } from './heap';\nimport { skewMerge } from './utils';\n\n/**\n * A skew heap is a heap implemented as a binary tree\n * ([source](https://en.wikipedia.org/wiki/Skew_heap)).\n *\n * A skew heap is a self-adjusting heap which attempts to maintain balance\n * by unconditionally swapping all nodes in the merge path when merging two heaps. Every\n * operation that modifies the heap (e.g. push, pop, merge) is considered a merge and is done\n * by using a skew heap merge.\n *\n * Skew heaps can merge more quickly than binary heaps. This can seem contradictory, since\n * skew heaps have no structural constraints and no guarantee that the height of the tree is\n * logarithmic (i.e. balanced). However, amortized complexity analysis can demonstrate that\n * all operations on a skew heap can be done in O(log(n). More specifically, the\n * amortized complexity is known to be log<sub></sub>(n) where  is the golden ratio. This is\n * approximately 1.44*log<sub>2</sub>(n).\n *\n * #### Complexity\n *\n * | Property | Average  | Worst |\n * | :------- | :------  | :---- |\n * | Space    | O(n)     | O(n)\n * | Push     | O(log n) | O(log n)\n * | Peek     | O(1)\t | O(1)\n * | Pop      | O(log n) | O(log n)\n * | Search   | O(n)     | O(n)\n */\nexport class SkewHeap<T> implements Heap<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The node at the \"top\" of the heap.\n     */\n    protected root: BinaryTreeNode<T> | undefined;\n    /**\n     * Instantiate a heap.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the heap with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>) {\n        this.compare = compareFn;\n        this.length = 0;\n        this.addAll(elements ?? []);\n    }\n\n    addAll(elements: Iterable<T>): number {\n        if (isArray(elements)) {\n            for (let i = 0; i < elements.length; ++i) {\n                this.push(elements[i]);\n            }\n        } else if (elements instanceof SkewHeap || elements instanceof BinaryHeap) {\n            this.merge(elements);\n        } else {\n            for (const element of elements) {\n                this.push(element);\n            }\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.root = undefined;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        for (const node of preOrderTraverse(this.root)) {\n            if (element === node.value) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    delete(element: T): boolean {\n        if (this.root == null) {\n            return false;\n        }\n        if (this.root.value === element) {\n            this.pop()!;\n            return true;\n        }\n        for (const par of preOrderTraverse(this.root)) {\n            const key: keyof BinaryTreeNode<T> | undefined =\n                par.left && par.left.value === element\n                    ? 'left'\n                    : par.right && par.right.value === element\n                    ? 'right'\n                    : undefined;\n            if (key != null) {\n                const node = par[key]!;\n                par[key] = skewMerge(this.compare, [node.left, node.right]);\n                --this.length;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    merge(heap: Heap<T>): this {\n        if (this.compare !== heap.comparator()) {\n            this.addAll(heap);\n        } else if (heap instanceof SkewHeap) {\n            this.root = skewMerge(this.compare, [this.root, clone(heap.root)]);\n            this.length += heap.size;\n        } else if (heap instanceof BinaryHeap) {\n            this.root = skewMerge(this.compare, [this.root, toBinaryTree(heap['array'])!]);\n            this.length += heap.size;\n        } else {\n            this.addAll(heap);\n        }\n        return this;\n    }\n\n    peek(): T | undefined {\n        return this.root?.value;\n    }\n\n    pop(): T | undefined {\n        if (this.root == null) {\n            return undefined;\n        }\n        const value = this.root.value;\n        this.root = skewMerge(this.compare, [this.root.left, this.root.right]);\n        --this.length;\n        return value;\n    }\n\n    push(value: T): number {\n        this.root = skewMerge(this.compare, [this.root, { value }]);\n        return ++this.length;\n    }\n\n    pushPop(value: T): T {\n        this.push(value);\n        return this.pop()!;\n    }\n\n    replace(value: T): T | undefined {\n        if (this.root == null) {\n            this.root = { value };\n            this.length = 1;\n            return undefined;\n        }\n        const out = this.root.value;\n        this.root = skewMerge(this.compare, [this.root.left, this.root.right, { value }]);\n        return out;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        if (this.root == null) {\n            return;\n        }\n        const heap = new SkewHeap<BinaryTreeNode<T>>(\n            (a, b) => this.compare(a.value, b.value),\n            [this.root],\n        );\n        do {\n            const node = heap.pop()!;\n            yield node.value;\n            node.left && heap.push(node.left);\n            node.right && heap.push(node.right);\n        } while (heap.size > 0);\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.root == null) {\n            return false;\n        }\n\n        if (this.root.value === curElement) {\n            this.root = skewMerge(this.compare, [\n                this.root.left,\n                this.root.right,\n                { value: newElement },\n            ]);\n            return true;\n        }\n\n        let node: BinaryTreeNode<T> | undefined = undefined;\n        for (const par of preOrderTraverse(this.root)) {\n            if (par.left && par.left.value === curElement) {\n                node = par.left;\n                par.left = undefined;\n                break;\n            }\n            if (par.right && par.right.value === curElement) {\n                node = par.right;\n                par.right = undefined;\n                break;\n            }\n        }\n\n        if (node == null) {\n            return false;\n        }\n\n        this.root = skewMerge(this.compare, [\n            this.root,\n            node.left,\n            node.right,\n            { value: newElement },\n        ]);\n        return true;\n    }\n}\n","import { splice } from 'src/collection/arrayUtils';\nimport { clamp, wrapLeft } from 'src/math/numberUtils';\nimport { CompareFn } from '..';\nimport { List } from './list';\n\n/**\n * An implementation of the {@link List} interface using an array\n */\nexport class ArrayList<T> implements List<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: Array<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    add(index: number, element: T): number {\n        if (index >= 0 && index <= this.size) {\n            this.array.splice(index, 0, element);\n        }\n        return this.size;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.size) {\n            splice(this.array, index, 0, elements);\n        }\n        return this.size;\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    concat(...lists: Iterable<T>[]): ArrayList<T> {\n        const out = new ArrayList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        index = clamp(wrapLeft(index, 0, this.size), 0, this.size);\n        min = clamp(wrapLeft(min ?? 0, 0, this.size), 0, this.size);\n        max = clamp(wrapLeft(max ?? this.size, 0, this.size), 0, this.size);\n        this.array.copyWithin(index, min, max);\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.size), 0, this.size);\n        max = clamp(wrapLeft(max ?? this.size, 0, this.size), 0, this.size);\n        this.array.fill(element, min, max);\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array[index];\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        let value: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            value = this.array[index];\n            this.array[index] = callback(value);\n        }\n        return value;\n    }\n\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n\n    push(element: T): number {\n        return this.array.push(element);\n    }\n\n    remove(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array.splice(index, 1)[0];\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.size), 0, this.size);\n        max = clamp(wrapLeft(max ?? this.size, 0, this.size), 0, this.size) - 1;\n        while (min < max) {\n            const temp = this.array[min];\n            this.array[min++] = this.array[max];\n            this.array[max--] = temp;\n        }\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        let prev: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            prev = this.array[index];\n            this.array[index] = element;\n        }\n        return prev;\n    }\n\n    shift(): T | undefined {\n        return this.array.shift();\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    slice(min?: number, max?: number): ArrayList<T> {\n        return new ArrayList(this.array.slice(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        return new ArrayList(splice(this.array, start, count, elements));\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        this.array.sort(compareFn);\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n\n    unshift(element: T): number {\n        return this.array.unshift(element);\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = clamp(wrapLeft((min as number) ?? 0, 0, this.size), 0, this.size);\n        max = clamp(wrapLeft((max as number) ?? this.size, 0, this.size), 0, this.size);\n        while (min < max) {\n            this.array[min] = callback(this.array[min], min);\n            ++min;\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = clamp(wrapLeft(min ?? 0, 0, this.size), 0, this.size);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.size;\n        } else if (max >= 0) {\n            len = () => Math.min(max, this.size);\n        } else {\n            len = () => this.size + max;\n        }\n\n        while (min < len()) {\n            yield this.array[min++];\n        }\n    }\n}\n","import { CompareFn } from '..';\nimport { DoublyLinkedNode } from './doublyLinkedNode';\nimport { LinkedNode } from './linkedNode';\n\n/**\n * Sorts a list in place.\n *\n * Works on complete lists as well as sublists and circular lists:\n * - Linked lists will keep the link to the next node beyond the sorted section\n * - Doubly linked lists will keep links to the prev and next nodes outside the sorted section\n *\n * @param node - The head of the list\n * @param len - The length of the list beginning from node\n * @param isDoubly - Whether node is a doubly linked node\n * @param compareFn - A function used to determine the order of elements.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n *\n * @returns The new head and tail of the sorted list\n *\n * @internal\n */\nexport function linkedMergeSort<T, Node extends LinkedNode<T>>(\n    node: Node,\n    len: number,\n    isDoubly: boolean,\n    compareFn: CompareFn<T>,\n): [Node, Node] {\n    // Base case\n    if (len < 2) {\n        return [node, node];\n    }\n\n    // Split the list into two halves and sort them\n    len = len / 2;\n    const lens: [number, number] = [Math.ceil(len), Math.floor(len)];\n    const heads = linkedMergeSort(node, lens[0], isDoubly, compareFn);\n    const tails = linkedMergeSort(heads[1].next as Node, lens[1], isDoubly, compareFn);\n\n    // Group the heads and tails together\n    node = heads[1];\n    heads[1] = tails[0];\n    tails[0] = node;\n    tails[0].next = tails[1].next;\n\n    // Merge the sorted halves\n    const prev = (heads[0] as DoublyLinkedNode<T>).prev;\n    node = linkedMergeSorted(heads, lens, isDoubly, compareFn);\n    if (isDoubly) {\n        (node as DoublyLinkedNode<T>).prev = prev;\n    }\n\n    // Return the head and tail\n    return [node, tails[+(lens[0] < 1)]];\n}\n/**\n * Merges two sorted lists.\n *\n * @param nodes - The heads of the lists\n * @param lens - The lengths of the lists\n * @param isDoubly - Whether the lists are a doubly linked\n * @param compareFn - A function used to determine the order of elements.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n *\n * @returns The new head of the sorted list\n *\n * @internal\n */\nexport function linkedMergeSorted<T, Node extends LinkedNode<T>>(\n    heads: [Node, Node],\n    lens: [number, number],\n    isDoubly: boolean,\n    compareFn: CompareFn<T>,\n): Node {\n    const root = {} as Node;\n\n    let node = root;\n    do {\n        const index = +(compareFn(heads[0].value, heads[1].value) > 0);\n        node.next = heads[index];\n        if (isDoubly) {\n            (node.next as DoublyLinkedNode<T>).prev = node;\n        }\n        node = node.next as Node;\n        heads[index] = node.next as Node;\n        --lens[index];\n    } while (lens[0] > 0 && lens[1] > 0);\n\n    // Add any remaining nodes\n    node.next = heads[+(lens[0] < 1)];\n    if (isDoubly && node.next) {\n        (node.next as DoublyLinkedNode<T>).prev = node;\n    }\n    return root.next as Node;\n}\n","import { clamp, wrapLeft } from 'src/math/numberUtils';\nimport { CompareFn } from '..';\nimport { DoublyLinkedNode } from './doublyLinkedNode';\nimport { List } from './list';\nimport { linkedMergeSort } from './utils';\n\n/**\n * A (circular) doubly-linked list implementation of the {@link List} interface.\n *\n * Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.\n */\nexport class DoublyLinkedList<T> implements List<T> {\n    /**\n     * The number of elements in the list\n     */\n    protected length: number;\n    /**\n     * The sentinel node at the fron of the list\n     */\n    protected root: DoublyLinkedNode<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as DoublyLinkedNode<T>;\n        this.root.prev = this.root.next = this.root;\n        this._addAll(this.root, elements ?? []);\n    }\n\n    add(index: number, value: T): number {\n        if (index < 0 || index > this.length) {\n            return this.length;\n        }\n        const prev = this._get(index - 1);\n        const node = { next: prev.next, prev, value };\n        prev.next = node;\n        node.next!.prev = node;\n        return ++this.length;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.length) {\n            this._addAll(this._get(index), elements);\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.root.prev = this.root.next = this.root;\n    }\n\n    concat(...lists: Iterable<T>[]): DoublyLinkedList<T> {\n        const out = new DoublyLinkedList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to the same section\n        index = clamp(wrapLeft(index, 0, this.length), 0, this.length);\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Check for overlap edge case\n        if (min < index && index < max) {\n            let nodeA = this._get(max);\n            let nodeB = this._get(index + (max - min));\n            do {\n                nodeA = nodeA.prev!;\n                nodeB = nodeB.prev!;\n                nodeB.value = nodeA.value;\n            } while (++min < max);\n            return this;\n        }\n\n        // Copy the section to the destination\n        let nodeA = this._get(min);\n        let nodeB = this._get(index);\n        do {\n            nodeB.value = nodeA.value;\n            nodeA = nodeA.next!;\n            nodeB = nodeB.next!;\n        } while (++min < max);\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.length ? undefined : this._get(index).value;\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const tail = this.root.prev!;\n        tail.prev!.next = this.root;\n        this.root.prev = tail.prev;\n        --this.length;\n        return tail.value;\n    }\n\n    push(value: T): number {\n        const prev = this.root.prev!;\n        const node = { next: this.root, prev, value };\n        prev.next = this.root.prev = node;\n        return ++this.length;\n    }\n\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        node.prev!.next = node.next;\n        node.next!.prev = node.prev;\n        --this.length;\n        return node.value;\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        const tail = root.next!;\n        let node = tail;\n        do {\n            const temp = node.next!;\n            node.next = node.prev;\n            node.prev = temp;\n            root.next = node;\n            node = temp;\n        } while (++min < max);\n        tail.next = node;\n        node.prev = tail;\n        root.next!.prev = root;\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n\n    shift(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const head = this.root.next!;\n        head.next!.prev = this.root;\n        this.root.next = head.next;\n        --this.length;\n        return head.value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    slice(min?: number, max?: number): DoublyLinkedList<T> {\n        return new DoublyLinkedList(this.view(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = clamp(wrapLeft(start ?? 0, 0, this.length), 0, this.length);\n        count = clamp(count ?? this.size, 0, this.size - start);\n\n        // If not modifying the list\n        const list = new DoublyLinkedList<T>();\n        if (elements == null && count < 1) {\n            return list;\n        }\n\n        // Delete elements\n        let node = this._get(start);\n        while (count-- > 0) {\n            list.push(node.value);\n            node.prev!.next = node.next!;\n            node.next!.prev = node.prev!;\n            node = node.next!;\n            --this.length;\n        }\n\n        // Add elements\n        this._addAll(node, elements ?? []);\n\n        return list;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        if (this.length > 1) {\n            const [head, tail] = linkedMergeSort(this.root.next!, this.length, true, compareFn);\n            this.root.next = head;\n            tail.next!.prev = tail;\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let node = this.root.next!; node !== this.root; node = node.next!) {\n            yield node.value;\n        }\n    }\n\n    unshift(value: T): number {\n        const head = this.root.next!;\n        const node = { next: head, prev: this.root, value };\n        this.root.next = head.prev = node;\n        return ++this.length;\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = clamp(wrapLeft((min as number) ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft((max as number) ?? this.length, 0, this.length), 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.length;\n        } else if (max >= 0) {\n            len = () => max;\n        } else {\n            len = () => this.length + max;\n        }\n\n        if (min < len()) {\n            let node = this._get(min);\n            do {\n                yield node.value;\n                node = node.next!;\n            } while (++min < len() && node !== this.root);\n        }\n    }\n    /**\n     *\n     */\n    protected _addAll(next: DoublyLinkedNode<T>, elements: Iterable<T>): void {\n        let prev = next.prev!;\n        for (const value of elements) {\n            const node = { prev, value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        next.prev = prev;\n    }\n    /**\n     * A helper method to iterate and return the node at the given index.\n     *\n     * Depending on the index, the list will be traversed from beginning or end; whichever is closest to the specified index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number): DoublyLinkedNode<T> {\n        let node = this.root;\n        if (index < this.length / 2) {\n            while (index-- >= 0) {\n                node = node.next!;\n            }\n        } else {\n            for (index = this.length - index; index > 0; --index) {\n                node = node.prev!;\n            }\n        }\n        return node;\n    }\n}\n","import { clamp, wrapLeft } from 'src/math/numberUtils';\nimport { CompareFn } from '..';\nimport { LinkedNode } from './linkedNode';\nimport { List } from './list';\nimport { linkedMergeSort } from './utils';\n\n/**\n * A (circular) linked list implementation of the {@link List} interface.\n */\nexport class LinkedList<T> implements List<T> {\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The sentinel node at the front of the list.\n     */\n    protected root: LinkedNode<T>;\n    /**\n     * The last node of the list.\n     */\n    protected tail: LinkedNode<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as LinkedNode<T>;\n        this.root.next = this.root;\n        this.tail = this._addAll(this.root, elements ?? []);\n    }\n\n    add(index: number, value: T): number {\n        if (index >= 0 && index < this.length) {\n            const prev = this._get(index - 1);\n            prev.next = { value, next: prev.next };\n            ++this.length;\n        } else if (index === this.length) {\n            this.push(value);\n        }\n        return this.length;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index < this.length) {\n            this._addAll(this._get(index - 1), elements);\n        } else if (index === this.length) {\n            this.tail = this._addAll(this.tail, elements);\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.tail = this.root.next = this.root;\n    }\n\n    concat(...lists: Iterable<T>[]): LinkedList<T> {\n        const out = new LinkedList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to itself\n        index = clamp(wrapLeft(index, 0, this.length), 0, this.length);\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Copy to earlier in the list\n        if (index < min) {\n            const node = this._get(index - 1);\n            this._copyWithin(this._get(min - index - 1, node), node, max - min);\n            return this;\n        }\n\n        // Copy to later in the list\n        if (index > max) {\n            const node = this._get(min - 1);\n            this._copyWithin(node, this._get(index - min - 1, node), max - min);\n            return this;\n        }\n\n        // Copy to overlapping destination\n        const nodeA = this._get(min - 1);\n        const nodeC = this._get(max - min - 1, nodeA);\n        const nodeD = this._copyWithin(nodeA, nodeC, index - min);\n        if (index + (max - min) >= this.length) {\n            this.tail = nodeC;\n        }\n        const temp = nodeA.next;\n        nodeA.next = nodeC.next;\n        nodeC.next = nodeD.next;\n        nodeD.next = temp;\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        return index < this.length - 1 ? this._get(index).value : this.tail.value;\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = index < this.length - 1 ? this._get(index) : this.tail;\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const value = this.tail.value;\n        this.tail = this._get(this.length - 2);\n        this.tail.next = this.root;\n        --this.length;\n        return value;\n    }\n\n    push(value: T): number {\n        const tail: LinkedNode<T> = { next: this.root, value };\n        this.tail.next = tail;\n        this.tail = tail;\n        return ++this.length;\n    }\n\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const prev = this._get(index - 1);\n        const node = prev.next!;\n        prev.next = node.next;\n        if (index === --this.length) {\n            this.tail = prev;\n        }\n        return node.value;\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        this.tail = max >= this.length ? root.next! : this.tail;\n        const tail = root.next!;\n        let prev = tail;\n        let node = tail.next!;\n        while (++min < max) {\n            const next = node.next!;\n            node.next = prev;\n            prev = node;\n            node = next;\n        }\n        root.next = prev;\n        tail.next = node;\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n\n    shift(): T | undefined {\n        return this.remove(0);\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    slice(min?: number, max?: number): LinkedList<T> {\n        return new LinkedList(this.view(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = clamp(wrapLeft(start ?? 0, 0, this.length), 0, this.length);\n        count = clamp(count ?? this.size, 0, this.size - start);\n\n        // If not modifying the list\n        const deleted = new LinkedList<T>();\n        if (elements == null && count < 1) {\n            return deleted;\n        }\n\n        // Delete elements\n        let prev = this._get(start - 1);\n        const newTail = start + count >= this.size;\n        while (count-- > 0) {\n            const node = prev.next!;\n            deleted.push(node.value);\n            prev.next = node.next;\n            --this.length;\n        }\n\n        // Add elements\n        prev = this._addAll(prev, elements ?? []);\n        this.tail = newTail ? prev : this.tail;\n\n        return deleted;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        if (this.length > 1) {\n            const [head, tail] = linkedMergeSort(this.root.next!, this.length, false, compareFn);\n            this.root.next = head;\n            this.tail = tail;\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let node = this.root.next!; node !== this.root; node = node.next!) {\n            yield node.value;\n        }\n    }\n\n    unshift(value: T): number {\n        return this.add(0, value);\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = clamp(wrapLeft((min as number) ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft((max as number) ?? this.length, 0, this.length), 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.length;\n        } else if (max >= 0) {\n            len = () => max;\n        } else {\n            len = () => this.length + max;\n        }\n\n        if (min < len()) {\n            let node = this._get(min);\n            do {\n                yield node.value;\n                node = node.next!;\n            } while (++min < len() && node !== this.root);\n        }\n    }\n\n    protected _addAll(prev: LinkedNode<T>, elements: Iterable<T>): LinkedNode<T> {\n        const next = prev.next!;\n        for (const value of elements) {\n            const node = { value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        return prev;\n    }\n    /**\n     * Copy values from 'from' to 'to'.\n     *\n     * @param from - The initial node to copy from\n     * @param prev - The root of the initial node to copy to\n     * @param count - The number of values to copy\n     */\n    protected _copyWithin(from: LinkedNode<T>, to: LinkedNode<T>, count: number): LinkedNode<T> {\n        while (count-- > 0) {\n            from = from.next!;\n            to = to.next!;\n            to.value = from.value;\n        }\n        return to;\n    }\n    /**\n     * Get the node at the given index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number, root: LinkedNode<T> = this.root): LinkedNode<T> {\n        let node = root!;\n        while (index-- >= 0) {\n            node = node.next!;\n        }\n        return node;\n    }\n}\n","/**\n * Bit hacks for 32-bit unsigned numbers.\n */\n\n/**\n * Get the number of bits set of a 32-bit unsigned number ([source](https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan))\n *\n * @param a\n */\nexport function bitsSet(a: number): number {\n    let b = 0;\n    while (a) {\n        ++b;\n        a &= a - 1;\n    }\n    return b;\n}\n/**\n * Invert the bits of a 32-bit unsigned number.\n *\n * Example: 11 (1011) -> 4 (0100)\n *\n * @param a The number to invert\n *\n * @returns The inverted number\n */\nexport function invert(a: number): number {\n    const b = msp(a);\n    return u32(a ^ (b | (b - 1)));\n}\n/**\n * Check whether a 32-bit unsigned number is a power of 2.\n *\n * Example: 8 (1000) -> true\n *\n * @param a The number to check\n */\nexport function isPow2(a: number): boolean {\n    return (a & (a - 1)) === 0;\n}\n/**\n * Get the Least Significant Bit of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns The lowest bit set\n */\nexport function lsb(a: number): number {\n    let b = -1;\n    for (a = lsp(a); a; a >>>= 1) {\n        ++b;\n    }\n    return b;\n}\n/**\n * Get the Least Significant Power of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns 2**lsb(a)\n */\nexport function lsp(a: number): number {\n    return u32(a & -a);\n}\n/**\n * Get the Least Significant Power Set of a 32-bit unsigned number.\n *\n * Example: 54 (110110) -> 6 (000110)\n *\n * @param a\n */\nexport function lsps(a: number): number {\n    return u32(a & (lsp(a + lsp(a)) - 1));\n}\n/**\n * Get the Most Significant Power of the Least Significant Power Set of a 32-bit unsigned number.\n *\n * Example: 54 (110110) -> 4 (000100)\n *\n * @param a\n */ /*\nexport function mlsp(a: number): number {\n    return (lsp(a + lsp(a)) >>> 1) || u32(0x80000000 & a);\n}\n*/\n/**\n * Get the Most Significant Bit of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns log2(a) : the highest bit set\n */\nexport function msb(a: number): number {\n    let b = -1;\n    while (a !== 0) {\n        ++b;\n        a >>>= 1;\n    }\n    return b;\n}\n/**\n * Get the Most Significant Power of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns 2**msb(a)\n */\nexport function msp(a: number): number {\n    let b = a & -a;\n    while (a != b) {\n        a ^= b;\n        b = a & -a;\n    }\n    return u32(b);\n}\n/**\n * Get the Most Significant Power Set of a 32-bit unsigned number.\n *\n * Example: 50 (110010) -> 48 (110000)\n *\n * @param a\n */\nexport function msps(a: number): number {\n    let b = a & -a;\n    while (a & (a + b)) {\n        a ^= b;\n        b = a & -a;\n    }\n    return u32(a);\n}\n/**\n * Reverse a 32-bit unsigned number.\n *\n * Example: 50 (110010) -> 19 (010011)\n *\n * @param a\n */\nexport function reverse(a: number): number {\n    a = ((a & 0xaaaaaaaa) >>> 1) | ((a & 0x55555555) << 1);\n    a = ((a & 0xcccccccc) >>> 2) | ((a & 0x33333333) << 2);\n    a = ((a & 0xf0f0f0f0) >>> 4) | ((a & 0x0f0f0f0f) << 4);\n    a = ((a & 0xff00ff00) >>> 8) | ((a & 0x00ff00ff) << 8);\n    return u32((a >>> 16) | (a << 16));\n}\n/**\n * Turn a number into an unsigned 32-bit number\n *\n * @param a\n */\nexport function u32(a: number): number {\n    return a >>> 0;\n}\n","import { Queue } from './queue';\n\n/**\n * An implementation of the {@link Queue} interface using an array\n */\nexport class ArrayQueue<T> implements Queue<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * Instantiate the queue.\n     *\n     * @param elements - A set of elements to initialize the queue with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    dequeue(): T | undefined {\n        return this.size < 1 ? undefined : this.array.shift();\n    }\n\n    enqueue(element: T): number {\n        return this.array.push(element);\n    }\n\n    peek(): T | undefined {\n        return this.size < 1 ? undefined : this.array[0];\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Queue } from './queue';\n\n/**\n * A linked list implementation of the {@link Queue} interface\n */\nexport class LinkedQueue<T> implements Queue<T> {\n    /**\n     * The list containing every element.\n     */\n    protected list: List<T>;\n    /**\n     * Instantiate the queue.\n     *\n     * @param elements - A set of elements to initialize the queue with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList(elements);\n    }\n\n    clear(): void {\n        this.list.clear();\n    }\n\n    dequeue(): T | undefined {\n        return this.list.shift();\n    }\n\n    enqueue(element: T): number {\n        return this.list.push(element);\n    }\n\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","import { lsb, lsp, msb, msp } from '../math/u32';\nimport { CombineFn } from '..';\nimport { MAX_ARRAY_LENGTH } from 'src/collection/arrayUtils';\nimport { SegmentTree } from './segmentTree';\n\n/*\n    mca(a, b) = lsp(a | msp(b - a)) ; // where a <= b\n    left(i) = i - (lsp(i + 1) >>> 1)\n    right(i) = i + (lsp(i + 1) >>> 1)\n    parent(i) =\n        offset = lsp(i + 1)\n        i + offset - ((i & 2*offset) >>> 0)\n*/\n\n/**\n * A {@link SegmentTree} with entries stored in in-order traversal.\n * Inspired by [Tristan Hume's IForestIndex](https://thume.ca/2021/03/14/iforests) ([github](https://github.com/trishume/gigatrace))\n */\nexport class InOrderSegmentTree<T> implements SegmentTree<T> {\n    /**\n     * The maximum amount of elements that can be added.\n     *\n     * n elements require 2n memory.\n     */\n    static readonly MAX_SIZE: number = MAX_ARRAY_LENGTH >>> 1;\n    /**\n     * The set of elements and aggregation nodes for the tree\n     */\n    protected array: T[];\n    /**\n     * The function used to aggregate elements\n     */\n    protected combine: CombineFn<T>;\n    /**\n     * Construct a new segment tree\n     *\n     * @param combine - The function used to aggregate segment information\n     * @param elements - A set of elements to add into the initial tree\n     */\n    constructor(combine: CombineFn<T>, elements: Iterable<T> = []) {\n        this.array = [];\n        this.combine = combine;\n        this.build(elements);\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    pop(): T | undefined {\n        // Sanitize range\n        if (this.size < 1) {\n            return undefined;\n        }\n\n        // Un-complete aggregation nodes\n        const i = this.array.length - 1;\n        for (let mask = 2; i & mask; mask *= 2) {\n            this.array[i - mask] = this.array[i - mask - (mask >>> 1)];\n        }\n\n        // Return element\n        const out = this.array[i - 1];\n        this.array.length -= 2;\n        return out;\n    }\n\n    push(element: T): number {\n        // Sanitize range\n        if (this.size >= InOrderSegmentTree.MAX_SIZE) {\n            throw new RangeError(`Invalid length`);\n        }\n\n        // Add element\n        const i = this.array.length;\n        this.array[i + 1] = this.set(i, element);\n\n        return this.size;\n    }\n\n    query(min: number, max: number): T {\n        // Sanitize range\n        if (min >= max) {\n            throw new RangeError(`Range [${min}..${max}) is empty`);\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min *= 2;\n        max *= 2;\n\n        // Jump to min's highest aggregation node that is fully within the range\n        let offset = lsp(min | msp(max - min));\n        let value = this.array[min - 1 + (offset >>> 1)];\n\n        // Continue jumping aggregation nodes until max is reached\n        for (min += offset; min < max; min += offset) {\n            offset = lsp(min | msp(max - min));\n            value = this.combine(value, this.array[min - 1 + (offset >>> 1)]);\n        }\n\n        return value;\n    }\n\n    get size(): number {\n        return this.array.length >>> 1;\n    }\n\n    /**\n     * Return an iterator through the tree's elements\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let i = 0; i < this.array.length; i += 2) {\n            yield this.array[i];\n        }\n    }\n\n    update(min: number, max: number, operation: (element: T, index: number) => T): void {\n        // Sanitize range\n        if (min >= max) {\n            return;\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min *= 2;\n        max *= 2;\n\n        // Update the values\n        let value: T;\n        do {\n            value = this.set(min, operation(this.array[min], min >>> 1));\n            min += 2;\n        } while (min < max);\n\n        // Update remaining aggregation nodes\n        let dc = 0;\n        let dp = lsp(min);\n        max = msb(min ^ this.array.length) - lsb(min);\n        for (--min; max > 0; --max) {\n            value = this.combine(value, this.array[min + (dp >>> 1) - dc]);\n            this.array[min] = value;\n            dc = (min & (2 * dp)) >>> 0;\n            min += dp - dc;\n            dp *= 2;\n        }\n\n        // Update the incomplete aggregation node\n        this.array[min] = value;\n    }\n    /**\n     * A helper method used to build the tree\n     *\n     * @param elements The initial set of elements to add into the tree\n     */\n    protected build(elements: Iterable<T>) {\n        for (const element of elements) {\n            this.push(element);\n        }\n    }\n    /**\n     * A helper method to update complete aggregation nodes for an index\n     */\n    protected set(index: number, element: T): T {\n        // Set the index\n        this.array[index++] = element;\n\n        // Update complete aggregation nodes, from lowest to highest\n        for (let mask = 2; index & mask; mask *= 2) {\n            element = this.combine(this.array[index - mask - (mask >>> 1)], element);\n            this.array[index - mask] = element;\n        }\n\n        return element;\n    }\n}\n","/**\n *  Thanks to [Douglas Wilhelm Harder](https://ece.uwaterloo.ca/~dwharder/aads/Algorithms/Array_resizing/)\n *  for their analysis on array resizing\n */\nimport { isArray, MAX_ARRAY_LENGTH } from 'src/collection/arrayUtils';\nimport { isCollection } from 'src/collection';\nimport { Collection } from 'src/collection/collection';\nimport { CombineFn } from '..';\nimport { isPow2, lsp, msp } from '../math/u32';\nimport { SegmentTree } from './segmentTree';\n\n/**\n * A {@link SegmentTree} with entries stored in level-order traversal.\n * Memory usage: n elements require between 2n-1 to 4(n-1)-1 entries\n *\n */\nexport class LevelOrderSegmentTree<T> implements SegmentTree<T> {\n    /**\n     * The maximum number of elements that can be added.\n     *\n     * n elements require 2^log2(2n) - 1 memory:\n     */\n    static readonly MAX_SIZE: number = (MAX_ARRAY_LENGTH + 1) / 2;\n    /**\n     * The internal array used to store elements and aggregation nodes\n     */\n    protected array: Array<T>;\n    /**\n     * The function used to aggregate elements\n     */\n    protected combine: CombineFn<T>;\n    /**\n     * The used length (size) of our internal array\n     */\n    protected length: number;\n    /**\n     * The start index for the lowest level\n     */\n    protected level: number;\n    /**\n     * Construct a new {@link SegmentTree}\n     *\n     * @param combinFn - The function used to aggregate elements\n     * @param elements - Initial elements to build into the tree\n     */\n    constructor(combine: CombineFn<T>, elements: Iterable<T> = []) {\n        this.array = [];\n        this.combine = combine;\n        this.length = 0;\n        this.level = 0;\n        this.build(elements);\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.level = 0;\n        this.array.length = 0;\n    }\n\n    pop(): T | undefined {\n        // Sanitize range\n        if (this.length <= this.level) {\n            return undefined;\n        }\n\n        // Remove element\n        const out = this.array[--this.length];\n\n        // If level is <= 1/4 full\n        if (this.length <= (this.array.length + 1) >>> 2) {\n            this.shrink();\n        }\n\n        return out;\n    }\n\n    push(element: T): number {\n        // If array is full\n        if (this.length >= this.array.length) {\n            this.grow();\n        }\n\n        // Add the new element\n        this.array[this.length++] = element;\n\n        // Update aggregation nodes\n        for (let i = this.length; i & 1; this.array[i - 1] = element) {\n            element = this.combine(this.array[i - 2], element);\n            i >>>= 1;\n        }\n\n        return this.size;\n    }\n\n    query(min: number, max: number): T {\n        // Sanitize range\n        if (min >= max) {\n            throw new RangeError(`Range [${min}..${max}) is empty`);\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices and align with powers of 2\n        min += this.level + 1;\n        max += this.level + 1;\n\n        // Take the longest possible jump from min\n        let offset = lsp(min | msp(max - min));\n        let value: T = this.array[min / offset - 1];\n        min += offset;\n\n        // Continue jumping until max\n        while (min < max) {\n            offset = lsp(min | msp(max - min));\n            value = this.combine(value, this.array[min / offset - 1]);\n            min += offset;\n        }\n\n        return value;\n    }\n\n    get size(): number {\n        return this.length - this.level;\n    }\n\n    /**\n     * Return an iterator through the elements\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let i = 0; i < this.size; ++i) {\n            yield this.array[this.level + i];\n        }\n    }\n\n    update(min: number, max: number, operation: (element: T, index: number) => T): void {\n        // Sanitize range\n        if (min >= max) {\n            return;\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min += this.level;\n        max += this.level;\n\n        // Update the range\n        for (let i = min; i < max; ++i) {\n            this.array[i] = operation(this.array[i], i - this.level);\n        }\n\n        // Update the range's aggregation nodes\n        this.aggregate(min, max);\n    }\n    /**\n     * A helper method to aggregate a range of elements\n     */\n    protected aggregate(min: number, max: number): void {\n        // Align indices with powers of 2\n        ++min;\n        ++max;\n\n        // Aggregate elements\n        for (let cap = this.length + 1; min < max; cap >>>= 1) {\n            max += max & ((max - cap) >>> 31);\n            for (let i = (min | 1) >>> 0; i < max; i += 2) {\n                this.array[(i >>> 1) - 1] = this.combine(this.array[i - 2], this.array[i - 1]);\n            }\n            min >>>= 1;\n            max >>>= 1;\n        }\n    }\n    /**\n     * A helper method used to build the tree\n     *\n     * @param elements The initial set of elements to add into the tree\n     */\n    protected build(elements: Collection<T> | Iterable<T>): void {\n        let key: string | undefined = undefined;\n\n        // Check if the iterable's size can be known.\n        if (isArray(elements)) {\n            key = 'length';\n        } else if (isCollection(elements)) {\n            key = 'size';\n        } else {\n            for (const element of elements) {\n                this.push(element);\n            }\n            return;\n        }\n\n        // Get the iterable's size\n        const n: number = (elements as any)[key];\n\n        // Check for base case\n        if (n < 1) {\n            this.array.length = 0;\n            this.length = 0;\n            this.level = 0;\n            return;\n        }\n\n        // Check if max capacity reached\n        if (n >= LevelOrderSegmentTree.MAX_SIZE) {\n            throw new RangeError('Invalid length');\n        }\n\n        // Allocate the array\n        this.level = 2 * msp(n - 1) - 1;\n        this.length = this.level;\n        this.array.length = 2 * this.level + 1;\n\n        // Add the elements\n        for (const element of elements) {\n            this.array[this.length++] = element;\n        }\n\n        // Update aggregation nodes\n        this.aggregate(this.level, this.length);\n    }\n    /**\n     * Shift the tree down a level\n     */\n    protected grow(): void {\n        // Check base case\n        if (this.size < 1) {\n            this.array.length = 1;\n            return;\n        }\n\n        // Check if max capacity reached\n        if (this.size >= LevelOrderSegmentTree.MAX_SIZE) {\n            throw new RangeError('Invalid length');\n        }\n\n        // Extend capacity\n        this.array.length += this.array.length + 1;\n\n        // Shift the tree down a level\n        let min = this.level + 1;\n        for (let max = this.length + 1; min < max; max >>>= 1) {\n            this.array.copyWithin(2 * min - 1, min - 1, max - 1);\n            min >>>= 1;\n        }\n\n        // Update pointers\n        this.length += this.level + 1;\n        this.level += this.level + 1;\n    }\n    /**\n     * Shrink the tree to the smallest size\n     */\n    protected shrink(): void {\n        const length = this.length - this.level;\n\n        // Check base case\n        if (length < 2) {\n            this.array.copyWithin(0, this.level, this.length);\n            this.level = 0;\n            this.length = length;\n            this.array.length = length;\n            return;\n        }\n\n        // Get the highest node\n        let min = this.level + 1;\n        let mask = msp(length);\n        min = min / lsp(min | mask) - 1;\n\n        // Update the tree\n        this.level = +!isPow2(length);\n        for (let max = min + 1; mask; this.level += this.level + 1) {\n            this.array.copyWithin(this.level, min, max);\n            mask >>>= 1;\n            min += min + 1;\n            max += max + 2 + +((length & mask) > 0);\n        }\n\n        // Update pointers\n        this.length = this.level + length;\n        this.array.length = 2 * this.level + 1;\n    }\n}\n","import { Stack } from './stack';\n\n/**\n * An implementation of the {@link Stack} interface using an array\n */\nexport class ArrayStack<T> implements Stack<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * Instantiate the stack.\n     *\n     * @param elements - A set of elements to initialize the stack with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    peek(): T | undefined {\n        return this.array[this.array.length - 1];\n    }\n\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n\n    push(element: T): number {\n        return this.array.push(element);\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        const array = this.array;\n        for (let i = array.length; i > 0; yield array[--i]) {}\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Stack } from './stack';\n\n/**\n * A linked list implementation of the {@link Stack} interface\n */\nexport class LinkedStack<T> implements Stack<T> {\n    /**\n     * The list containing every element.\n     */\n    protected list: List<T>;\n    /**\n     * Instantiate the stack.\n     *\n     * @param elements - A set of elements to initialize the stack with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList();\n        for (const element of elements || []) {\n            this.push(element);\n        }\n    }\n\n    clear(): void {\n        this.list.clear();\n    }\n\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n\n    pop(): T | undefined {\n        return this.list.shift();\n    }\n\n    push(element: T): number {\n        return this.list.unshift(element);\n    }\n\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","import { CompareFn } from '..';\nimport { AATreeNode } from './aaTreeNode';\nimport {\n    clone,\n    search,\n    Edge,\n    inOrderTraverse,\n    leftmost,\n    leftmostStack,\n    preOrderTraverse,\n    removeStack,\n    rightmost,\n    rightmostStack,\n    searchStack,\n    debug,\n} from './binaryTreeUtils';\nimport { SortedTree } from './sortedTree';\nimport { isArray } from 'src/collection/arrayUtils';\nimport { LinkedNode } from 'src/list';\n\n/**\n * An AA tree is a form of balanced tree used for storing and retrieving ordered data efficiently\n * ([source](https://en.wikipedia.org/wiki/AA_tree)).\n *\n * AA trees are named for Arne Andersson, their inventor. They are a variation of the redblack tree,\n * which supports efficient addition and deletion of entries. Unlike redblack trees, additional\n * constraints on the balancing mechanism greatly simplifies the implementation as well as\n * maintenance operations; While a redblack tree needs to consider seven different shapes\n * to properly balance the tree, an AA tree only needs to consider two shapes.\n *\n * The performance of an AA tree is equivalent to the performance of a redblack tree.\n * While an AA tree makes more rotations than a red-black tree, the simpler algorithms\n * tend to be faster, which balances out to similar performance. A red-black tree is\n * more consistent in its performance, but an AA tree tends to be flatter, which results\n * in slightly faster search times.\n */\nexport class AATree<T> implements SortedTree<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * Indicates how to handle duplicates:\n     * - < 0 : Add to left subtree\n     * - = 0 : Do now allow duplicates\n     * - > 0 : Add to right subtree\n     */\n    protected dupeWeight: number;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The node at the \"top\" of the heap.\n     */\n    protected root: AATreeNode<T> | undefined;\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>);\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param allowDuplicates - Whether to allow duplicates\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, allowDuplicates: boolean, elements?: Iterable<T>);\n    constructor(\n        compareFn: CompareFn<T>,\n        allowDuplicates?: boolean | Iterable<T>,\n        elements?: Iterable<T>,\n    ) {\n        if (typeof allowDuplicates !== 'boolean') {\n            elements = allowDuplicates;\n            allowDuplicates = true;\n        }\n        this.compare = compareFn;\n        this.dupeWeight = +allowDuplicates;\n        this.length = 0;\n        this.build(elements ?? []);\n    }\n\n    add(element: T): this {\n        // Find the element\n        const sentinel = { left: this.root } as AATreeNode<T>;\n        let edge: Edge<AATreeNode<T>> = { from: sentinel, label: 'left', to: this.root };\n        let stack = searchStack(element, { value: edge }, this.compare, this.dupeWeight);\n\n        // If element already exists\n        if (stack.value.to != null) {\n            return this;\n        }\n\n        // Add element\n        edge = stack.value;\n        let label = edge.label;\n        edge.from![label!] = { level: 1, value: element };\n\n        // Balance the tree\n        while (stack.next) {\n            stack = stack.next;\n            edge = stack.value;\n            edge.to = split(skew(edge.to));\n            edge.from![(label = edge.label!)] = edge.to;\n        }\n\n        // Update state\n        ++this.length;\n        this.root = sentinel.left;\n        return this;\n    }\n\n    clear(): void {\n        this.root = undefined;\n        this.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    delete(element: T): boolean {\n        // Remove the element if found\n        const sentinel = { left: this.root } as AATreeNode<T>;\n        const edge: Edge<AATreeNode<T>> = { from: sentinel, label: 'left', to: this.root };\n        const stack = searchStack(element, { value: edge }, this.compare, 0);\n        const removed = remove(stack);\n\n        // Update state\n        this.root = sentinel.left;\n        this.length -= +removed;\n        return removed;\n    }\n\n    has(element: T): boolean {\n        return search(element, this.root, this.compare) != null;\n    }\n\n    max(): T | undefined {\n        return rightmost(this.root)?.value;\n    }\n\n    min(): T | undefined {\n        return leftmost(this.root)?.value;\n    }\n\n    pop(): T | undefined {\n        // Find the maximum value\n        const sentinel = { left: this.root } as AATreeNode<T>;\n        const edge: Edge<AATreeNode<T>> = { from: sentinel, label: 'left', to: this.root };\n        const stack = rightmostStack({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.root = sentinel.left;\n        this.length -= +removed;\n        return value;\n    }\n\n    shift(): T | undefined {\n        // Find the minimum value\n        const sentinel = { left: this.root } as AATreeNode<T>;\n        const edge: Edge<AATreeNode<T>> = { from: sentinel, label: 'left', to: this.root };\n        const stack = leftmostStack({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.root = sentinel.left;\n        this.length -= +removed;\n        return value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        for (const node of inOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.delete(curElement)) {\n            this.add(newElement);\n            return true;\n        }\n        return false;\n    }\n\n    protected build(obj: Iterable<T>): void {\n        if (isArray(obj)) {\n            for (let i = 0; i < obj.length; ++i) {\n                this.add(obj[i]);\n            }\n        } else if (obj instanceof AATree && this.compare === obj.compare) {\n            this.root = clone(obj.root);\n            this.length = obj.size;\n        } else {\n            for (const element of obj) {\n                this.add(element);\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nexport function remove<T>(stack: LinkedNode<Edge<AATreeNode<T>>>): boolean {\n    let edge = stack.value;\n    let node = edge.to;\n\n    // If not found\n    if (node == null) {\n        return false;\n    }\n\n    // Remove the node\n    stack = removeStack(stack);\n\n    // Update the tree\n    while (stack.next) {\n        stack = stack.next;\n        edge = stack.value;\n        node = edge.to!;\n\n        // Decrease levels\n        const level = 1 + Math.min(node.left?.level ?? 0, node.right?.level ?? 0);\n        if (level < node.level) {\n            node.level = level;\n            if (node.right != null && level < node.right.level) {\n                node.right.level = level;\n            }\n        }\n\n        // Balance\n        node = skew(node);\n        node.right = skew(node.right);\n        if (node.right != null) {\n            node.right.right = skew(node.right.right);\n        }\n        node = split(node);\n        node.right = split(node.right);\n\n        // Make the update\n        edge.from![edge.label!] = edge.to = node;\n    }\n\n    return true;\n}\n/**\n * @internal\n */\nexport function skew<T>(node?: undefined): undefined;\nexport function skew<T>(node: AATreeNode<T>): AATreeNode<T>;\nexport function skew<T>(node?: AATreeNode<T>): AATreeNode<T> | undefined;\nexport function skew<T>(node?: AATreeNode<T>): AATreeNode<T> | undefined {\n    if (node == null || node.left == null || node.level != node.left.level) {\n        return node;\n    }\n    const left = node.left;\n    node.left = left.right;\n    left.right = node;\n    return left;\n}\n/**\n * @internal\n */\nexport function split<T>(node?: undefined): undefined;\nexport function split<T>(node: AATreeNode<T>): AATreeNode<T>;\nexport function split<T>(node?: AATreeNode<T>): AATreeNode<T> | undefined;\nexport function split<T>(node?: AATreeNode<T>): AATreeNode<T> | undefined {\n    if (\n        node == null ||\n        node.right == null ||\n        node.right.right == null ||\n        node.level != node.right.right.level\n    ) {\n        return node;\n    }\n    const right = node.right;\n    node.right = right.left;\n    right.left = node;\n    ++right.level;\n    return right;\n}\n","import { CompareFn } from 'src';\nimport { AVLTreeNode } from './avlTreeNode';\nimport {\n    clone,\n    search,\n    Edge,\n    inOrderTraverse,\n    leftmost,\n    leftmostStack,\n    preOrderTraverse,\n    rightmost,\n    rightmostStack,\n    searchStack,\n    removeStack,\n} from './binaryTreeUtils';\nimport { SortedTree } from './sortedTree';\nimport { isArray } from 'src/collection/arrayUtils';\nimport { LinkedNode } from 'src/list';\n\n/**\n * An AVL tree is a self-balancing binary search tree ([source](https://en.wikipedia.org/wiki/AVL_tree)).\n *\n * It is named after inventors Georgy Adelson-Velsky and Evgenii Landis and was the first such\n * data structure to be invented. In an AVL tree, the heights of the two child\n * subtrees of any node differ by at most one; if at any time they differ by more\n * than one, rebalancing is done to restore this property.\n *\n * Lookup, insertion, and deletion all take O(log(n)) time in both the average and worst cases,\n * where n is the number of nodes in the tree prior to the operation. Insertions and deletions\n * may require the tree to be rebalanced by one or more tree rotations.\n *\n * AVL trees are often compared with redblack trees as both take O(log(n))\n * time for the basic operations. For lookup-intensive applications, AVL trees are\n * faster than redblack trees because they are more strictly balanced.\n * Similar to redblack trees, AVL trees are height-balanced.\n */\nexport class AVLTree<T> implements SortedTree<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * Indicates how to handle duplicates:\n     * - < 0 : Add to left subtree\n     * - = 0 : Do now allow duplicates\n     * - > 0 : Add to right subtree\n     */\n    protected dupeWeight: number;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The root of the tree.\n     */\n    protected root: AVLTreeNode<T>;\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>);\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param allowDuplicates - Whether to allow duplicates\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, allowDuplicates: boolean, elements?: Iterable<T>);\n    constructor(\n        compareFn: CompareFn<T>,\n        allowDuplicates?: boolean | Iterable<T>,\n        elements?: Iterable<T>,\n    ) {\n        if (typeof allowDuplicates !== 'boolean') {\n            elements = allowDuplicates;\n            allowDuplicates = true;\n        }\n        this.compare = compareFn;\n        this.dupeWeight = +allowDuplicates;\n        this.length = 0;\n        this.root = {} as AVLTreeNode<T>;\n        this.build(elements ?? []);\n    }\n\n    add(element: T): this {\n        // Find the element\n        let edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        let stack = searchStack(element, { value: edge }, this.compare, this.dupeWeight);\n\n        // If element already exists\n        if (stack.value.to != null) {\n            return this;\n        }\n\n        // Add element\n        edge = stack.value;\n        let label = edge.label;\n        edge.from![label!] = { balanceFactor: 0, value: element };\n\n        // Balance the tree\n        while (stack.next) {\n            stack = stack.next;\n            edge = stack.value;\n            edge.to!.balanceFactor += label === 'left' ? -1 : 1;\n            edge.to = balance(edge.to!);\n            edge.from![(label = edge.label!)] = edge.to;\n            if (edge.to!.balanceFactor === 0) {\n                break;\n            }\n        }\n\n        // Update state\n        ++this.length;\n        return this;\n    }\n\n    clear(): void {\n        this.root.left = undefined;\n        this.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    delete(element: T): boolean {\n        // Remove the element if found\n        const edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        const stack = searchStack(element, { value: edge }, this.compare, 0);\n        const removed = remove(stack);\n\n        // Update state\n        this.length -= +removed;\n        return removed;\n    }\n\n    has(element: T): boolean {\n        return search(element, this.root.left, this.compare) != null;\n    }\n\n    max(): T | undefined {\n        return rightmost(this.root.left)?.value;\n    }\n\n    min(): T | undefined {\n        return leftmost(this.root.left)?.value;\n    }\n\n    pop(): T | undefined {\n        // Find the maximum value\n        const edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        const stack = rightmostStack({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.length -= +removed;\n        return value;\n    }\n\n    shift(): T | undefined {\n        // Find the minimum value\n        const edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        const stack = leftmostStack({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.length -= +removed;\n        return value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        for (const node of inOrderTraverse(this.root.left)) {\n            yield node.value;\n        }\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root.left)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.delete(curElement)) {\n            this.add(newElement);\n            return true;\n        }\n        return false;\n    }\n\n    protected build(obj: Iterable<T>): void {\n        if (isArray(obj)) {\n            for (let i = 0; i < obj.length; ++i) {\n                this.add(obj[i]);\n            }\n        } else if (obj instanceof AVLTree && this.compare === obj.compare) {\n            this.root = clone(obj.root);\n            this.length = obj.size;\n        } else {\n            for (const element of obj) {\n                this.add(element);\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nexport function balance<T>(node: AVLTreeNode<T>): AVLTreeNode<T> {\n    if (node.balanceFactor > 1) {\n        if (node.right!.balanceFactor < 0) {\n            node.right = rotateR(node.right!);\n        }\n        node = rotateL(node);\n    } else if (node.balanceFactor < -1) {\n        if (node.left!.balanceFactor > 0) {\n            node.left = rotateL(node.left!);\n        }\n        node = rotateR(node);\n    }\n    return node;\n}\n/**\n * @internal\n */\nexport function remove<T>(stack: LinkedNode<Edge<AVLTreeNode<T>>>): boolean {\n    let edge = stack.value;\n    const node = edge.to;\n\n    // If not found\n    if (node == null) {\n        return false;\n    }\n\n    // Remove the node\n    stack = removeStack(stack);\n\n    // Balance the tree\n    let label = stack.value.label;\n    while (stack.next) {\n        stack = stack.next;\n        edge = stack.value;\n        edge.to!.balanceFactor -= label === 'left' ? -1 : 1;\n        edge.to = balance(edge.to!);\n        edge.from![(label = edge.label)!] = edge.to;\n        if (edge.to!.balanceFactor !== 0) {\n            break;\n        }\n    }\n\n    return true;\n}\n/**\n * @internal\n */\nexport function rotateL<T>(P: AVLTreeNode<T>): AVLTreeNode<T> {\n    const R = P.right!;\n    P.right = R.left;\n    R.left = P;\n    P.balanceFactor -= 1 + Math.max(0, R.balanceFactor);\n    R.balanceFactor -= 1 - Math.min(0, P.balanceFactor);\n    return R;\n}\n/**\n * @internal\n */\nexport function rotateR<T>(P: AVLTreeNode<T>): AVLTreeNode<T> {\n    const L = P.left!;\n    P.left = L.right;\n    L.right = P;\n    P.balanceFactor += 1 - Math.min(0, L.balanceFactor);\n    L.balanceFactor += 1 + Math.max(0, P.balanceFactor);\n    return L;\n}\n"],"sourceRoot":""}