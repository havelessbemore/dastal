{"version":3,"sources":["webpack://Dastal/webpack/universalModuleDefinition","webpack://Dastal/./src/list/arrayList.ts","webpack://Dastal/./src/list/doublyLinkedList.ts","webpack://Dastal/./src/list/linkedList.ts","webpack://Dastal/./src/queue/arrayQueue.ts","webpack://Dastal/./src/queue/linkedQueue.ts","webpack://Dastal/./src/stack/arrayStack.ts","webpack://Dastal/./src/stack/linkedStack.ts","webpack://Dastal/./src/utils.ts","webpack://Dastal/webpack/bootstrap","webpack://Dastal/webpack/runtime/compat get default export","webpack://Dastal/webpack/runtime/define property getters","webpack://Dastal/webpack/runtime/hasOwnProperty shorthand","webpack://Dastal/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","self","Symbol","iterator","ArrayList","elements","this","array","Array","from","index","element","size","splice","batch","items","length","out","lists","list","addAll","min","max","wrap","copyWithin","fill","undefined","callback","value","pop","push","temp","prev","shift","slice","start","count","clamp","unshift","arguments","len","Math","DoublyLinkedList","next","_addAll","_get","node","nodeA","nodeB","tail","head","view","LinkedList","_copyWithin","nodeC","nodeD","remove","deleted","newTail","add","to","ArrayQueue","LinkedQueue","clear","get","ArrayStack","i","LinkedStack","f","num","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","r","toStringTag"],"mappings":"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","file":"dastal.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Dastal\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Dastal\"] = factory();\n\telse\n\t\troot[\"Dastal\"] = factory();\n})(self, function() {\nreturn ","import { List } from './list';\nimport { batch, clamp, wrap } from '../utils';\n\n/**\n * An implementation of the {@link List} interface using an array\n */\nexport class ArrayList<T> implements List<T> {\n    /**\n     * @ignore\n     */\n    protected array: Array<T>;\n\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n    /**\n     * Add the element at the specified index.\n     *\n     * @param index - The index to add into\n     * @param element - The element to add\n     *\n     * @returns The new size of the list\n     */\n    add(index: number, element: T): number {\n        if (index >= 0 && index <= this.size) {\n            this.array.splice(index, 0, element);\n        }\n        return this.size;\n    }\n    /**\n     * Add elements at the specified index.\n     *\n     * @param index - The index to add into\n     * @param element - The elements to add\n     *\n     * @returns The new size of the list\n     */\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.size) {\n            for (const items of batch(10000, elements)) {\n                this.array.splice(index, 0, ...items);\n                index += items.length;\n            }\n        }\n        return this.size;\n    }\n    /**\n     * Removes all elements\n     */\n    clear(): void {\n        this.array.length = 0;\n    }\n    /**\n     * Combines the list with multiple iterables into a new list.\n     * Does not modify the existing list or inputs.\n     *\n     * @param lists — Additional iterables to add to the end of the list.\n     *\n     * @returns A new list consisting of the elements in the list on which\n     * it is called, followed in order by the elements of each argument. It\n     * does not recurse into nested iterable arguments\n     */\n    concat(...lists: Iterable<T>[]): ArrayList<T> {\n        const out = new ArrayList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n    /**\n     * Copies a section of the list identified by min and max to the same array at position index.\n     *\n     * Negative indices can be used for index, min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * Note that this method will not change the size of the list. If index is after min,\n     * the copied sequence will be trimmed to fit list.size\n     *\n     * @param index - Where to copy the sequence to\n     * @param min - Where to start copying elements from, inclusive. Defaults to 0\n     * @param max - Where to end copying elements from, exclusive. Defaults to list.size\n     *\n     * @returns The list\n     */\n    copyWithin(index: number, min?: number, max?: number): this {\n        index = wrap(index ?? 0, 0, this.size);\n        min = wrap(min ?? 0, 0, this.size);\n        max = wrap(max ?? this.size, 0, this.size);\n        this.array.copyWithin(index, min, max);\n        return this;\n    }\n    /**\n     * Returns the this object after filling the section identified by min and max with element.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param element — element to fill list section with\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param end - Where to stop filling the list, exclusive. Defaults to list.size\n     *\n     * @returns The list on which this method was called\n     */\n    fill(element: T, min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.size);\n        max = wrap(max ?? this.size, 0, this.size);\n        this.array.fill(element, min, max);\n        return this;\n    }\n    /**\n     * Return the element at the specified index.\n     *\n     * A negative index can be used for to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The element at the index, or `undefined` if index is invalid\n     */\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array[index];\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * A negative index can be used to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param index - The index to retrieve\n     * @param callback - A function that receives the previous element and returns\n     * the new element. The function is only called if the index is valid\n     *\n     * @returns The previous element at the index, or `undefined` if index is invalid\n     */\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        let value: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            value = this.array[index];\n            this.array[index] = callback(value);\n        }\n        return value;\n    }\n    /**\n     * Retrieves and removes the end of the list\n     *\n     * @returns The element at the end of the list, or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n    /**\n     * Inserts the specified element into the end of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns The new size of the list\n     */\n    push(element: T): number {\n        return this.array.push(element);\n    }\n    /**\n     * Retrieves and removes the element at the given index.\n     *\n     * A negative index can be used to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param index - The index to remove\n     *\n     * @returns The value at the index, or `undefined` if the index is invalid\n     */\n    remove(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array.splice(index, 1)[0];\n    }\n    /**\n     * Reverses the elements in the list in place.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns a reference to the same list\n     */\n    reverse(min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.size);\n        max = wrap(max ?? this.size, 0, this.size) - 1;\n        while (min < max) {\n            const temp = this.array[min];\n            this.array[min++] = this.array[max];\n            this.array[max--] = temp;\n        }\n        return this;\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * @param index - The index to retrieve\n     * @param element - The new element to insert at index\n     *\n     * @returns The previous element in the index, or undefined if the index is invalid\n     */\n    set(index: number, element: T): T | undefined {\n        let prev: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            prev = this.array[index];\n            this.array[index] = element;\n        }\n        return prev;\n    }\n    /**\n     * Retrieves and removes the first element in the list\n     *\n     * @returns The element at the front of the list or `undefined` if this list is empty.\n     */\n    shift(): T | undefined {\n        return this.array.shift();\n    }\n    /**\n     * The number of elements in this list\n     */\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Returns a copy of a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns A new list with a copy of the indicated section of the original list\n     */\n    slice(min?: number, max?: number): ArrayList<T> {\n        return new ArrayList(this.array.slice(min, max));\n    }\n    /**\n     * Removes elements from the list and optionally inserts new elements in their place.\n     * Returns any deleted elements.\n     *\n     * @param start - The index from which to start removing elements. Defaults to 0\n     *\n     * If > size, start will be set to size. In this case, no element will be\n     * deleted but the method can still add elements to the end of the list.\n     *\n     * If < 0, start will indicate an offset from the end of the list. For example,\n     * -2 refers to the second to last element of the list.\n     *\n     * If < -size, start will be set to 0\n     * @param count - The number of elements to remove. Defaults to size - start\n     *\n     * If >= size - start (that is, if it's >= than the number of elements from start\n     * until the end of the list), then all the elements from start until the end of\n     * the list will be removed.\n     *\n     * If <= 0, no elements are removed\n     * @param elements - The new elements to insert at start. Defaults to none\n     *\n     * @returns A new list of deleted elements\n     */\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = wrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n        const list = new ArrayList(this.array.splice(start, count));\n        for (const items of batch(10000, elements ?? [])) {\n            this.array.splice(start, 0, ...items);\n            start += items.length;\n        }\n        return list;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n    /**\n     * Inserts the specified element into the front of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns The new size of the list\n     */\n    unshift(element: T): number {\n        return this.array.unshift(element);\n    }\n    /**\n     * Update the elements of the list\n     *\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(callback: (element: T, index: number) => T): this;\n    /**\n     * Update the elements of the list\n     *\n     * Negative indices can be used to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    /**\n     * Update the elements of the list\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param max - Where to stop filling the list, exclusive. Defaults to list.size\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = wrap((min as number) ?? 0, 0, this.size);\n        max = wrap((max as number) ?? this.size, 0, this.size);\n        while (min < max) {\n            this.array[min] = callback(this.array[min], min);\n            ++min;\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns An iterator through the indicated section of the list\n     */\n    *view(min?: number, max?: number): Iterable<T> {\n        min = wrap(min ?? 0, 0, this.size);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.size;\n        } else if (max >= 0) {\n            len = () => Math.min(max, this.size);\n        } else {\n            len = () => this.size + max;\n        }\n\n        while (min < len()) {\n            yield this.array[min++];\n        }\n    }\n}\n","import { List } from './list';\nimport { clamp, wrap } from '../utils';\n\n/**\n * A doubly-linked node version of the {@link LinkedNode} interface.\n *\n * Each node links to its neighbors on the left (prev) and right (next) of it.\n */\nexport interface DoublyLinkedNode<T> {\n    /**\n     * A link to the node's next (right) neighbor\n     */\n    next?: DoublyLinkedNode<T>;\n    /**\n     * A link to the node's previous (left) neighbor\n     */\n    prev?: DoublyLinkedNode<T>;\n    /**\n     * The value of the node\n     */\n    value: T;\n}\n/**\n * A (circular) doubly-linked list implementation of the {@link List} interface.\n *\n * Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.\n */\nexport class DoublyLinkedList<T> implements List<T> {\n    /**\n     * @ignore\n     * The number of elements in this list\n     */\n    protected length: number;\n    /**\n     * @ignore\n     * The first node in the list\n     */\n    protected root: DoublyLinkedNode<T>;\n\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as DoublyLinkedNode<T>;\n        this.root.prev = this.root.next = this.root;\n        this._addAll(this.root, elements ?? []);\n    }\n    /**\n     * Add the element at the specified index.\n     *\n     * @param index - The index to add into (0 <= index <= size)\n     * @param element - The element to add\n     *\n     * @returns The new size of the list\n     */\n    add(index: number, value: T): number {\n        if (index < 0 || index > this.length) {\n            return this.length;\n        }\n        const prev = this._get(index - 1);\n        const node = { next: prev.next, prev, value };\n        prev.next = node;\n        node.next!.prev = node;\n        return ++this.length;\n    }\n    /**\n     * Add elements at the specified index.\n     *\n     * @param index - The index to add into (0 <= index <= size)\n     * @param element - The elements to add\n     *\n     * @returns The new size of the list\n     */\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.length) {\n            this._addAll(this._get(index), elements);\n        }\n        return this.length;\n    }\n    /**\n     * Removes all elements\n     */\n    clear(): void {\n        this.length = 0;\n        this.root.prev = this.root.next = this.root;\n    }\n    /**\n     * Combines the list with multiple iterables into a new list.\n     * Does not modify the existing list or inputs.\n     *\n     * @param lists — Additional iterables to add to the end of the list.\n     *\n     * @returns A new list consisting of the elements in the list on which\n     * it is called, followed in order by the elements of each argument. It\n     * does not recurse into nested iterable arguments\n     */\n    concat(...lists: Iterable<T>[]): DoublyLinkedList<T> {\n        const out = new DoublyLinkedList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n    /**\n     * Copies a section of the list identified by min and max to the same array at position index.\n     *\n     * Negative indices can be used for index, min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * Note that this method will not change the size of the list. If index is after min,\n     * the copied sequence will be trimmed to fit list.size\n     *\n     * @param index - Where to copy the sequence to\n     * @param min - Where to start copying elements from, inclusive. Defaults to 0\n     * @param max - Where to end copying elements from, exclusive. Defaults to list.size\n     *\n     * @returns The list\n     */\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to the same section\n        index = wrap(index, 0, this.length);\n        min = wrap(min ?? 0, 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = wrap(max ?? this.length, 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Check for overlap edge case\n        if (min < index && index < max) {\n            let nodeA = this._get(max);\n            let nodeB = this._get(index + (max - min));\n            do {\n                nodeA = nodeA.prev!;\n                nodeB = nodeB.prev!;\n                nodeB.value = nodeA.value;\n            } while (++min < max);\n            return this;\n        }\n\n        // Copy the section to the destination\n        let nodeA = this._get(min);\n        let nodeB = this._get(index);\n        do {\n            nodeB.value = nodeA.value;\n            nodeA = nodeA.next!;\n            nodeB = nodeB.next!;\n        } while (++min < max);\n        return this;\n    }\n    /**\n     * Returns the this object after filling the section identified by min and max with element.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param element — element to fill list section with\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param end - Where to stop filling the list, exclusive. Defaults to list.size\n     *\n     * @returns The list on which this method was called\n     */\n    fill(element: T, min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.length);\n        max = wrap(max ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n    /**\n     * Return the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     *\n     * @returns The element at the index, or `undefined` if index is invalid\n     */\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.length ? undefined : this._get(index).value;\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     * @param callback - A function that receives the previous element and returns\n     * the new element. The function is only called if the index is valid\n     *\n     * @returns The previous element at the index, or `undefined` if index is invalid\n     */\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n    /**\n     * Retrieves and removes the end of the list\n     *\n     * @returns The element at the end of the list, or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const tail = this.root.prev!;\n        tail.prev!.next = this.root;\n        this.root.prev = tail.prev;\n        --this.length;\n        return tail.value;\n    }\n    /**\n     * Inserts the specified element into the end of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns `true` upon success, otherwise `false`\n     */\n    push(value: T): number {\n        const prev = this.root.prev!;\n        const node = { next: this.root, prev, value };\n        prev.next = this.root.prev = node;\n        return ++this.length;\n    }\n    /**\n     * Retrieves and removes the element at the given index.\n     *\n     * @param index - The index to remove (0 <= index < size)\n     *\n     * @returns The value at the index, or `undefined` if the index is invalid\n     */\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        node.prev!.next = node.next;\n        node.next!.prev = node.prev;\n        --this.length;\n        return node.value;\n    }\n    /**\n     * Reverses the elements in the list in place.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns a reference to the same list\n     */\n    reverse(min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.length);\n        max = wrap(max ?? this.length, 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        const tail = root.next!;\n        let node = tail;\n        do {\n            const temp = node.next!;\n            node.next = node.prev;\n            node.prev = temp;\n            root.next = node;\n            node = temp;\n        } while (++min < max);\n        tail.next = node;\n        node.prev = tail;\n        root.next!.prev = root;\n        return this;\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     * @param element - The new element to insert at index\n     *\n     * @returns The previous element in the index, or undefined if the index is invalid\n     */\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n    /**\n     * Retrieves and removes the first element in the list\n     *\n     * @returns The element at the front of the list or `undefined` if this list is empty.\n     */\n    shift(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const head = this.root.next!;\n        head.next!.prev = this.root;\n        this.root.next = head.next;\n        --this.length;\n        return head.value;\n    }\n    /**\n     * The number of elements in this list\n     */\n    get size(): number {\n        return this.length;\n    }\n    /**\n     * Returns a copy of a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns A new list with a copy of the indicated section of the original list\n     */\n    slice(min?: number, max?: number): DoublyLinkedList<T> {\n        return new DoublyLinkedList(this.view(min, max));\n    }\n    /**\n     * Removes elements from the list and optionally inserts new elements in their place.\n     * Returns any deleted elements.\n     *\n     * @param start - The index from which to start removing elements. Defaults to 0\n     *\n     * If > size, start will be set to size. In this case, no element will be\n     * deleted but the method can still add elements to the end of the list.\n     *\n     * If < 0, start will indicate an offset from the end of the list. For example,\n     * -2 refers to the second to last element of the list.\n     *\n     * If < -size, start will be set to 0\n     * @param count - The number of elements to remove. Defaults to size - start\n     *\n     * If >= size - start (that is, if it's >= than the number of elements from start\n     * until the end of the list), then all the elements from start until the end of\n     * the list will be removed.\n     *\n     * If <= 0, no elements are removed\n     * @param elements - The new elements to insert at start. Defaults to none\n     *\n     * @returns A new list of deleted elements\n     */\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = wrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n\n        // If not modifying the list\n        const list = new DoublyLinkedList<T>();\n        if (elements == null && count < 1) {\n            return list;\n        }\n\n        // Delete elements\n        let node = this._get(start);\n        while (count-- > 0) {\n            list.push(node.value);\n            node.prev!.next = node.next!;\n            node.next!.prev = node.prev!;\n            node = node.next!;\n            --this.length;\n        }\n\n        // Add elements\n        this._addAll(node, elements ?? []);\n\n        return list;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let node = this.root.next!; node !== this.root; node = node.next!) {\n            yield node.value;\n        }\n    }\n    /**\n     * Inserts the specified element into the front of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns `true` upon success, otherwise `false`\n     */\n    unshift(value: T): number {\n        const head = this.root.next!;\n        const node = { next: head, prev: this.root, value };\n        this.root.next = head.prev = node;\n        return ++this.length;\n    }\n    /**\n     * Update the elements of the list\n     *\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(callback: (element: T, index: number) => T): this;\n    /**\n     * Update the elements of the list\n     *\n     * Negative indices can be used to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    /**\n     * Update the elements of the list\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param max - Where to stop filling the list, exclusive. Defaults to list.size\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = wrap((min as number) ?? 0, 0, this.length);\n        max = wrap((max as number) ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns An iterator through the indicated section of the list\n     */\n    *view(min?: number, max?: number): Iterable<T> {\n        min = wrap(min ?? 0, 0, this.length);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.length;\n        } else if (max >= 0) {\n            len = () => max;\n        } else {\n            len = () => this.length + max;\n        }\n\n        if (min < len()) {\n            let node = this._get(min);\n            do {\n                yield node.value;\n                node = node.next!;\n            } while (++min < len() && node !== this.root);\n        }\n    }\n    /**\n     * @ignore\n     *\n     */\n    protected _addAll(next: DoublyLinkedNode<T>, elements: Iterable<T>): void {\n        let prev = next.prev!;\n        for (const value of elements) {\n            const node = { prev, value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        next.prev = prev;\n    }\n    /**\n     * @ignore\n     * A helper method to iterate and return the node at the given index.\n     *\n     * Depending on the index, the list will be traversed from beginning or end; whichever is closest to the specified index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number): DoublyLinkedNode<T> {\n        let node = this.root;\n        if (index < this.length / 2) {\n            while (index-- >= 0) {\n                node = node.next!;\n            }\n        } else {\n            for (index = this.length - index; index > 0; --index) {\n                node = node.prev!;\n            }\n        }\n        return node;\n    }\n}\n","import { List } from './list';\nimport { clamp, wrap } from '../utils';\n\n/**\n * A linked node interface.\n *\n * Each node links to its next neighbor.\n */\nexport interface LinkedNode<T> {\n    /**\n     * A link to the node's neighbor\n     */\n    next?: LinkedNode<T>;\n    /**\n     * The value of the node\n     */\n    value: T;\n}\n/**\n * A (circular) linked list implementation of the {@link List} interface.\n */\nexport class LinkedList<T> implements List<T> {\n    /**\n     * @ignore\n     */\n    protected length: number;\n    /**\n     * @ignore\n     */\n    protected root: LinkedNode<T>;\n    /**\n     * @ignore\n     */\n    protected tail: LinkedNode<T>;\n\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as LinkedNode<T>;\n        this.root.next = this.root;\n        this.tail = this._addAll(this.root, elements ?? []);\n    }\n    /**\n     * Add the element at the specified index.\n     *\n     * @param index - The index to add into (0 <= index <= size)\n     * @param element - The element to add\n     *\n     * @returns The new size of the list\n     */\n    add(index: number, value: T): number {\n        if (index >= 0 && index < this.length) {\n            const prev = this._get(index - 1);\n            prev.next = { value, next: prev.next };\n            ++this.length;\n        } else if (index === this.length) {\n            this.push(value);\n        }\n        return this.length;\n    }\n    /**\n     * Add elements at the specified index.\n     *\n     * @param index - The index to add into (0 <= index <= size)\n     * @param element - The elements to add\n     *\n     * @returns The new size of the list\n     */\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index < this.length) {\n            this._addAll(this._get(index - 1), elements);\n        } else if (index === this.length) {\n            this.tail = this._addAll(this.tail, elements);\n        }\n        return this.length;\n    }\n    /**\n     * Removes all elements\n     */\n    clear(): void {\n        this.length = 0;\n        this.tail = this.root.next = this.root;\n    }\n    /**\n     * Combines the list with multiple iterables into a new list.\n     * Does not modify the existing list or inputs.\n     *\n     * @param lists — Additional iterables to add to the end of the list.\n     *\n     * @returns A new list consisting of the elements in the list on which\n     * it is called, followed in order by the elements of each argument. It\n     * does not recurse into nested iterable arguments\n     */\n    concat(...lists: Iterable<T>[]): LinkedList<T> {\n        const out = new LinkedList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n    /**\n     * Copies a section of the list identified by min and max to the same array at position index.\n     *\n     * Negative indices can be used for index, min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * Note that this method will not change the size of the list. If index is after min,\n     * the copied sequence will be trimmed to fit list.size\n     *\n     * @param index - Where to copy the sequence to\n     * @param min - Where to start copying elements from, inclusive. Defaults to 0\n     * @param max - Where to end copying elements from, exclusive. Defaults to list.size\n     *\n     * @returns The list\n     */\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to itself\n        index = wrap(index, 0, this.length);\n        min = wrap(min ?? 0, 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = wrap(max ?? this.length, 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Copy to earlier in the list\n        if (index < min) {\n            const node = this._get(index - 1);\n            this._copyWithin(this._get(min - index - 1, node), node, max - min);\n            return this;\n        }\n\n        // Copy to later in the list\n        if (index > max) {\n            const node = this._get(min - 1);\n            this._copyWithin(node, this._get(index - min - 1, node), max - min);\n            return this;\n        }\n\n        // Copy to overlapping destination\n        const nodeA = this._get(min - 1);\n        const nodeC = this._get(max - min - 1, nodeA);\n        const nodeD = this._copyWithin(nodeA, nodeC, index - min);\n        if (index + (max - min) >= this.length) {\n            this.tail = nodeC;\n        }\n        const temp = nodeA.next;\n        nodeA.next = nodeC.next;\n        nodeC.next = nodeD.next;\n        nodeD.next = temp;\n        return this;\n    }\n    /**\n     * Returns the this object after filling the section identified by min and max with element.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param element — element to fill list section with\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param end - Where to stop filling the list, exclusive. Defaults to list.size\n     *\n     * @returns The list on which this method was called\n     */\n    fill(element: T, min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.length);\n        max = wrap(max ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n    /**\n     * Return the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     *\n     * @returns The element at the index, or `undefined` if index is invalid\n     */\n    get(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        return index < this.length - 1 ? this._get(index).value : this.tail.value;\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     * @param callback - A function that receives the previous element and returns\n     * the new element. The function is only called if the index is valid\n     *\n     * @returns The previous element at the index, or `undefined` if index is invalid\n     */\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = index < this.length - 1 ? this._get(index) : this.tail;\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n    /**\n     * Retrieves and removes the end of the list\n     *\n     * @returns The value at the end of the list, or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const value = this.tail.value;\n        this.tail = this._get(this.length - 2);\n        this.tail.next = this.root;\n        --this.length;\n        return value;\n    }\n    /**\n     * Inserts the specified value into the end of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns `true` upon success, otherwise `false`\n     */\n    push(value: T): number {\n        const tail: LinkedNode<T> = { next: this.root, value };\n        this.tail.next = tail;\n        this.tail = tail;\n        return ++this.length;\n    }\n    /**\n     * Retrieves and removes the element at the given index.\n     *\n     * @param index - The index to remove (0 <= index < size)\n     *\n     * @returns The value at the index, or `undefined` if the index is invalid\n     */\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const prev = this._get(index - 1);\n        const node = prev.next!;\n        prev.next = node.next;\n        if (index === --this.length) {\n            this.tail = prev;\n        }\n        return node.value;\n    }\n    /**\n     * Reverses the elements in the list in place.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns a reference to the same list\n     */\n    reverse(min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.length);\n        max = wrap(max ?? this.length, 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        this.tail = max >= this.length ? root.next! : this.tail;\n        const tail = root.next!;\n        let prev = tail;\n        let node = tail.next!;\n        while (++min < max) {\n            const next = node.next!;\n            node.next = prev;\n            prev = node;\n            node = next;\n        }\n        root.next = prev;\n        tail.next = node;\n        return this;\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     * @param element - The new element to insert at index\n     *\n     * @returns The previous element in the index, or undefined if the index is invalid\n     */\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n    /**\n     * Retrieves and removes the first element in the list\n     *\n     * @returns The value at the front of the list or `undefined` if this list is empty.\n     */\n    shift(): T | undefined {\n        return this.remove(0);\n    }\n    /**\n     * The number of elements in this list\n     */\n    get size(): number {\n        return this.length;\n    }\n    /**\n     * Returns a copy of a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns A new list with a copy of the indicated section of the original list\n     */\n    slice(min?: number, max?: number): LinkedList<T> {\n        return new LinkedList(this.view(min, max));\n    }\n    /**\n     * Removes elements from the list and optionally inserts new elements in their place.\n     * Returns any deleted elements.\n     *\n     * @param start - The index from which to start removing elements. Defaults to 0\n     *\n     * If > size, start will be set to size. In this case, no element will be\n     * deleted but the method can still add elements to the end of the list.\n     *\n     * If < 0, start will indicate an offset from the end of the list. For example,\n     * -2 refers to the second to last element of the list.\n     *\n     * If < -size, start will be set to 0\n     * @param count - The number of elements to remove. Defaults to size - start\n     *\n     * If >= size - start (that is, if it's >= than the number of elements from start\n     * until the end of the list), then all the elements from start until the end of\n     * the list will be removed.\n     *\n     * If <= 0, no elements are removed\n     * @param elements - The new elements to insert at start. Defaults to none\n     *\n     * @returns A new list of deleted elements\n     */\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = wrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n\n        // If not modifying the list\n        const deleted = new LinkedList<T>();\n        if (elements == null && count < 1) {\n            return deleted;\n        }\n\n        // Delete elements\n        let prev = this._get(start - 1);\n        const newTail = start + count >= this.size;\n        while (count-- > 0) {\n            const node = prev.next!;\n            deleted.push(node.value);\n            prev.next = node.next;\n            --this.length;\n        }\n\n        // Add elements\n        prev = this._addAll(prev, elements ?? []);\n        this.tail = newTail ? prev : this.tail;\n\n        return deleted;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let node = this.root.next!; node !== this.root; node = node.next!) {\n            yield node.value;\n        }\n    }\n    /**\n     * Inserts the specified value into the front of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns `true` upon success, otherwise `false`\n     */\n    unshift(value: T): number {\n        return this.add(0, value);\n    }\n    /**\n     * Update the elements of the list\n     *\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(callback: (element: T, index: number) => T): this;\n    /**\n     * Update the elements of the list\n     *\n     * Negative indices can be used to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    /**\n     * Update the elements of the list\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param max - Where to stop filling the list, exclusive. Defaults to list.size\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = wrap((min as number) ?? 0, 0, this.length);\n        max = wrap((max as number) ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns An iterator through the indicated section of the list\n     */\n    *view(min?: number, max?: number): Iterable<T> {\n        min = wrap(min ?? 0, 0, this.length);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.length;\n        } else if (max >= 0) {\n            len = () => max;\n        } else {\n            len = () => this.length + max;\n        }\n\n        if (min < len()) {\n            let node = this._get(min);\n            do {\n                yield node.value;\n                node = node.next!;\n            } while (++min < len() && node !== this.root);\n        }\n    }\n    protected _addAll(prev: LinkedNode<T>, elements: Iterable<T>): LinkedNode<T> {\n        const next = prev.next!;\n        for (const value of elements) {\n            const node = { value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        return prev;\n    }\n    /**\n     * @ignore\n     * Copy values from 'from' to 'to'.\n     *\n     * @param from - The initial node to copy from\n     * @param prev - The root of the initial node to copy to\n     * @param count - The number of values to copy\n     */\n    protected _copyWithin(from: LinkedNode<T>, to: LinkedNode<T>, count: number): LinkedNode<T> {\n        while (count-- > 0) {\n            from = from.next!;\n            to = to.next!;\n            to.value = from.value;\n        }\n        return to;\n    }\n    /**\n     * @ignore\n     * Get the node at the given index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number, root: LinkedNode<T> = this.root): LinkedNode<T> {\n        let node = root!;\n        while (index-- >= 0) {\n            node = node.next!;\n        }\n        return node;\n    }\n}\n","import { Queue } from './queue';\n\n/**\n * An implementation of the {@link Queue} interface using an array\n */\nexport class ArrayQueue<T> implements Queue<T> {\n    /**\n     * @ignore\n     */\n    protected array: T[];\n\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n    /**\n     * Removes all elements from this queue\n     */\n    clear(): void {\n        this.array.length = 0;\n    }\n    /**\n     * Retrieves and removes the head of this queue\n     *\n     * @returns The element at the head of the queue or `undefined` if this queue is empty.\n     */\n    dequeue(): T | undefined {\n        return this.size < 1 ? undefined : this.array.shift();\n    }\n    /**\n     * Inserts the specified element into this queue\n     *\n     * @param element - The element to be inserted\n     */\n    enqueue(element: T): number {\n        return this.array.push(element);\n    }\n    /**\n     * Retrieves, but does not remove, the head of this queue\n     *\n     * @returns The value at the head of the queue or `undefined` if this queue is empty.\n     */\n    peek(): T | undefined {\n        return this.size < 1 ? undefined : this.array[0];\n    }\n    /**\n     * The number of elements in this queue\n     */\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Queue } from './queue';\n\n/**\n * A linked list implementation of the {@link Queue} interface\n */\nexport class LinkedQueue<T> implements Queue<T> {\n    /**\n     * @ignore\n     */\n    protected list: List<T>;\n\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList(elements);\n    }\n    /**\n     * Removes all elements from this queue\n     */\n    clear(): void {\n        this.list.clear();\n    }\n    /**\n     * Retrieves and removes the head of this queue\n     *\n     * @returns The element at the head of the queue or `undefined` if this queue is empty.\n     */\n    dequeue(): T | undefined {\n        return this.list.shift();\n    }\n    /**\n     * Inserts the specified element into this queue\n     *\n     * @param element - The element to be inserted\n     */\n    enqueue(element: T): number {\n        return this.list.push(element);\n    }\n    /**\n     * Retrieves, but does not remove, the head of this queue\n     *\n     * @returns The element at the head of the queue or `undefined` if this queue is empty.\n     */\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n    /**\n     * The number of elements in this queue\n     */\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","import { Stack } from './stack';\n\n/**\n * An implementation of the {@link Stack} interface using an array\n */\nexport class ArrayStack<T> implements Stack<T> {\n    /**\n     * @ignore\n     */\n    protected array: T[];\n\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n    /**\n     * Removes all elements from the stack\n     */\n    clear(): void {\n        this.array.length = 0;\n    }\n    /**\n     * Retrieves, but does not remove, the top of the stack\n     *\n     * @returns The element at the top of the stack or `undefined` if empty.\n     */\n    peek(): T | undefined {\n        return this.array[this.array.length - 1];\n    }\n    /**\n     * Retrieves and removes the top of the stack\n     *\n     * @returns The element at the top of the stack or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n    /**\n     * Inserts a element into the stack\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns The new size of the stack\n     */\n    push(element: T): number {\n        return this.array.push(element);\n    }\n    /**\n     * The number of elements in the stack\n     */\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        const array = this.array;\n        for (let i = array.length; i > 0; yield array[--i]) {}\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Stack } from './stack';\n\n/**\n * A linked list implementation of the {@link Stack} interface\n */\nexport class LinkedStack<T> implements Stack<T> {\n    /**\n     * @ignore\n     */\n    protected list: List<T>;\n\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList();\n        for (const element of elements || []) {\n            this.push(element);\n        }\n    }\n    /**\n     * Removes all elements from the stack\n     */\n    clear(): void {\n        this.list.clear();\n    }\n    /**\n     * Retrieves, but does not remove, the top of the stack\n     *\n     * @returns The element at the top of the stack or `undefined` if empty.\n     */\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n    /**\n     * Retrieves and removes the top of the stack\n     *\n     * @returns The element at the top of the stack or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        return this.list.shift();\n    }\n    /**\n     * Inserts a element into the stack\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns The new size of the stack\n     */\n    push(element: T): number {\n        return this.list.unshift(element);\n    }\n    /**\n     * The number of elements in the stack\n     */\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","/**\n * @ignore\n */\nexport function* batch<T>(size: number, elements: Iterable<T>): Generator<T[]> {\n    let array: T[] = [];\n    for (const element of elements) {\n        if (array.push(element) >= size) {\n            yield array;\n            array = [];\n        }\n    }\n    if (array.length > 0) {\n        yield array;\n    }\n}\n/**\n * @ignore\n */\nexport function clamp(num: number, min: number, max: number): number {\n    return Math.min(max, Math.max(min, num));\n} /*\nexport function* first<T>(num: number, iterator: Iterator<T>): Generator<T> {\n    while (num-- > 0) {\n        const res = iterator.next();\n        if (res.done) {\n            break;\n        }\n        yield res.value;\n    }\n}\n*/ /*\nexport function* iterate<T>(iterator: Iterator<T>): Generator<T> {\n    let res = iterator.next();\n    while (!res.done) {\n        yield res.value;\n        res = iterator.next();\n    }\n}\n*/\n/**\n * @ignore\n */\n/**\n * @ignore\n */\n/**\n * @ignore\n */ export function wrap(num: number, min: number, max: number): number {\n    return clamp(num < 0 ? max + num : num, min, max);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}