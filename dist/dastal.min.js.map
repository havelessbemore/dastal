{"version":3,"sources":["webpack://Dastal/webpack/universalModuleDefinition","webpack://Dastal/./src/list/arrayList.ts","webpack://Dastal/./src/list/doublyLinkedList.ts","webpack://Dastal/./src/list/linkedList.ts","webpack://Dastal/./src/queue/arrayQueue.ts","webpack://Dastal/./src/queue/linkedQueue.ts","webpack://Dastal/./src/stack/arrayStack.ts","webpack://Dastal/./src/stack/linkedStack.ts","webpack://Dastal/./src/utils.ts","webpack://Dastal/webpack/bootstrap","webpack://Dastal/webpack/runtime/compat get default export","webpack://Dastal/webpack/runtime/define property getters","webpack://Dastal/webpack/runtime/hasOwnProperty shorthand","webpack://Dastal/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","self","Symbol","iterator","ArrayList","elements","this","array","Array","from","index","element","size","splice","batch","items","length","out","lists","list","push","min","max","wrap","copyWithin","fill","undefined","callback","value","pop","slice","reverse","prev","shift","start","count","clamp","unshift","arguments","len","Math","DoublyLinkedList","next","_get","node","nodeA","nodeB","tail","temp","head","view","first","iterate","newNode","i","LinkedList","_copyWithin","nodeC","nodeD","remove","newTail","to","ArrayQueue","LinkedQueue","clear","get","ArrayStack","LinkedStack","f","num","res","done","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","r","toStringTag"],"mappings":"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","file":"dastal.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Dastal\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Dastal\"] = factory();\n\telse\n\t\troot[\"Dastal\"] = factory();\n})(self, function() {\nreturn ","import { List } from './list';\nimport { batch, clamp, wrap } from '../utils';\n\n/**\n * An implementation of the {@link List} interface using an array\n */\nexport class ArrayList<T> implements List<T> {\n    /**\n     * @ignore\n     */\n    protected array: Array<T>;\n\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n    /**\n     * Add the element at the specified index.\n     *\n     * @param index - The index to add into\n     * @param element - The element to add\n     *\n     * @returns The new size of the list\n     */\n    add(index: number, element: T): number {\n        if (index >= 0 && index <= this.size) {\n            this.array.splice(index, 0, element);\n        }\n        return this.size;\n    }\n    /**\n     * Add elements at the specified index.\n     *\n     * @param index - The index to add into\n     * @param element - The elements to add\n     *\n     * @returns The new size of the list\n     */\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.size) {\n            for (const items of batch(10000, elements)) {\n                this.array.splice(index, 0, ...items);\n                index += items.length;\n            }\n        }\n        return this.size;\n    }\n    /**\n     * Removes all elements\n     */\n    clear(): void {\n        this.array.length = 0;\n    }\n    /**\n     * Combines the list with multiple iterables into a new list.\n     * Does not modify the existing list or inputs.\n     *\n     * @param lists — Additional iterables to add to the end of the list.\n     *\n     * @returns A new list consisting of the elements in the list on which\n     * it is called, followed in order by the elements of each argument. It\n     * does not recurse into nested iterable arguments\n     */\n    concat(...lists: Iterable<T>[]): ArrayList<T> {\n        const out = new ArrayList(this);\n        for (const list of lists) {\n            for (const element of list) {\n                out.push(element);\n            }\n        }\n        return out;\n    }\n    /**\n     * Copies a section of the list identified by min and max to the same array at position index.\n     *\n     * Negative indices can be used for index, min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * Note that this method will not change the size of the list. If index is after min,\n     * the copied sequence will be trimmed to fit list.size\n     *\n     * @param index - Where to copy the sequence to\n     * @param min - Where to start copying elements from, inclusive. Defaults to 0\n     * @param max - Where to end copying elements from, exclusive. Defaults to list.size\n     *\n     * @returns The list\n     */\n    copyWithin(index: number, min?: number, max?: number): this {\n        index = wrap(index ?? 0, 0, this.size);\n        min = wrap(min ?? 0, 0, this.size);\n        max = wrap(max ?? this.size, 0, this.size);\n        this.array.copyWithin(index, min, max);\n        return this;\n    }\n    /**\n     * Returns the this object after filling the section identified by min and max with element.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param element — element to fill list section with\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param end - Where to stop filling the list, exclusive. Defaults to list.size\n     *\n     * @returns The list on which this method was called\n     */\n    fill(element: T, min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.size);\n        max = wrap(max ?? this.size, 0, this.size);\n        this.array.fill(element, min, max);\n        return this;\n    }\n    /**\n     * Return the element at the specified index.\n     *\n     * A negative index can be used for to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The element at the index, or `undefined` if index is invalid\n     */\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array[index];\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * A negative index can be used to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param index - The index to retrieve\n     * @param callback - A function that receives the previous element and returns\n     * the new element. The function is only called if the index is valid\n     *\n     * @returns The previous element at the index, or `undefined` if index is invalid\n     */\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        let value: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            value = this.array[index];\n            this.array[index] = callback(value);\n        }\n        return value;\n    }\n    /**\n     * Retrieves and removes the end of the list\n     *\n     * @returns The element at the end of the list, or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n    /**\n     * Inserts the specified element into the end of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns The new size of the list\n     */\n    push(element: T): number {\n        return this.array.push(element);\n    }\n    /**\n     * Retrieves and removes the element at the given index.\n     *\n     * A negative index can be used to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param index - The index to remove\n     *\n     * @returns The value at the index, or `undefined` if the index is invalid\n     */\n    remove(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array.splice(index, 1)[0];\n    }\n    /**\n     * Reverses the elements in the list in place.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns a reference to the same list\n     */\n    reverse(min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.size);\n        max = wrap(max ?? this.size, 0, this.size);\n        for (const items of batch(1000, this.array.slice(min, max).reverse())) {\n            this.array.splice(min, items.length, ...items);\n            min += items.length;\n        }\n        return this;\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * @param index - The index to retrieve\n     * @param element - The new element to insert at index\n     *\n     * @returns The previous element in the index, or undefined if the index is invalid\n     */\n    set(index: number, element: T): T | undefined {\n        let prev: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            prev = this.array[index];\n            this.array[index] = element;\n        }\n        return prev;\n    }\n    /**\n     * Retrieves and removes the first element in the list\n     *\n     * @returns The element at the front of the list or `undefined` if this list is empty.\n     */\n    shift(): T | undefined {\n        return this.array.shift();\n    }\n    /**\n     * The number of elements in this list\n     */\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Returns a copy of a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns A new list with a copy of the indicated section of the original list\n     */\n    slice(min?: number, max?: number): ArrayList<T> {\n        return new ArrayList(this.array.slice(min, max));\n    }\n    /**\n     * Removes elements from the list and optionally inserts new elements in their place.\n     * Returns any deleted elements.\n     *\n     * @param start - The index from which to start removing elements. Defaults to 0\n     *\n     * If > size, start will be set to size. In this case, no element will be\n     * deleted but the method can still add elements to the end of the list.\n     *\n     * If < 0, start will indicate an offset from the end of the list. For example,\n     * -2 refers to the second to last element of the list.\n     *\n     * If < -size, start will be set to 0\n     * @param count - The number of elements to remove. Defaults to size - start\n     *\n     * If >= size - start (that is, if it's >= than the number of elements from start\n     * until the end of the list), then all the elements from start until the end of\n     * the list will be removed.\n     *\n     * If <= 0, no elements are removed\n     * @param elements - The new elements to insert at start. Defaults to none\n     *\n     * @returns A new list of deleted elements\n     */\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = wrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n        const list = new ArrayList(this.array.splice(start, count));\n        for (const items of batch(10000, elements ?? [])) {\n            this.array.splice(start, 0, ...items);\n            start += items.length;\n        }\n        return list;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n    /**\n     * Inserts the specified element into the front of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns The new size of the list\n     */\n    unshift(element: T): number {\n        return this.array.unshift(element);\n    }\n    /**\n     * Update the elements of the list\n     *\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(callback: (element: T, index: number) => T): this;\n    /**\n     * Update the elements of the list\n     *\n     * Negative indices can be used to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    /**\n     * Update the elements of the list\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param max - Where to stop filling the list, exclusive. Defaults to list.size\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = wrap((min as number) ?? 0, 0, this.size);\n        max = wrap((max as number) ?? this.size, 0, this.size);\n        while (min < max) {\n            this.array[min] = callback(this.array[min], min);\n            ++min;\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns An iterator through the indicated section of the list\n     */\n    *view(min?: number, max?: number): Iterable<T> {\n        min = wrap(min ?? 0, 0, this.size);\n\n        let len = () => Math.min(max!, this.size);\n        if (max == null) {\n            len = () => this.size;\n        } else if (max < 0) {\n            len = () => this.size + max!;\n        }\n\n        while (min < len()) {\n            yield this.array[min++];\n        }\n    }\n}\n","import { List } from './list';\nimport { clamp, first, iterate, wrap } from '../utils';\n\n/**\n * A doubly-linked node version of the {@link LinkedNode} interface.\n *\n * Each node links to its neighbors on the left (prev) and right (next) of it.\n */\nexport interface DoublyLinkedNode<T> {\n    /**\n     * A link to the node's next (right) neighbor\n     */\n    next?: DoublyLinkedNode<T>;\n    /**\n     * A link to the node's previous (left) neighbor\n     */\n    prev?: DoublyLinkedNode<T>;\n    /**\n     * The value of the node\n     */\n    value: T;\n}\n/**\n * A (circular) doubly-linked list implementation of the {@link List} interface.\n *\n * Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.\n */\nexport class DoublyLinkedList<T> implements List<T> {\n    /**\n     * @ignore\n     * The number of elements in this list\n     */\n    protected length: number;\n    /**\n     * @ignore\n     * The first node in the list\n     */\n    protected root: DoublyLinkedNode<T>;\n\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as DoublyLinkedNode<T>;\n        this.root.prev = this.root.next = this.root;\n        for (const element of elements || []) {\n            this.push(element);\n        }\n    }\n    /**\n     * Add the element at the specified index.\n     *\n     * @param index - The index to add into (0 <= index <= size)\n     * @param element - The element to add\n     *\n     * @returns The new size of the list\n     */\n    add(index: number, value: T): number {\n        if (index < 0 || index > this.length) {\n            return this.length;\n        }\n        const prev = this._get(index - 1);\n        const node = { next: prev.next, prev, value };\n        prev.next = node;\n        node.next!.prev = node;\n        return ++this.length;\n    }\n    /**\n     * Add elements at the specified index.\n     *\n     * @param index - The index to add into (0 <= index <= size)\n     * @param element - The elements to add\n     *\n     * @returns The new size of the list\n     */\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index < 0 || index > this.length) {\n            return this.length;\n        }\n\n        let prev = this._get(index - 1);\n        const next = prev.next!;\n        for (const value of elements) {\n            const node = { prev, value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        next.prev = prev;\n\n        return this.length;\n    }\n    /**\n     * Removes all elements\n     */\n    clear(): void {\n        this.length = 0;\n        this.root.prev = this.root.next = this.root;\n    }\n    /**\n     * Combines the list with multiple iterables into a new list.\n     * Does not modify the existing list or inputs.\n     *\n     * @param lists — Additional iterables to add to the end of the list.\n     *\n     * @returns A new list consisting of the elements in the list on which\n     * it is called, followed in order by the elements of each argument. It\n     * does not recurse into nested iterable arguments\n     */\n    concat(...lists: Iterable<T>[]): DoublyLinkedList<T> {\n        const out = new DoublyLinkedList(this);\n        for (const list of lists) {\n            for (const element of list) {\n                out.push(element);\n            }\n        }\n        return out;\n    }\n    /**\n     * Copies a section of the list identified by min and max to the same array at position index.\n     *\n     * Negative indices can be used for index, min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * Note that this method will not change the size of the list. If index is after min,\n     * the copied sequence will be trimmed to fit list.size\n     *\n     * @param index - Where to copy the sequence to\n     * @param min - Where to start copying elements from, inclusive. Defaults to 0\n     * @param max - Where to end copying elements from, exclusive. Defaults to list.size\n     *\n     * @returns The list\n     */\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to the same section\n        index = wrap(index, 0, this.length);\n        min = wrap(min ?? 0, 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = wrap(max ?? this.length, 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Check for overlap edge case\n        if (min < index && index < max) {\n            let nodeA = this._get(max);\n            let nodeB = this._get(index + (max - min));\n            do {\n                nodeA = nodeA.prev!;\n                nodeB = nodeB.prev!;\n                nodeB.value = nodeA.value;\n            } while (min < --max);\n            return this;\n        }\n\n        // Copy the section to the destination\n        let nodeA = this._get(min);\n        let nodeB = this._get(index);\n        do {\n            nodeB.value = nodeA.value;\n            nodeA = nodeA.next!;\n            nodeB = nodeB.next!;\n        } while (++min < max);\n        return this;\n    }\n    /**\n     * Returns the this object after filling the section identified by min and max with element.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param element — element to fill list section with\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param end - Where to stop filling the list, exclusive. Defaults to list.size\n     *\n     * @returns The list on which this method was called\n     */\n    fill(element: T, min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.length);\n        max = wrap(max ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n    /**\n     * Return the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     *\n     * @returns The element at the index, or `undefined` if index is invalid\n     */\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.length ? undefined : this._get(index).value;\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     * @param callback - A function that receives the previous element and returns\n     * the new element. The function is only called if the index is valid\n     *\n     * @returns The previous element at the index, or `undefined` if index is invalid\n     */\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n    /**\n     * Retrieves and removes the end of the list\n     *\n     * @returns The element at the end of the list, or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const tail = this.root.prev!;\n        tail.prev!.next = this.root;\n        this.root.prev = tail.prev;\n        --this.length;\n        return tail.value;\n    }\n    /**\n     * Inserts the specified element into the end of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns `true` upon success, otherwise `false`\n     */\n    push(value: T): number {\n        const tail = this.root.prev!;\n        const node = { next: this.root, prev: tail, value };\n        tail.next = this.root.prev = node;\n        return ++this.length;\n    }\n    /**\n     * Retrieves and removes the element at the given index.\n     *\n     * @param index - The index to remove (0 <= index < size)\n     *\n     * @returns The value at the index, or `undefined` if the index is invalid\n     */\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        node.prev!.next = node.next;\n        node.next!.prev = node.prev;\n        --this.length;\n        return node.value;\n    }\n    /**\n     * Reverses the elements in the list in place.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns a reference to the same list\n     */\n    reverse(min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.length);\n        max = wrap(max ?? this.length, 0, this.length);\n        if (max - min > 1) {\n            const root = this._get(min - 1);\n            const tail = root.next!;\n            let node = tail;\n            do {\n                const temp = node.next!;\n                node.next = node.prev;\n                node.prev = temp;\n                root.next = node;\n                node = temp;\n            } while (++min < max);\n            tail.next = node;\n            node.prev = tail;\n            root.next!.prev = root;\n        }\n        return this;\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     * @param element - The new element to insert at index\n     *\n     * @returns The previous element in the index, or undefined if the index is invalid\n     */\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const prev = node.value;\n        node.value = element;\n        return prev;\n    }\n    /**\n     * Retrieves and removes the first element in the list\n     *\n     * @returns The element at the front of the list or `undefined` if this list is empty.\n     */\n    shift(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const head = this.root.next!;\n        head.next!.prev = this.root;\n        this.root.next = head.next;\n        --this.length;\n        return head.value;\n    }\n    /**\n     * The number of elements in this list\n     */\n    get size(): number {\n        return this.length;\n    }\n    /**\n     * Returns a copy of a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns A new list with a copy of the indicated section of the original list\n     */\n    slice(min?: number, max?: number): DoublyLinkedList<T> {\n        return new DoublyLinkedList(this.view(min, max));\n    }\n    /**\n     * Removes elements from the list and optionally inserts new elements in their place.\n     * Returns any deleted elements.\n     *\n     * @param start - The index from which to start removing elements. Defaults to 0\n     *\n     * If > size, start will be set to size. In this case, no element will be\n     * deleted but the method can still add elements to the end of the list.\n     *\n     * If < 0, start will indicate an offset from the end of the list. For example,\n     * -2 refers to the second to last element of the list.\n     *\n     * If < -size, start will be set to 0\n     * @param count - The number of elements to remove. Defaults to size - start\n     *\n     * If >= size - start (that is, if it's >= than the number of elements from start\n     * until the end of the list), then all the elements from start until the end of\n     * the list will be removed.\n     *\n     * If <= 0, no elements are removed\n     * @param elements - The new elements to insert at start. Defaults to none\n     *\n     * @returns A new list of deleted elements\n     */\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = wrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n        const list = new DoublyLinkedList<T>();\n        const iterator = (elements ?? [])[Symbol.iterator]();\n\n        // Replace elements\n        let node = this._get(start);\n        for (const element of first(count, iterator)) {\n            list.push(node.value);\n            node.value = element;\n            node = node.next!;\n            --count;\n        }\n\n        // Delete elements\n        if (count > 0) {\n            while (count-- > 0) {\n                list.push(node.value);\n                node.prev!.next = node.next!;\n                node.next!.prev = node.prev!;\n                node = node.next!;\n                --this.length;\n            }\n\n            // Add elements\n        } else {\n            for (const value of iterate(iterator)) {\n                const newNode = { next: node, prev: node.prev, value };\n                node.prev!.next = newNode;\n                node.prev = newNode;\n                ++this.length;\n            }\n        }\n\n        return list;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        let node = this.root;\n        for (let i = 0; i < this.length; ++i) {\n            node = node.next!;\n            yield node.value;\n        }\n    }\n    /**\n     * Inserts the specified element into the front of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns `true` upon success, otherwise `false`\n     */\n    unshift(value: T): number {\n        const head = this.root.next!;\n        const node = { next: head, prev: this.root, value };\n        this.root.next = head.prev = node;\n        return ++this.length;\n    }\n    /**\n     * Update the elements of the list\n     *\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(callback: (element: T, index: number) => T): this;\n    /**\n     * Update the elements of the list\n     *\n     * Negative indices can be used to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    /**\n     * Update the elements of the list\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param max - Where to stop filling the list, exclusive. Defaults to list.size\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = wrap((min as number) ?? 0, 0, this.length);\n        max = wrap((max as number) ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns An iterator through the indicated section of the list\n     */\n    *view(min?: number, max?: number): Iterable<T> {\n        min = wrap(min ?? 0, 0, this.length);\n\n        let len = () => Math.min(max!, this.length);\n        if (max == null) {\n            len = () => this.length;\n        } else if (max < 0) {\n            len = () => this.length + max!;\n        }\n\n        if (min < len()) {\n            let prev = this._get(min);\n            do {\n                yield prev.value;\n                prev = prev.next!;\n            } while (++min < len());\n        }\n    }\n    /**\n     * @ignore\n     * A helper method to iterate and return the node at the given index.\n     *\n     * Depending on the index, the list will be traversed from beginning or end; whichever is closest to the specified index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number): DoublyLinkedNode<T> {\n        let node = this.root;\n        if (index < this.length / 2) {\n            while (index-- >= 0) {\n                node = node.next!;\n            }\n        } else {\n            for (index = this.length - index; index > 0; --index) {\n                node = node.prev!;\n            }\n        }\n        return node;\n    }\n}\n","import { List } from './list';\nimport { clamp, first, iterate, wrap } from '../utils';\n\n/**\n * A linked node interface.\n *\n * Each node links to its next neighbor.\n */\nexport interface LinkedNode<T> {\n    /**\n     * A link to the node's neighbor\n     */\n    next?: LinkedNode<T>;\n    /**\n     * The value of the node\n     */\n    value: T;\n}\n/**\n * A (circular) linked list implementation of the {@link List} interface.\n */\nexport class LinkedList<T> implements List<T> {\n    /**\n     * @ignore\n     */\n    protected length: number;\n    /**\n     * @ignore\n     */\n    protected root: LinkedNode<T>;\n    /**\n     * @ignore\n     */\n    protected tail: LinkedNode<T>;\n\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as LinkedNode<T>;\n        this.tail = this.root.next = this.root;\n        for (const element of elements || []) {\n            this.push(element);\n        }\n    }\n    /**\n     * Add the element at the specified index.\n     *\n     * @param index - The index to add into (0 <= index <= size)\n     * @param element - The element to add\n     *\n     * @returns The new size of the list\n     */\n    add(index: number, value: T): number {\n        if (index < 0 || index >= this.length) {\n            return index == this.length ? this.push(value) : this.length;\n        }\n        const prev = this._get(index - 1);\n        prev.next = { value, next: prev.next };\n        return ++this.length;\n    }\n    /**\n     * Add elements at the specified index.\n     *\n     * @param index - The index to add into (0 <= index <= size)\n     * @param element - The elements to add\n     *\n     * @returns The new size of the list\n     */\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index < 0 || index >= this.length) {\n            if (index == this.length) {\n                for (const element of elements) {\n                    this.push(element);\n                }\n            }\n            return this.length;\n        }\n        let prev = this._get(index - 1);\n        const next = prev.next!;\n        for (const value of elements) {\n            const node = { value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        return this.length;\n    }\n    /**\n     * Removes all elements\n     */\n    clear(): void {\n        this.length = 0;\n        this.tail = this.root.next = this.root;\n    }\n    /**\n     * Combines the list with multiple iterables into a new list.\n     * Does not modify the existing list or inputs.\n     *\n     * @param lists — Additional iterables to add to the end of the list.\n     *\n     * @returns A new list consisting of the elements in the list on which\n     * it is called, followed in order by the elements of each argument. It\n     * does not recurse into nested iterable arguments\n     */\n    concat(...lists: Iterable<T>[]): LinkedList<T> {\n        const out = new LinkedList(this);\n        for (const list of lists) {\n            for (const element of list) {\n                out.push(element);\n            }\n        }\n        return out;\n    }\n    /**\n     * Copies a section of the list identified by min and max to the same array at position index.\n     *\n     * Negative indices can be used for index, min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * Note that this method will not change the size of the list. If index is after min,\n     * the copied sequence will be trimmed to fit list.size\n     *\n     * @param index - Where to copy the sequence to\n     * @param min - Where to start copying elements from, inclusive. Defaults to 0\n     * @param max - Where to end copying elements from, exclusive. Defaults to list.size\n     *\n     * @returns The list\n     */\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to itself\n        index = wrap(index, 0, this.length);\n        min = wrap(min ?? 0, 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = wrap(max ?? this.length, 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Copy to earlier in the list\n        if (index < min) {\n            const node = this._get(index - 1);\n            this._copyWithin(this._get(min - index - 1, node), node, max - min);\n            return this;\n        }\n\n        // Copy to later in the list\n        if (index > max) {\n            const node = this._get(min - 1);\n            this._copyWithin(node, this._get(index - min - 1, node), max - min);\n            return this;\n        }\n\n        // Copy to overlapping destination\n        const nodeA = this._get(min - 1);\n        const nodeC = this._get(max - min - 1, nodeA);\n        const nodeD = this._copyWithin(nodeA, nodeC, index - min);\n        if (index + (max - min) >= this.length) {\n            this.tail = nodeC;\n        }\n        const temp = nodeA.next;\n        nodeA.next = nodeC.next;\n        nodeC.next = nodeD.next;\n        nodeD.next = temp;\n        return this;\n    }\n    /**\n     * Returns the this object after filling the section identified by min and max with element.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param element — element to fill list section with\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param end - Where to stop filling the list, exclusive. Defaults to list.size\n     *\n     * @returns The list on which this method was called\n     */\n    fill(element: T, min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.length);\n        max = wrap(max ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n    /**\n     * Return the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     *\n     * @returns The element at the index, or `undefined` if index is invalid\n     */\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.length ? undefined : this._get(index).value;\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     * @param callback - A function that receives the previous element and returns\n     * the new element. The function is only called if the index is valid\n     *\n     * @returns The previous element at the index, or `undefined` if index is invalid\n     */\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n    /**\n     * Retrieves and removes the end of the list\n     *\n     * @returns The value at the end of the list, or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        return this.remove(this.length - 1);\n    }\n    /**\n     * Inserts the specified value into the end of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns `true` upon success, otherwise `false`\n     */\n    push(value: T): number {\n        const tail: LinkedNode<T> = { value } as LinkedNode<T>;\n        tail.next = this.root;\n        this.tail.next = tail;\n        this.tail = tail;\n        return ++this.length;\n    }\n    /**\n     * Retrieves and removes the element at the given index.\n     *\n     * @param index - The index to remove (0 <= index < size)\n     *\n     * @returns The value at the index, or `undefined` if the index is invalid\n     */\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const prev = this._get(index - 1);\n        const node = prev.next!;\n        prev.next = node.next;\n        --this.length;\n        return node.value;\n    }\n    /**\n     * Reverses the elements in the list in place.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns a reference to the same list\n     */\n    reverse(min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.length);\n        max = wrap(max ?? this.length, 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        this.tail = max >= this.length ? root.next! : this.tail;\n        const tail = root.next!;\n        let prev = tail;\n        let node = tail.next!;\n        while (++min < max) {\n            const next = node.next!;\n            node.next = prev;\n            prev = node;\n            node = next;\n        }\n        root.next = prev;\n        tail.next = node;\n        return this;\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     * @param element - The new element to insert at index\n     *\n     * @returns The previous element in the index, or undefined if the index is invalid\n     */\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n    /**\n     * Retrieves and removes the first element in the list\n     *\n     * @returns The value at the front of the list or `undefined` if this list is empty.\n     */\n    shift(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const head = this.root.next!;\n        this.root.next = head.next;\n        --this.length;\n        return head.value;\n    }\n    /**\n     * The number of elements in this list\n     */\n    get size(): number {\n        return this.length;\n    }\n    /**\n     * Returns a copy of a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns A new list with a copy of the indicated section of the original list\n     */\n    slice(min?: number, max?: number): LinkedList<T> {\n        return new LinkedList(this.view(min, max));\n    }\n    /**\n     * Removes elements from the list and optionally inserts new elements in their place.\n     * Returns any deleted elements.\n     *\n     * @param start - The index from which to start removing elements. Defaults to 0\n     *\n     * If > size, start will be set to size. In this case, no element will be\n     * deleted but the method can still add elements to the end of the list.\n     *\n     * If < 0, start will indicate an offset from the end of the list. For example,\n     * -2 refers to the second to last element of the list.\n     *\n     * If < -size, start will be set to 0\n     * @param count - The number of elements to remove. Defaults to size - start\n     *\n     * If >= size - start (that is, if it's >= than the number of elements from start\n     * until the end of the list), then all the elements from start until the end of\n     * the list will be removed.\n     *\n     * If <= 0, no elements are removed\n     * @param elements - The new elements to insert at start. Defaults to none\n     *\n     * @returns A new list of deleted elements\n     */\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = wrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n        const newTail = start + count >= this.size;\n        const list = new LinkedList<T>();\n        const iterator = (elements ?? [])[Symbol.iterator]();\n\n        // Replace elements\n        let prev = this._get(start - 1);\n        for (const element of first(count, iterator)) {\n            const node = prev.next!;\n            list.push(node.value);\n            node.value = element;\n            prev = node;\n            --count;\n        }\n\n        // Delete elements\n        if (count > 0) {\n            do {\n                const node = prev.next!;\n                list.push(node.value);\n                prev.next = node.next;\n                --this.length;\n            } while (--count > 0);\n\n            // Add elements\n        } else {\n            for (const value of iterate(iterator)) {\n                const node = { next: prev.next, value };\n                prev.next = node;\n                prev = node;\n                ++start;\n                ++this.length;\n            }\n        }\n\n        // Update state\n        if (newTail) {\n            this.tail = prev;\n        }\n\n        return list;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        let node = this.root;\n        for (let i = 0; i < this.length; ++i) {\n            node = node!.next!;\n            yield node.value;\n        }\n    }\n    /**\n     * Inserts the specified value into the front of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns `true` upon success, otherwise `false`\n     */\n    unshift(value: T): number {\n        const head: LinkedNode<T> = { value } as LinkedNode<T>;\n        head.next = this.root.next;\n        this.root.next = head;\n        return ++this.length;\n    }\n    /**\n     * Update the elements of the list\n     *\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(callback: (element: T, index: number) => T): this;\n    /**\n     * Update the elements of the list\n     *\n     * Negative indices can be used to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    /**\n     * Update the elements of the list\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param max - Where to stop filling the list, exclusive. Defaults to list.size\n     * @param callback - A function called for each index. Returns the new element\n     *\n     * @returns The list on which this method was called\n     */\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = wrap((min as number) ?? 0, 0, this.length);\n        max = wrap((max as number) ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns An iterator through the indicated section of the list\n     */\n    *view(min?: number, max?: number): Iterable<T> {\n        min = wrap(min ?? 0, 0, this.length);\n\n        let len = () => Math.min(max!, this.length);\n        if (max == null) {\n            len = () => this.length;\n        } else if (max < 0) {\n            len = () => this.length + max!;\n        }\n\n        if (min < len()) {\n            let prev = this._get(min);\n            do {\n                yield prev.value;\n                prev = prev.next!;\n            } while (++min < len());\n        }\n    }\n    /**\n     * @ignore\n     * Copy values from 'from' to 'to'.\n     *\n     * @param from - The initial node to copy from\n     * @param prev - The root of the initial node to copy to\n     * @param count - The number of values to copy\n     */\n    protected _copyWithin(from: LinkedNode<T>, to: LinkedNode<T>, count: number): LinkedNode<T> {\n        while (count-- > 0) {\n            from = from.next!;\n            to = to.next!;\n            to.value = from.value;\n        }\n        return to;\n    }\n    /**\n     * @ignore\n     * Get the node at the given index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number, root: LinkedNode<T> = this.root): LinkedNode<T> {\n        let node = root!;\n        while (index-- >= 0) {\n            node = node.next!;\n        }\n        return node;\n    }\n}\n","import { Queue } from './queue';\n\n/**\n * An implementation of the {@link Queue} interface using an array\n */\nexport class ArrayQueue<T> implements Queue<T> {\n    /**\n     * @ignore\n     */\n    protected array: T[];\n\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n    /**\n     * Removes all elements from this queue\n     */\n    clear(): void {\n        this.array.length = 0;\n    }\n    /**\n     * Retrieves and removes the head of this queue\n     *\n     * @returns The element at the head of the queue or `undefined` if this queue is empty.\n     */\n    dequeue(): T | undefined {\n        return this.size < 1 ? undefined : this.array.shift();\n    }\n    /**\n     * Inserts the specified element into this queue\n     *\n     * @param element - The element to be inserted\n     */\n    enqueue(element: T): number {\n        return this.array.push(element);\n    }\n    /**\n     * Retrieves, but does not remove, the head of this queue\n     *\n     * @returns The value at the head of the queue or `undefined` if this queue is empty.\n     */\n    peek(): T | undefined {\n        return this.size < 1 ? undefined : this.array[0];\n    }\n    /**\n     * The number of elements in this queue\n     */\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Queue } from './queue';\n\n/**\n * A linked list implementation of the {@link Queue} interface\n */\nexport class LinkedQueue<T> implements Queue<T> {\n    /**\n     * @ignore\n     */\n    protected list: List<T>;\n\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList(elements);\n    }\n    /**\n     * Removes all elements from this queue\n     */\n    clear(): void {\n        this.list.clear();\n    }\n    /**\n     * Retrieves and removes the head of this queue\n     *\n     * @returns The element at the head of the queue or `undefined` if this queue is empty.\n     */\n    dequeue(): T | undefined {\n        return this.list.shift();\n    }\n    /**\n     * Inserts the specified element into this queue\n     *\n     * @param element - The element to be inserted\n     */\n    enqueue(element: T): number {\n        return this.list.push(element);\n    }\n    /**\n     * Retrieves, but does not remove, the head of this queue\n     *\n     * @returns The element at the head of the queue or `undefined` if this queue is empty.\n     */\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n    /**\n     * The number of elements in this queue\n     */\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","import { Stack } from './stack';\n\n/**\n * An implementation of the {@link Stack} interface using an array\n */\nexport class ArrayStack<T> implements Stack<T> {\n    /**\n     * @ignore\n     */\n    protected array: T[];\n\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n    /**\n     * Removes all elements from the stack\n     */\n    clear(): void {\n        this.array.length = 0;\n    }\n    /**\n     * Retrieves, but does not remove, the top of the stack\n     *\n     * @returns The element at the top of the stack or `undefined` if empty.\n     */\n    peek(): T | undefined {\n        return this.array[this.array.length - 1];\n    }\n    /**\n     * Retrieves and removes the top of the stack\n     *\n     * @returns The element at the top of the stack or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n    /**\n     * Inserts a element into the stack\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns The new size of the stack\n     */\n    push(element: T): number {\n        return this.array.push(element);\n    }\n    /**\n     * The number of elements in the stack\n     */\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        const array = this.array;\n        for (let i = array.length; i > 0; yield array[--i]) {}\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Stack } from './stack';\n\n/**\n * A linked list implementation of the {@link Stack} interface\n */\nexport class LinkedStack<T> implements Stack<T> {\n    /**\n     * @ignore\n     */\n    protected list: List<T>;\n\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList();\n        for (const element of elements || []) {\n            this.push(element);\n        }\n    }\n    /**\n     * Removes all elements from the stack\n     */\n    clear(): void {\n        this.list.clear();\n    }\n    /**\n     * Retrieves, but does not remove, the top of the stack\n     *\n     * @returns The element at the top of the stack or `undefined` if empty.\n     */\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n    /**\n     * Retrieves and removes the top of the stack\n     *\n     * @returns The element at the top of the stack or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        return this.list.shift();\n    }\n    /**\n     * Inserts a element into the stack\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns The new size of the stack\n     */\n    push(element: T): number {\n        return this.list.unshift(element);\n    }\n    /**\n     * The number of elements in the stack\n     */\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","/**\n * @ignore\n */\nexport function* batch<T>(size: number, elements: Iterable<T>): Generator<T[]> {\n    let array: T[] = [];\n    for (const element of elements) {\n        if (array.push(element) >= size) {\n            yield array;\n            array = [];\n        }\n    }\n    if (array.length > 0) {\n        yield array;\n    }\n}\n/**\n * @ignore\n */\nexport function clamp(num: number, min: number, max: number): number {\n    return Math.min(max, Math.max(min, num));\n}\n/**\n * @ignore\n */\nexport function* first<T>(num: number, iterator: Iterator<T>): Generator<T> {\n    while (num-- > 0) {\n        const res = iterator.next();\n        if (res.done) {\n            break;\n        }\n        yield res.value;\n    }\n}\n/**\n * @ignore\n */\nexport function* iterate<T>(iterator: Iterator<T>): Generator<T> {\n    let res = iterator.next();\n    while (!res.done) {\n        yield res.value;\n        res = iterator.next();\n    }\n}\n/**\n * @ignore\n */\nexport function wrap(num: number, min: number, max: number): number {\n    return clamp(num < 0 ? max + num : num, min, max);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}