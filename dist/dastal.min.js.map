{"version":3,"sources":["webpack://Dastal/webpack/universalModuleDefinition","webpack://Dastal/./src/math/bits.ts","webpack://Dastal/./src/segmentTree/inOrderSegmentTree.ts","webpack://Dastal/./src/segmentTree/levelOrderSegmentTree.ts","webpack://Dastal/webpack/bootstrap","webpack://Dastal/webpack/runtime/compat get default export","webpack://Dastal/webpack/runtime/define property getters","webpack://Dastal/webpack/runtime/hasOwnProperty shorthand","webpack://Dastal/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","self","lsb","a","b","lsp","msb","msp","Symbol","iterator","InOrderSegmentTree","combine","values","this","array","build","value","push","length","size","i","mask","out","MAX_SIZE","RangeError","min","max","offset","transform","dc","dp","LevelOrderSegmentTree","level","n","Array","it","update","_","next","copyWithin","shrink","grow","cap","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","getter","__esModule","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","toStringTag"],"mappings":"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","file":"dastal.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Dastal\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Dastal\"] = factory();\n\telse\n\t\troot[\"Dastal\"] = factory();\n})(self, function() {\nreturn ","/**\n * Get the Least Significant Bit of a number\n *\n * @param a\n *\n * @returns The lowest bit set\n */\nexport function lsb(a: number): number {\n    let b = -1;\n    for (a = lsp(a); a !== 0; a >>>= 1) {\n        ++b;\n    }\n    return b;\n}\n\n/**\n * Get the Least Significant Power of a number\n *\n * @param a\n *\n * @returns 2**lsb(a)\n */\nexport function lsp(a: number): number {\n    return (a & -a) >>> 0;\n}\n\n/**\n * Get the Most Significant Bit of a number\n *\n * @param a\n *\n * @returns ⌊log2(a)⌋ : the highest bit set\n */\nexport function msb(a: number): number {\n    let b = -1;\n    while (a !== 0) {\n        ++b;\n        a >>>= 1;\n    }\n    return b;\n}\n\n/**\n * Get the Most Significant Power of a number\n *\n * @param a\n *\n * @returns 2**msb(a)\n */\nexport function msp(a: number): number {\n    for (let b = a & -a; a !== b; b = a & -a) {\n        a ^= b;\n    }\n    return a >>> 0;\n}\n","import { lsb, lsp, msb, msp } from 'src/math/bits';\nimport { SegmentTree } from './segmentTree';\nimport { CombineFn } from '..';\n\n/**\n * A {@link SegmentTree} with entries stored in in-order traversal.\n * Inspired by [Tristan Hume's IForestIndex](https://thume.ca/2021/03/14/iforests)([github](https://github.com/trishume/gigatrace))\n */\nexport class InOrderSegmentTree<T> implements SegmentTree<T> {\n    /**\n     * The maximum amount of values that can be added.\n     *\n     * According to [ECMA-262](https://tc39.es/ecma262/#array-index):\n     *    0 <= array.length <= 2^32 - 1\n     *\n     * So since n elements require 2n memory:\n     *    0 <= size <= 2^31 - 1/2\n     */\n    static readonly MAX_SIZE = 2147483647;\n\n    /**\n     * The internal array used to store values and aggregation nodes\n     */\n    protected array: Array<T>;\n\n    /**\n     * The function used to aggregate values\n     */\n    protected combine: CombineFn<T>;\n\n    /**\n     * Construct a new {@link InOrderSegmentTree}\n     *\n     * @param combine - The function used to aggregate segment information\n     * @param values - Initial values to {@link push} into the tree\n     */\n    constructor(combine: CombineFn<T>, values: Iterable<T> = []) {\n        this.array = [];\n        this.combine = combine;\n        this.build(values);\n    }\n\n    protected build(values: Iterable<T>) {\n        for (const value of values) {\n            this.push(value);\n        }\n    }\n\n    /**\n     * Remove all values\n     */\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    /**\n     * Remove the last added value\n     *\n     * @returns The last added value or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        // Sanitize range\n        if (this.size < 1) {\n            return undefined;\n        }\n\n        // Un-complete aggregation nodes\n        const i = this.array.length - 1;\n        for (let mask = 2; i & mask; mask *= 2) {\n            this.array[i - mask] = this.array[i - mask - (mask >>> 1)];\n        }\n\n        // Return value\n        const out = this.array[i - 1];\n        this.array.length -= 2;\n        return out;\n    }\n\n    /**\n     * Insert the given value into the end of the tree\n     *\n     * @param value - The value to be inserted\n     *\n     */\n    push(value: T): void {\n        // Sanitize range\n        if (this.size >= InOrderSegmentTree.MAX_SIZE) {\n            throw new RangeError(`Invalid SegmentTree length`);\n        }\n\n        // Add the new value\n        this.array.push(value);\n\n        // Complete aggregation nodes\n        const i = this.array.length;\n        for (let mask = 2; i & mask; mask *= 2) {\n            value = this.combine(this.array[i - mask], value);\n            this.array[i - mask] = value;\n        }\n\n        // Push new aggregation node\n        this.array.push(value);\n    }\n\n    /**\n     * Get the aggregated information for values in a given range\n     *\n     * @param min - The start of the range, inclusive\n     * @param max - The end of the range, exclusive\n     *\n     * @returns The aggregated information for values in range [min, max)\n     */\n    query(min: number, max: number): T {\n        // Sanitize range\n        if (min >= max) {\n            throw new RangeError(`Range [${min}..${max}) is empty`);\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min *= 2;\n        max *= 2;\n\n        // Take the longest possible jump from min\n        let offset = lsp(min | msp(max - min));\n        let value = this.array[min - 1 + (offset >>> 1)];\n        min += offset;\n\n        // Continue jumping until max\n        while (min < max) {\n            offset = lsp(min | msp(max - min));\n            value = this.combine(value, this.array[min - 1 + (offset >>> 1)]);\n            min += offset;\n        }\n\n        return value;\n    }\n\n    /**\n     * The number of values in the tree\n     *    0 <= size <= {@link MAX_SIZE}\n     */\n    get size(): number {\n        return this.array.length >>> 1;\n    }\n\n    /**\n     * Return an iterator that iterates through the values\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let i = 0; i < this.array.length; i += 2) {\n            yield this.array[i];\n        }\n    }\n\n    /**\n     * Update values in a given range\n     *\n     * @param min - The start of the range, inclusive\n     * @param max - The end of the range, exclusive\n     * @param transform - The callback function doing the updating\n     */\n    update(min: number, max: number, transform: (value: T, index: number) => T): void {\n        // Sanitize range\n        if (min >= max) {\n            return;\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min *= 2;\n        max *= 2;\n\n        // For each new value in range\n        let value: T;\n        do {\n            // Update the value\n            value = transform(this.array[min], min >>> 1);\n            this.array[min++] = value;\n\n            // Update aggregation nodes\n            for (let mask = 2; min & mask; mask *= 2) {\n                value = this.combine(this.array[min - mask - (mask >>> 1)], value);\n                this.array[min - mask] = value;\n            }\n        } while (++min < max);\n\n        // Update remaining aggregation nodes\n        let dc = 0;\n        let dp = lsp(min);\n        max = msb(min ^ this.array.length) - lsb(min);\n        for (--min; max > 0; --max) {\n            value = this.combine(value, this.array[min + (dp >>> 1) - dc]);\n            this.array[min] = value;\n            dc = (min & (2 * dp)) >>> 0;\n            min += dp - dc;\n            dp *= 2;\n        }\n\n        // Update the incomplete aggregation node\n        this.array[min] = value;\n    }\n}\n","import { CombineFn } from '..';\nimport { lsp, msb, msp } from '../math/bits';\nimport { SegmentTree } from './segmentTree';\n\n/**\n * A {@link SegmentTree} with entries stored in level-order traversal.\n * Memory usage: n elements require between 2n-1 to 4(n-1)-1 entries\n */\nexport class LevelOrderSegmentTree<T> implements SegmentTree<T> {\n    /**\n     * The maximum number of elements that can be added.\n     *\n     * According to [ECMA-262](https://tc39.es/ecma262/#array-index):\n     *    0 <= array.length <= 2^32 - 1\n     *\n     * So since n elements require 2^⌊log2(2n)⌋ - 1 memory:\n     *    0 <= size <= 2^31\n     */\n    static readonly MAX_SIZE = 2147483648;\n\n    /**\n     * The internal array used to store elements and aggregation nodes\n     */\n    protected array: Array<T>;\n\n    /**\n     * The function used to aggregate elements\n     */\n    protected combine: CombineFn<T>;\n\n    /**\n     * The used length (size) of our internal array\n     */\n    protected length: number;\n\n    /**\n     * The start index for the lowest level\n     */\n    protected level: number;\n\n    /**\n     * Construct a new {@link SegmentTree}\n     *\n     * @param combinFn - The function used to aggregate elements\n     * @param values - Initial elements to build into the tree\n     */\n    constructor(combine: CombineFn<T>, values: Iterable<T> = []) {\n        this.array = [];\n        this.combine = combine;\n        this.length = 0;\n        this.level = 0;\n        this.build(values);\n    }\n\n    protected build(values: Array<T> | Iterable<T>): void {\n        if (!('length' in values) || typeof values['length'] !== 'number') {\n            for (const value of values) {\n                this.push(value);\n            }\n            return;\n        }\n\n        const n = values['length'];\n\n        // Check for base case\n        if (n < 1) {\n            this.array = [];\n            this.length = 0;\n            this.level = 0;\n            return;\n        }\n\n        // Check if max capacity reached\n        if (n >= LevelOrderSegmentTree.MAX_SIZE) {\n            throw new RangeError(`Invalid SegmentTree length`);\n        }\n\n        // Allocate the array\n        this.level = 2 * msp(n - 1) - 1;\n        this.length = this.level + n;\n        this.array = new Array(2 * this.level + 1);\n\n        // Build the tree\n        const it = values[Symbol.iterator]();\n        this.update(0, n, (_) => it.next().value);\n    }\n\n    /**\n     * Shift the tree down a level\n     */\n    protected grow(): void {\n        // Check if max capacity reached\n        if (this.size >= LevelOrderSegmentTree.MAX_SIZE) {\n            throw new RangeError(`Invalid SegmentTree length`);\n        }\n\n        // Extend capacity\n        this.array.length += this.array.length + 1;\n\n        // Shift the tree down a level\n        let min = this.level + 1;\n        for (let max = this.length + 1; min < max; max >>>= 1) {\n            this.array.copyWithin(2 * min - 1, min - 1, max - 1);\n            min >>>= 1;\n        }\n\n        // Update pointers\n        this.length += this.level + 1;\n        this.level += this.level + 1;\n    }\n\n    /**\n     * Shift the tree up a level\n     */\n    protected shrink(): void {\n        // Get the tree's Lowest Common Ancestor (root)\n        let min = this.level + 1;\n        let max = msb(min ^ this.length) + 1;\n        min >>>= max;\n\n        // Shift the tree up a level\n        ++this.level;\n        if (min > 0) {\n            for (max = min + 1; min <= this.level; max *= 2) {\n                this.array.copyWithin((min >>> 1) - 1, min - 1, max - 1);\n                min *= 2;\n            }\n        }\n\n        // Update pointers and capacity\n        this.level -= (this.level >>> 1) + 1;\n        this.length -= (this.length + 1) >>> 1;\n        this.array.length = this.length - this.level + this.length;\n    }\n\n    /**\n     * Remove all elements\n     */\n    clear(): void {\n        this.length = 0;\n        this.level = 0;\n        this.array.length = 0;\n    }\n\n    /**\n     * Remove the last added value\n     *\n     * @returns The last added value or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        // Sanitize range\n        if (this.length <= this.level) {\n            return undefined;\n        }\n\n        // Remove value\n        const out = this.array[--this.length];\n\n        // If level is >= 3/4 empty\n        if (this.length < 0.625 * (this.array.length + 1)) {\n            this.shrink();\n        }\n\n        return out;\n    }\n\n    /**\n     * Insert the given value into the end of the tree\n     *\n     * @param value - The value to be inserted\n     */\n    push(value: T): void {\n        // If array is full\n        if (this.length >= this.array.length) {\n            this.grow();\n        }\n\n        // Add the new value\n        this.array[this.length++] = value;\n\n        // Update aggregation nodes\n        for (let i = this.length; i & 1; this.array[i - 1] = value) {\n            value = this.combine(this.array[i - 2], value);\n            i >>>= 1;\n        }\n    }\n\n    /**\n     * Get the aggregated information for values in a given range\n     *\n     * @param min - The start of the range, inclusive\n     * @param max - The end of the range, exclusive\n     *\n     * @returns The aggregated information for values in range [min, max)\n     */\n    query(min: number, max: number): T {\n        // Sanitize range\n        if (min >= max) {\n            throw new RangeError(`Range [${min}..${max}) is empty`);\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices and align with powers of 2\n        min += this.level + 1;\n        max += this.level + 1;\n\n        // Take the longest possible jump from min\n        let offset = lsp(min | msp(max - min));\n        let value: T = this.array[min / offset - 1];\n        min += offset;\n\n        // Continue jumping until max\n        while (min < max) {\n            offset = lsp(min | msp(max - min));\n            value = this.combine(value, this.array[min / offset - 1]);\n            min += offset;\n        }\n\n        return value;\n    }\n\n    /**\n     * The number of values in the tree\n     *    0 <= size <= {@link MAX_SIZE}\n     */\n    get size(): number {\n        return this.length - this.level;\n    }\n\n    /**\n     * Return an iterator that iterates through the values\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let i = 0; i < this.size; ++i) {\n            yield this.array[this.level + i];\n        }\n    }\n\n    /**\n     * Update values in a given range\n     *\n     * @param min - The start of the range, inclusive\n     * @param max - The end of the range, exclusive\n     * @param transform - The callback function doing the updating\n     */\n    update(min: number, max: number, transform: (value: T, index: number) => T): void {\n        // Sanitize range\n        if (min >= max) {\n            return;\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min += this.level;\n        max += this.level;\n\n        // Update the range\n        for (let i = min; i < max; ++i) {\n            this.array[i] = transform(this.array[i], i - this.level);\n        }\n\n        // Update the range's aggregation nodes\n        ++min;\n        ++max;\n        for (let cap = this.length + 1; min < max; cap >>>= 1) {\n            max += max & ((max - cap) >>> 31);\n            for (let i = (min | 1) >>> 0; i < max; i += 2) {\n                this.array[(i >>> 1) - 1] = this.combine(this.array[i - 2], this.array[i - 1]);\n            }\n            min >>>= 1;\n            max >>>= 1;\n        }\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}