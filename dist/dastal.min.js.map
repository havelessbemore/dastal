{"version":3,"sources":["webpack://Dastal/webpack/universalModuleDefinition","webpack://Dastal/./src/math/bits.ts","webpack://Dastal/./src/segmentTree/inOrderSegmentTree.ts","webpack://Dastal/./src/segmentTree/levelOrderSegmentTree.ts","webpack://Dastal/webpack/bootstrap","webpack://Dastal/webpack/runtime/compat get default export","webpack://Dastal/webpack/runtime/define property getters","webpack://Dastal/webpack/runtime/hasOwnProperty shorthand","webpack://Dastal/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","self","lsb","a","b","lsp","msb","msp","Symbol","iterator","InOrderSegmentTree","combine","elements","this","array","build","element","push","length","size","i","mask","out","MAX_SIZE","RangeError","min","max","offset","value","transform","dc","dp","LevelOrderSegmentTree","level","key","n","it","update","_","next","copyWithin","shrink","grow","cap","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","getter","__esModule","d","definition","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","toStringTag"],"mappings":"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","file":"dastal.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Dastal\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Dastal\"] = factory();\n\telse\n\t\troot[\"Dastal\"] = factory();\n})(self, function() {\nreturn ","/**\n * Get the Least Significant Bit of a number\n *\n * @param a\n *\n * @returns The lowest bit set\n */\nexport function lsb(a: number): number {\n    let b = -1;\n    for (a = lsp(a); a !== 0; a >>>= 1) {\n        ++b;\n    }\n    return b;\n}\n\n/**\n * Get the Least Significant Power of a number\n *\n * @param a\n *\n * @returns 2**lsb(a)\n */\nexport function lsp(a: number): number {\n    return (a & -a) >>> 0;\n}\n\n/**\n * Get the Most Significant Bit of a number\n *\n * @param a\n *\n * @returns ⌊log2(a)⌋ : the highest bit set\n */\nexport function msb(a: number): number {\n    let b = -1;\n    while (a !== 0) {\n        ++b;\n        a >>>= 1;\n    }\n    return b;\n}\n\n/**\n * Get the Most Significant Power of a number\n *\n * @param a\n *\n * @returns 2**msb(a)\n */\nexport function msp(a: number): number {\n    for (let b = a & -a; a !== b; b = a & -a) {\n        a ^= b;\n    }\n    return a >>> 0;\n}\n","import { lsb, lsp, msb, msp } from 'src/math/bits';\nimport { SegmentTree } from './segmentTree';\nimport { CombineFn } from '..';\n\n/**\n * A {@link SegmentTree} with entries stored in in-order traversal.\n * Inspired by [Tristan Hume's IForestIndex](https://thume.ca/2021/03/14/iforests) ([github](https://github.com/trishume/gigatrace))\n */\nexport class InOrderSegmentTree<T> implements SegmentTree<T> {\n    /**\n     * The maximum amount of elements that can be added.\n     *\n     * According to [ECMA-262](https://tc39.es/ecma262/#array-index):\n     *     0 <= array.length <= 2^32 - 1\n     *\n     * Because n elements require 2n memory:\n     *     0 <= size <= 2^31 - 1\n     */\n    static readonly MAX_SIZE: number = 2147483647;\n\n    /**\n     * The internal array used to store elements and aggregation nodes\n     */\n    protected array: Array<T>;\n\n    /**\n     * The function used to aggregate elements\n     */\n    protected combine: CombineFn<T>;\n\n    /**\n     * Construct a new {@link InOrderSegmentTree}\n     *\n     * @param combine - The function used to aggregate segment information\n     * @param elements - A set of elements to add into the initial tree\n     */\n    constructor(combine: CombineFn<T>, elements: Iterable<T> = []) {\n        this.array = [];\n        this.combine = combine;\n        this.build(elements);\n    }\n\n    /**\n     * A helper method used to build the tree\n     *\n     * @param elements The initial set of elements to add into the tree\n     */\n    protected build(elements: Iterable<T>) {\n        for (const element of elements) {\n            this.push(element);\n        }\n    }\n\n    /**\n     * Remove all elements\n     */\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    /**\n     * Remove the last added element\n     *\n     * @returns The last added element or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        // Sanitize range\n        if (this.size < 1) {\n            return undefined;\n        }\n\n        // Un-complete aggregation nodes\n        const i = this.array.length - 1;\n        for (let mask = 2; i & mask; mask *= 2) {\n            this.array[i - mask] = this.array[i - mask - (mask >>> 1)];\n        }\n\n        // Return element\n        const out = this.array[i - 1];\n        this.array.length -= 2;\n        return out;\n    }\n\n    /**\n     * Insert the given element into the end of the tree\n     *\n     * @param element - The element to be inserted\n     *\n     */\n    push(element: T): void {\n        // Sanitize range\n        if (this.size >= InOrderSegmentTree.MAX_SIZE) {\n            throw new RangeError(`Invalid SegmentTree length`);\n        }\n\n        // Add the new element\n        this.array.push(element);\n\n        // Complete aggregation nodes\n        const i = this.array.length;\n        for (let mask = 2; i & mask; mask *= 2) {\n            element = this.combine(this.array[i - mask], element);\n            this.array[i - mask] = element;\n        }\n\n        // Push new aggregation node\n        this.array.push(element);\n    }\n\n    /**\n     * Get the aggregated information for elements in a given range\n     *\n     * @param min - The start of the range, inclusive\n     * @param max - The end of the range, exclusive\n     *\n     * @returns The aggregated information for elements in range [min, max)\n     */\n    query(min: number, max: number): T {\n        // Sanitize range\n        if (min >= max) {\n            throw new RangeError(`Range [${min}..${max}) is empty`);\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min *= 2;\n        max *= 2;\n\n        // Take the longest possible jump from min\n        let offset = lsp(min | msp(max - min));\n        let value = this.array[min - 1 + (offset >>> 1)];\n        min += offset;\n\n        // Continue jumping until max\n        while (min < max) {\n            offset = lsp(min | msp(max - min));\n            value = this.combine(value, this.array[min - 1 + (offset >>> 1)]);\n            min += offset;\n        }\n\n        return value;\n    }\n\n    /**\n     * The number of elements in the tree:\n     *     0 <= size <= {@link MAX_SIZE}\n     */\n    get size(): number {\n        return this.array.length >>> 1;\n    }\n\n    /**\n     * Return an iterator through the tree's elements\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let i = 0; i < this.array.length; i += 2) {\n            yield this.array[i];\n        }\n    }\n\n    /**\n     * Update elements in a given range\n     *\n     * @param min - The start of the range, inclusive\n     * @param max - The end of the range, exclusive\n     * @param transform - The callback function doing the updating\n     */\n    update(min: number, max: number, transform: (element: T, index: number) => T): void {\n        // Sanitize range\n        if (min >= max) {\n            return;\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min *= 2;\n        max *= 2;\n\n        // For each new value in range\n        let value: T;\n        do {\n            // Update the value\n            value = transform(this.array[min], min >>> 1);\n            this.array[min++] = value;\n\n            // Update aggregation nodes\n            for (let mask = 2; min & mask; mask *= 2) {\n                value = this.combine(this.array[min - mask - (mask >>> 1)], value);\n                this.array[min - mask] = value;\n            }\n        } while (++min < max);\n\n        // Update remaining aggregation nodes\n        let dc = 0;\n        let dp = lsp(min);\n        max = msb(min ^ this.array.length) - lsb(min);\n        for (--min; max > 0; --max) {\n            value = this.combine(value, this.array[min + (dp >>> 1) - dc]);\n            this.array[min] = value;\n            dc = (min & (2 * dp)) >>> 0;\n            min += dp - dc;\n            dp *= 2;\n        }\n\n        // Update the incomplete aggregation node\n        this.array[min] = value;\n    }\n}\n","import { CombineFn } from '..';\nimport { lsp, msb, msp } from '../math/bits';\nimport { SegmentTree } from './segmentTree';\n\n/**\n * A {@link SegmentTree} with entries stored in level-order traversal.\n * Memory usage: n elements require between 2n-1 to 4(n-1)-1 entries\n */\nexport class LevelOrderSegmentTree<T> implements SegmentTree<T> {\n    /**\n     * The maximum number of elements that can be added.\n     *\n     * According to [ECMA-262](https://tc39.es/ecma262/#array-index):\n     *     0 <= array.length <= 2^32 - 1\n     *\n     * So since n elements require 2^⌊log2(2n)⌋ - 1 memory:\n     *     0 <= size <= 2^31\n     */\n    static readonly MAX_SIZE: number = 2147483648;\n\n    /**\n     * The internal array used to store elements and aggregation nodes\n     */\n    protected array: Array<T>;\n\n    /**\n     * The function used to aggregate elements\n     */\n    protected combine: CombineFn<T>;\n\n    /**\n     * The used length (size) of our internal array\n     */\n    protected length: number;\n\n    /**\n     * The start index for the lowest level\n     */\n    protected level: number;\n\n    /**\n     * Construct a new {@link SegmentTree}\n     *\n     * @param combinFn - The function used to aggregate elements\n     * @param elements - Initial elements to build into the tree\n     */\n    constructor(combine: CombineFn<T>, elements: Iterable<T> = []) {\n        this.array = [];\n        this.combine = combine;\n        this.length = 0;\n        this.level = 0;\n        this.build(elements);\n    }\n\n    /**\n     * A helper method used to build the tree\n     *\n     * @param elements The initial set of elements to add into the tree\n     */\n    protected build(elements: Iterable<T>): void {\n        let key = '';\n\n        // Check if the iterable's size can be known.\n        // For example: array.length or map.size\n        if ('length' in elements && typeof elements['length'] !== 'number') {\n            key = 'length';\n        } else if ('size' in elements && typeof elements['size'] !== 'number') {\n            key = 'size';\n        }\n\n        // Iterate normally if size is not given\n        if (key.length < 1) {\n            for (const element of elements) {\n                this.push(element);\n            }\n            return;\n        }\n\n        // Get the iterable's size\n        const n = (elements as any)[key];\n\n        // Check for base case\n        if (n < 1) {\n            this.array.length = 0;\n            this.length = 0;\n            this.level = 0;\n            return;\n        }\n\n        // Check if max capacity reached\n        if (n >= LevelOrderSegmentTree.MAX_SIZE) {\n            throw new RangeError(`Invalid SegmentTree length`);\n        }\n\n        // Allocate the array\n        this.level = 2 * msp(n - 1) - 1;\n        this.length = this.level + n;\n        this.array.length = 2 * this.level + 1;\n\n        // Build the tree\n        const it = elements[Symbol.iterator]();\n        this.update(0, n, (_) => it.next().value);\n    }\n\n    /**\n     * Shift the tree down a level\n     */\n    protected grow(): void {\n        // Check if max capacity reached\n        if (this.size >= LevelOrderSegmentTree.MAX_SIZE) {\n            throw new RangeError(`Invalid SegmentTree length`);\n        }\n\n        // Extend capacity\n        this.array.length += this.array.length + 1;\n\n        // Shift the tree down a level\n        let min = this.level + 1;\n        for (let max = this.length + 1; min < max; max >>>= 1) {\n            this.array.copyWithin(2 * min - 1, min - 1, max - 1);\n            min >>>= 1;\n        }\n\n        // Update pointers\n        this.length += this.level + 1;\n        this.level += this.level + 1;\n    }\n\n    /**\n     * Shift the tree up a level\n     */\n    protected shrink(): void {\n        // Get the tree's Lowest Common Ancestor (root)\n        let min = this.level + 1;\n        let max = msb(min ^ this.length) + 1;\n        min >>>= max;\n\n        // Shift the tree up a level\n        ++this.level;\n        if (min > 0) {\n            for (max = min + 1; min <= this.level; max *= 2) {\n                this.array.copyWithin((min >>> 1) - 1, min - 1, max - 1);\n                min *= 2;\n            }\n        }\n\n        // Update pointers and capacity\n        this.level -= (this.level >>> 1) + 1;\n        this.length -= (this.length + 1) >>> 1;\n        this.array.length = this.length - this.level + this.length;\n    }\n\n    /**\n     * Remove all elements\n     */\n    clear(): void {\n        this.length = 0;\n        this.level = 0;\n        this.array.length = 0;\n    }\n\n    /**\n     * Remove the last added element\n     *\n     * @returns The last added element or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        // Sanitize range\n        if (this.length <= this.level) {\n            return undefined;\n        }\n\n        // Remove element\n        const out = this.array[--this.length];\n\n        // If level is <= 1/4 full\n        if (this.length < 0.625 * (this.array.length + 1)) {\n            this.shrink();\n        }\n\n        return out;\n    }\n\n    /**\n     * Insert the given element into the end of the tree\n     *\n     * @param element - The element to be inserted\n     */\n    push(element: T): void {\n        // If array is full\n        if (this.length >= this.array.length) {\n            this.grow();\n        }\n\n        // Add the new element\n        this.array[this.length++] = element;\n\n        // Update aggregation nodes\n        for (let i = this.length; i & 1; this.array[i - 1] = element) {\n            element = this.combine(this.array[i - 2], element);\n            i >>>= 1;\n        }\n    }\n\n    /**\n     * Get the aggregated information for elements in a given range\n     *\n     * @param min - The start of the range, inclusive\n     * @param max - The end of the range, exclusive\n     *\n     * @returns The aggregated information for elements in range [min, max)\n     */\n    query(min: number, max: number): T {\n        // Sanitize range\n        if (min >= max) {\n            throw new RangeError(`Range [${min}..${max}) is empty`);\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices and align with powers of 2\n        min += this.level + 1;\n        max += this.level + 1;\n\n        // Take the longest possible jump from min\n        let offset = lsp(min | msp(max - min));\n        let value: T = this.array[min / offset - 1];\n        min += offset;\n\n        // Continue jumping until max\n        while (min < max) {\n            offset = lsp(min | msp(max - min));\n            value = this.combine(value, this.array[min / offset - 1]);\n            min += offset;\n        }\n\n        return value;\n    }\n\n    /**\n     * The number of elements in the tree:\n     *     0 <= size <= {@link MAX_SIZE}\n     */\n    get size(): number {\n        return this.length - this.level;\n    }\n\n    /**\n     * Return an iterator through the elements\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let i = 0; i < this.size; ++i) {\n            yield this.array[this.level + i];\n        }\n    }\n\n    /**\n     * Update elements in a given range\n     *\n     * @param min - The start of the range, inclusive\n     * @param max - The end of the range, exclusive\n     * @param transform - The callback function doing the updating\n     */\n    update(min: number, max: number, transform: (element: T, index: number) => T): void {\n        // Sanitize range\n        if (min >= max) {\n            return;\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min += this.level;\n        max += this.level;\n\n        // Update the range\n        for (let i = min; i < max; ++i) {\n            this.array[i] = transform(this.array[i], i - this.level);\n        }\n\n        // Update the range's aggregation nodes\n        ++min;\n        ++max;\n        for (let cap = this.length + 1; min < max; cap >>>= 1) {\n            max += max & ((max - cap) >>> 31);\n            for (let i = (min | 1) >>> 0; i < max; i += 2) {\n                this.array[(i >>> 1) - 1] = this.combine(this.array[i - 2], this.array[i - 1]);\n            }\n            min >>>= 1;\n            max >>>= 1;\n        }\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}