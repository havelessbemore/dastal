{"version":3,"sources":["webpack://Dastal/webpack/universalModuleDefinition","webpack://Dastal/./src/array/utils.ts","webpack://Dastal/./src/heap/binaryHeap.ts","webpack://Dastal/./src/heap/skewHeap.ts","webpack://Dastal/./src/heap/utils.ts","webpack://Dastal/./src/list/arrayList.ts","webpack://Dastal/./src/list/doublyLinkedList.ts","webpack://Dastal/./src/list/linkedList.ts","webpack://Dastal/./src/list/utils.ts","webpack://Dastal/./src/queue/arrayQueue.ts","webpack://Dastal/./src/queue/linkedQueue.ts","webpack://Dastal/./src/stack/arrayStack.ts","webpack://Dastal/./src/stack/linkedStack.ts","webpack://Dastal/./src/tree/aaTreeUtils.ts","webpack://Dastal/./src/tree/aaTree.ts","webpack://Dastal/./src/tree/avlTreeUtils.ts","webpack://Dastal/./src/tree/avlTree.ts","webpack://Dastal/./src/tree/binaryTreeUtils.ts","webpack://Dastal/webpack/bootstrap","webpack://Dastal/webpack/runtime/compat get default export","webpack://Dastal/webpack/runtime/define property getters","webpack://Dastal/webpack/runtime/hasOwnProperty shorthand","webpack://Dastal/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","self","MAX_ARRAY_LENGTH","isArray","obj","Array","isTypedArray","TypedArray","Object","getPrototypeOf","Uint8Array","Symbol","iterator","BinaryHeap","compareFn","elements","this","compare","array","addAll","length","RangeError","i","push","element","heapify","indexOf","index","last","pop","sinkDown","bubbleUp","heap","size","undefined","value","a","b","curElement","newElement","SkewHeap","merge","preOrderTraverse","par","key","left","right","node","skewMerge","comparator","clone","toBinaryTree","out","parentIndex","Math","floor","parent","n","childIndex","child","heaps","lists","list","tree","next","tail","mergeKSorted","ArrayList","from","splice","batch","items","min","max","cwrap","copyWithin","fill","callback","temp","prev","shift","slice","start","count","clamp","sort","unshift","arguments","len","DoublyLinkedList","_addAll","_get","nodeA","nodeB","head","view","mergeSort","LinkedList","_copyWithin","nodeC","nodeD","remove","deleted","newTail","add","to","batchArray","batchIterable","iterable","f","num","pivot","wrap","isDoubly","lens","ceil","heads","tails","mergeSorted","ArrayQueue","LinkedQueue","clear","get","ArrayStack","LinkedStack","insert","level","split","skew","found","comparison","chi","AATree","build","res","inOrderTraverse","delete","balance","bf","balanceFactor","rotateR","rotateL","height","stack","edge","successor","label","P","R","L","AVLTree","allowDuplicates","dupeWeight","search","removed","rightmost","leftmost","assign","paths","comp","nodes","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","d","definition","o","defineProperty","enumerable","prop","prototype","hasOwnProperty","call","r","toStringTag"],"mappings":"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","file":"dastal.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Dastal\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Dastal\"] = factory();\n\telse\n\t\troot[\"Dastal\"] = factory();\n})(self, function() {\nreturn ","/**\n * The maximum length of an array.\n *\n * According to [ECMA-262](https://tc39.es/ecma262/#array-index):\n *     0 <= array.length <= 2^32 - 1\n */\nexport const MAX_ARRAY_LENGTH = 4294967295;\n/**\n * Check if a value is an Array or TypedArray.\n *\n * @param obj - The value to check.\n *\n * @returns `true` if an Array or TypedArray, otherwise `false`.\n */\nexport function isArray<T = any>(obj: unknown): obj is T[] {\n    return obj instanceof Array || isTypedArray(obj);\n}\n/**\n * Check if a value is a TypedArray.\n *\n * See [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)\n * for more details.\n *\n * @param obj - The value to check.\n *\n * @returns `true` if a TypedArray, otherwise `false`.\n */\nexport const isTypedArray = (() => {\n    const TypedArray = Object.getPrototypeOf(Uint8Array);\n    return function isTypedArray<T = any>(obj: unknown): obj is T[] {\n        return obj instanceof TypedArray;\n    };\n})();\n","import { isArray, MAX_ARRAY_LENGTH } from 'src/array/utils';\nimport { CompareFn } from '..';\nimport { Heap } from './heap';\nimport { bubbleUp, heapify, sinkDown } from './utils';\n\n/**\n * A binary heap is a heap implemented as a binary tree with an additional shape property\n * ([source](https://en.wikipedia.org/wiki/Binary_heap)).\n *\n * **Shape property**: Must be a complete binary tree. This means all levels of the tree\n * (except possibly the last one) are fully filled. If the last level of the tree is incomplete,\n * the nodes of that level are filled from left to right.\n *\n * #### Complexity\n *\n * | Property | Average | Worst |\n * | :------- | :------ | :---- |\n * | Space    | O(n)    | O(n)\n * | Push     | O(1)    | O(log n)\n * | Peek     | O(1)\t| O(1)\n * | Pop      | O(log n)| O(log n)\n * | Search   | O(n)    | O(n)\n */\nexport class BinaryHeap<T> implements Heap<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * Instantiate a heap.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>) {\n        this.compare = compareFn;\n        this.array = [];\n        this.addAll(elements ?? []);\n    }\n\n    addAll(elements: Iterable<T>): number {\n        const array = this.array;\n        const length = array.length;\n\n        if (isArray(elements)) {\n            if (array.length + elements.length > MAX_ARRAY_LENGTH) {\n                throw new RangeError('Invalid heap length');\n            }\n            for (let i = 0; i < elements.length; ++i) {\n                array.push(elements[i]);\n            }\n        } else {\n            for (const element of elements) {\n                if (array.length >= MAX_ARRAY_LENGTH) {\n                    throw new RangeError('Invalid heap length');\n                }\n                array.push(element);\n            }\n        }\n\n        // Update the heap\n        if (length < array.length) {\n            heapify(this.compare, array);\n        }\n\n        return array.length;\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        return this.array.indexOf(element) >= 0;\n    }\n\n    delete(element: T): boolean {\n        const index = this.array.indexOf(element);\n        if (index < 0) {\n            return false;\n        }\n\n        // If deleting the last value\n        const last = this.array.pop()!;\n        if (index >= this.array.length) {\n            return true;\n        }\n\n        // Add the last value to the\n        // deleted index and update the heap\n        this.array[index] = last;\n        sinkDown(index, this.compare, this.array);\n        bubbleUp(index, this.compare, this.array);\n        return true;\n    }\n\n    merge(heap: Heap<T>): this {\n        const array = this.array;\n\n        if (heap.size < 1) {\n            return this;\n        }\n\n        if (array.length + heap.size > MAX_ARRAY_LENGTH) {\n            throw new RangeError('Invalid heap length');\n        }\n\n        for (const element of heap) {\n            array.push(element);\n        }\n\n        heapify(this.compare, array);\n        return this;\n    }\n\n    peek(): T | undefined {\n        return this.array.length > 0 ? this.array[0] : undefined;\n    }\n\n    pop(): T | undefined {\n        if (this.array.length < 1) {\n            return undefined;\n        }\n\n        // Get the root and the last value\n        const value = this.array[0];\n        const last = this.array.pop();\n\n        // If value != last\n        if (this.array.length > 0) {\n            // Move the last value to the root and update the heap\n            this.array[0] = last!;\n            sinkDown(0, this.compare, this.array);\n        }\n\n        return value;\n    }\n\n    push(value: T): number {\n        // Add new value to the end of the heap\n        this.array.push(value);\n\n        // Update the heap\n        bubbleUp(this.array.length - 1, this.compare, this.array);\n        return this.size;\n    }\n\n    pushPop(value: T): T {\n        // If empty or value is <= to root\n        if (this.array.length < 1 || this.compare(value, this.array[0]) <= 0) {\n            return value;\n        }\n\n        // Swap the root and value\n        const root = this.array[0];\n        this.array[0] = value;\n        sinkDown(0, this.compare, this.array);\n        return root;\n    }\n\n    replace(value: T): T | undefined {\n        // If empty\n        if (this.array.length < 1) {\n            this.array.push(value);\n            return undefined;\n        }\n\n        // Swap the root with value\n        const root = this.array[0];\n        this.array[0] = value;\n        value = root;\n\n        // Update the heap\n        sinkDown(0, this.compare, this.array);\n        return value;\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    *sorted(): Iterable<T> {\n        if (this.array.length < 1) {\n            return;\n        }\n        const array = this.array;\n        const heap = new BinaryHeap<number>((a, b) => this.compare(array[a], array[b]), [0]);\n        do {\n            let index = heap.pop()!;\n            if (index < array.length) {\n                yield array[index];\n                index = 2 * index + 1;\n                index < array.length && heap.push(index);\n                ++index < array.length && heap.push(index);\n            }\n        } while (heap.size > 0);\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        const index = this.array.indexOf(curElement);\n        if (index < 0) {\n            return false;\n        }\n        this.array[index] = newElement;\n        sinkDown(index, this.compare, this.array);\n        bubbleUp(index, this.compare, this.array);\n        return true;\n    }\n}\n","import { isArray } from 'src/array/utils';\nimport { BinaryTreeNode } from 'src/tree/binaryTreeNode';\nimport { clone, preOrderTraverse, toBinaryTree } from 'src/tree/binaryTreeUtils';\nimport { CompareFn } from '..';\nimport { BinaryHeap } from './binaryHeap';\nimport { Heap } from './heap';\nimport { skewMerge } from './utils';\n\n/**\n * A skew heap is a heap implemented as a binary tree\n * ([source](https://en.wikipedia.org/wiki/Skew_heap)).\n *\n * A skew heap is a self-adjusting heap which attempts to maintain balance\n * by unconditionally swapping all nodes in the merge path when merging two heaps. Every\n * operation that modifies the heap (e.g. push, pop, merge) is considered a merge and is done\n * by using a skew heap merge.\n *\n * Skew heaps can merge more quickly than binary heaps. This can seem contradictory, since\n * skew heaps have no structural constraints and no guarantee that the height of the tree is\n * logarithmic (i.e. balanced). However, amortized complexity analysis can demonstrate that\n * all operations on a skew heap can be done in O(log(n). More specifically, the\n * amortized complexity is known to be log<sub>φ</sub>(n) where φ is the golden ratio. This is\n * approximately 1.44*log<sub>2</sub>(n).\n *\n * #### Complexity\n *\n * | Property | Average  | Worst |\n * | :------- | :------  | :---- |\n * | Space    | O(n)     | O(n)\n * | Push     | O(log n) | O(log n)\n * | Peek     | O(1)\t | O(1)\n * | Pop      | O(log n) | O(log n)\n * | Search   | O(n)     | O(n)\n */\nexport class SkewHeap<T> implements Heap<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The node at the \"top\" of the heap.\n     */\n    protected root: BinaryTreeNode<T> | undefined;\n    /**\n     * Instantiate a heap.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the heap with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>) {\n        this.compare = compareFn;\n        this.length = 0;\n        this.addAll(elements ?? []);\n    }\n\n    addAll(elements: Iterable<T>): number {\n        if (isArray(elements)) {\n            for (let i = 0; i < elements.length; ++i) {\n                this.push(elements[i]);\n            }\n        } else if (elements instanceof SkewHeap || elements instanceof BinaryHeap) {\n            this.merge(elements);\n        } else {\n            for (const element of elements) {\n                this.push(element);\n            }\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.root = undefined;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        for (const node of preOrderTraverse(this.root)) {\n            if (element === node.value) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    delete(element: T): boolean {\n        if (this.root == null) {\n            return false;\n        }\n        if (this.root.value === element) {\n            this.pop()!;\n            return true;\n        }\n        for (const par of preOrderTraverse(this.root)) {\n            const key: keyof BinaryTreeNode<T> | undefined =\n                par.left && par.left.value === element\n                    ? 'left'\n                    : par.right && par.right.value === element\n                    ? 'right'\n                    : undefined;\n            if (key != null) {\n                const node = par[key]!;\n                par[key] = skewMerge(this.compare, [node.left, node.right]);\n                --this.length;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    merge(heap: Heap<T>): this {\n        if (this.compare !== heap.comparator()) {\n            this.addAll(heap);\n        } else if (heap instanceof SkewHeap) {\n            this.root = skewMerge(this.compare, [this.root, clone(heap.root)]);\n            this.length += heap.size;\n        } else if (heap instanceof BinaryHeap) {\n            this.root = skewMerge(this.compare, [this.root, toBinaryTree(heap['array'])!]);\n            this.length += heap.size;\n        } else {\n            this.addAll(heap);\n        }\n        return this;\n    }\n\n    peek(): T | undefined {\n        return this.root?.value;\n    }\n\n    pop(): T | undefined {\n        if (this.root == null) {\n            return undefined;\n        }\n        const value = this.root.value;\n        this.root = skewMerge(this.compare, [this.root.left, this.root.right]);\n        --this.length;\n        return value;\n    }\n\n    push(value: T): number {\n        this.root = skewMerge(this.compare, [this.root, { value }]);\n        return ++this.length;\n    }\n\n    pushPop(value: T): T {\n        this.push(value);\n        return this.pop()!;\n    }\n\n    replace(value: T): T | undefined {\n        if (this.root == null) {\n            this.root = { value };\n            this.length = 1;\n            return undefined;\n        }\n        const out = this.root.value;\n        this.root = skewMerge(this.compare, [this.root.left, this.root.right, { value }]);\n        return out;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        if (this.root == null) {\n            return;\n        }\n        const heap = new SkewHeap<BinaryTreeNode<T>>(\n            (a, b) => this.compare(a.value, b.value),\n            [this.root],\n        );\n        do {\n            const node = heap.pop()!;\n            yield node.value;\n            node.left && heap.push(node.left);\n            node.right && heap.push(node.right);\n        } while (heap.size > 0);\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.root == null) {\n            return false;\n        }\n\n        if (this.root.value === curElement) {\n            this.root = skewMerge(this.compare, [\n                this.root.left,\n                this.root.right,\n                { value: newElement },\n            ]);\n            return true;\n        }\n\n        let node: BinaryTreeNode<T> | undefined = undefined;\n        for (const par of preOrderTraverse(this.root)) {\n            if (par.left && par.left.value === curElement) {\n                node = par.left;\n                par.left = undefined;\n                break;\n            }\n            if (par.right && par.right.value === curElement) {\n                node = par.right;\n                par.right = undefined;\n                break;\n            }\n        }\n\n        if (node == null) {\n            return false;\n        }\n\n        this.root = skewMerge(this.compare, [\n            this.root,\n            node.left,\n            node.right,\n            { value: newElement },\n        ]);\n        return true;\n    }\n}\n","import { LinkedNode } from 'src/list';\nimport { BinaryTreeNode } from 'src/tree/binaryTreeNode';\nimport { CompareFn } from '..';\n\n/**\n * @internal\n */\nexport function bubbleUp<T>(index: number, compareFn: CompareFn<T>, array: Array<T>): void {\n    const value = array[index];\n\n    // Until we reach the top of the heap\n    while (index > 0) {\n        // Get the parent\n        const parentIndex = Math.floor((index + 1) / 2) - 1;\n        const parent = array[parentIndex]!;\n\n        // If the parent is above or equal to value, the heap is in order\n        if (compareFn(parent, value) <= 0) {\n            break;\n        }\n\n        // Swap the parent with value and continue\n        array[parentIndex] = value;\n        array[index] = parent;\n        index = parentIndex;\n    }\n}\n/**\n * @internal\n */\nexport function heapify<T>(compareFn: CompareFn<T>, array: T[]): void {\n    for (let i = (array.length + 1) >>> 1; i > 0; sinkDown(--i, compareFn, array)) {}\n}\n/**\n * @internal\n */\nexport function mergeKSorted<T>(compareFn: CompareFn<T>, lists: LinkedNode<T>[]): LinkedNode<T> {\n    // Heapify the list of lists based on\n    // the value at the head of each list.\n    const compare: CompareFn<LinkedNode<T>> = (a, b) => compareFn(a.value, b.value);\n    heapify(compare, lists);\n\n    // Combine the lists into a single list.\n    const list: LinkedNode<T> = lists[0];\n    for (let tail = list; lists.length > 1; tail = tail.next) {\n        lists[0] = lists[0].next ?? lists.pop()!;\n        sinkDown(0, compare, lists);\n        tail.next = lists[0];\n    }\n\n    return list;\n}\n/**\n * @internal\n */\nexport function sinkDown<T>(index: number, compareFn: CompareFn<T>, array: Array<T>): void {\n    const n = array.length;\n    const value = array[index];\n    do {\n        // Compute the left child's index\n        let childIndex = 2 * index + 1;\n\n        // If no children exist\n        if (childIndex >= n) {\n            break;\n        }\n\n        // Decide which child to compare with\n        let child = array[childIndex];\n        if (childIndex + 1 < n && compareFn(array[childIndex + 1], child) <= 0) {\n            child = array[++childIndex]!;\n        }\n\n        // If value <= child\n        if (compareFn(value, child) <= 0) {\n            break;\n        }\n\n        // Swap value and child\n        array[index] = child;\n        array[childIndex] = value;\n        index = childIndex;\n    } while (true);\n}\n/**\n * See: https://en.wikipedia.org/wiki/Skew_heap#Merging_two_heaps\n *\n * @param compareFn - A function used to determine the order of the heap.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n * @param heaps - An iterable of heaps to merge\n *\n * @returns The new heap\n */\nexport function skewMerge<T>(\n    compareFn: CompareFn<T>,\n    heaps: (BinaryTreeNode<T> | undefined)[],\n): BinaryTreeNode<T> | undefined {\n    // Remove undefineds and initialize a list for each heap\n    const lists: LinkedNode<BinaryTreeNode<T>>[] = [];\n    for (let i = 0; i < heaps.length; ++i) {\n        if (heaps[i] != null) {\n            lists.push({ value: heaps[i]! });\n        }\n    }\n\n    // Check if nothing to merge with\n    if (lists.length < 2) {\n        return lists[0]?.value;\n    }\n\n    // Split each heap into subheaps by cutting every right path; From the root\n    // node, sever the right node to make the right child its own heap. Repeat\n    // until you can't go right. This will turn each heap into a list of heaps\n    // where the root either only has a left child or no children at all. The\n    // lists of heaps will be in desc order (from bottom to top).\n    for (let i = 0; i < lists.length; ++i) {\n        let list = lists[i];\n        let tree: BinaryTreeNode<T> | undefined = list.value;\n        while ((tree = tree.right)) {\n            list = { next: list, value: tree };\n        }\n        lists[i] = list;\n    }\n\n    // Combine the lists into a single list in desc order\n    let list: LinkedNode<BinaryTreeNode<T>> | undefined = mergeKSorted(\n        (a, b) => compareFn(b.value, a.value),\n        lists,\n    );\n\n    // While there are still multiple heaps, iteratively combine\n    // the first two (from left to right). If the root of the second-to-first\n    // subtree has a left child, swap it to be the right child. Link the root\n    // of the last subtree as the left child of the second-to-first subtree.\n    let heap = list.value;\n    while ((list = list.next)) {\n        const node = list.value;\n        node.right = node.left;\n        node.left = heap;\n        heap = node;\n    }\n\n    return heap;\n}\n","import { CompareFn } from '..';\nimport { List } from './list';\nimport { batch, clamp, cwrap } from './utils';\n\n/**\n * An implementation of the {@link List} interface using an array\n */\nexport class ArrayList<T> implements List<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: Array<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    add(index: number, element: T): number {\n        if (index >= 0 && index <= this.size) {\n            this.array.splice(index, 0, element);\n        }\n        return this.size;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.size) {\n            for (const items of batch(10000, elements)) {\n                this.array.splice(index, 0, ...items);\n                index += items.length;\n            }\n        }\n        return this.size;\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    concat(...lists: Iterable<T>[]): ArrayList<T> {\n        const out = new ArrayList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        index = cwrap(index ?? 0, 0, this.size);\n        min = cwrap(min ?? 0, 0, this.size);\n        max = cwrap(max ?? this.size, 0, this.size);\n        this.array.copyWithin(index, min, max);\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.size);\n        max = cwrap(max ?? this.size, 0, this.size);\n        this.array.fill(element, min, max);\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array[index];\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        let value: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            value = this.array[index];\n            this.array[index] = callback(value);\n        }\n        return value;\n    }\n\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n\n    push(element: T): number {\n        return this.array.push(element);\n    }\n\n    remove(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array.splice(index, 1)[0];\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.size);\n        max = cwrap(max ?? this.size, 0, this.size) - 1;\n        while (min < max) {\n            const temp = this.array[min];\n            this.array[min++] = this.array[max];\n            this.array[max--] = temp;\n        }\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        let prev: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            prev = this.array[index];\n            this.array[index] = element;\n        }\n        return prev;\n    }\n\n    shift(): T | undefined {\n        return this.array.shift();\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    slice(min?: number, max?: number): ArrayList<T> {\n        return new ArrayList(this.array.slice(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = cwrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n        const list = new ArrayList(this.array.splice(start, count));\n        for (const items of batch(10000, elements ?? [])) {\n            this.array.splice(start, 0, ...items);\n            start += items.length;\n        }\n        return list;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        this.array.sort(compareFn);\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n\n    unshift(element: T): number {\n        return this.array.unshift(element);\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = cwrap((min as number) ?? 0, 0, this.size);\n        max = cwrap((max as number) ?? this.size, 0, this.size);\n        while (min < max) {\n            this.array[min] = callback(this.array[min], min);\n            ++min;\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = cwrap(min ?? 0, 0, this.size);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.size;\n        } else if (max >= 0) {\n            len = () => Math.min(max, this.size);\n        } else {\n            len = () => this.size + max;\n        }\n\n        while (min < len()) {\n            yield this.array[min++];\n        }\n    }\n}\n","import { CompareFn } from '..';\nimport { DoublyLinkedNode } from './doublyLinkedNode';\nimport { List } from './list';\nimport { clamp, mergeSort, cwrap } from './utils';\n\n/**\n * A (circular) doubly-linked list implementation of the {@link List} interface.\n *\n * Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.\n */\nexport class DoublyLinkedList<T> implements List<T> {\n    /**\n     * The number of elements in the list\n     */\n    protected length: number;\n    /**\n     * The sentinel node at the fron of the list\n     */\n    protected root: DoublyLinkedNode<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as DoublyLinkedNode<T>;\n        this.root.prev = this.root.next = this.root;\n        this._addAll(this.root, elements ?? []);\n    }\n\n    add(index: number, value: T): number {\n        if (index < 0 || index > this.length) {\n            return this.length;\n        }\n        const prev = this._get(index - 1);\n        const node = { next: prev.next, prev, value };\n        prev.next = node;\n        node.next!.prev = node;\n        return ++this.length;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.length) {\n            this._addAll(this._get(index), elements);\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.root.prev = this.root.next = this.root;\n    }\n\n    concat(...lists: Iterable<T>[]): DoublyLinkedList<T> {\n        const out = new DoublyLinkedList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to the same section\n        index = cwrap(index, 0, this.length);\n        min = cwrap(min ?? 0, 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = cwrap(max ?? this.length, 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Check for overlap edge case\n        if (min < index && index < max) {\n            let nodeA = this._get(max);\n            let nodeB = this._get(index + (max - min));\n            do {\n                nodeA = nodeA.prev!;\n                nodeB = nodeB.prev!;\n                nodeB.value = nodeA.value;\n            } while (++min < max);\n            return this;\n        }\n\n        // Copy the section to the destination\n        let nodeA = this._get(min);\n        let nodeB = this._get(index);\n        do {\n            nodeB.value = nodeA.value;\n            nodeA = nodeA.next!;\n            nodeB = nodeB.next!;\n        } while (++min < max);\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.length);\n        max = cwrap(max ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.length ? undefined : this._get(index).value;\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const tail = this.root.prev!;\n        tail.prev!.next = this.root;\n        this.root.prev = tail.prev;\n        --this.length;\n        return tail.value;\n    }\n\n    push(value: T): number {\n        const prev = this.root.prev!;\n        const node = { next: this.root, prev, value };\n        prev.next = this.root.prev = node;\n        return ++this.length;\n    }\n\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        node.prev!.next = node.next;\n        node.next!.prev = node.prev;\n        --this.length;\n        return node.value;\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.length);\n        max = cwrap(max ?? this.length, 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        const tail = root.next!;\n        let node = tail;\n        do {\n            const temp = node.next!;\n            node.next = node.prev;\n            node.prev = temp;\n            root.next = node;\n            node = temp;\n        } while (++min < max);\n        tail.next = node;\n        node.prev = tail;\n        root.next!.prev = root;\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n\n    shift(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const head = this.root.next!;\n        head.next!.prev = this.root;\n        this.root.next = head.next;\n        --this.length;\n        return head.value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    slice(min?: number, max?: number): DoublyLinkedList<T> {\n        return new DoublyLinkedList(this.view(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = cwrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n\n        // If not modifying the list\n        const list = new DoublyLinkedList<T>();\n        if (elements == null && count < 1) {\n            return list;\n        }\n\n        // Delete elements\n        let node = this._get(start);\n        while (count-- > 0) {\n            list.push(node.value);\n            node.prev!.next = node.next!;\n            node.next!.prev = node.prev!;\n            node = node.next!;\n            --this.length;\n        }\n\n        // Add elements\n        this._addAll(node, elements ?? []);\n\n        return list;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        if (this.length > 1) {\n            const [head, tail] = mergeSort(this.root.next!, this.length, true, compareFn);\n            this.root.next = head;\n            tail.next!.prev = tail;\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let node = this.root.next!; node !== this.root; node = node.next!) {\n            yield node.value;\n        }\n    }\n\n    unshift(value: T): number {\n        const head = this.root.next!;\n        const node = { next: head, prev: this.root, value };\n        this.root.next = head.prev = node;\n        return ++this.length;\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = cwrap((min as number) ?? 0, 0, this.length);\n        max = cwrap((max as number) ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = cwrap(min ?? 0, 0, this.length);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.length;\n        } else if (max >= 0) {\n            len = () => max;\n        } else {\n            len = () => this.length + max;\n        }\n\n        if (min < len()) {\n            let node = this._get(min);\n            do {\n                yield node.value;\n                node = node.next!;\n            } while (++min < len() && node !== this.root);\n        }\n    }\n    /**\n     *\n     */\n    protected _addAll(next: DoublyLinkedNode<T>, elements: Iterable<T>): void {\n        let prev = next.prev!;\n        for (const value of elements) {\n            const node = { prev, value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        next.prev = prev;\n    }\n    /**\n     * A helper method to iterate and return the node at the given index.\n     *\n     * Depending on the index, the list will be traversed from beginning or end; whichever is closest to the specified index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number): DoublyLinkedNode<T> {\n        let node = this.root;\n        if (index < this.length / 2) {\n            while (index-- >= 0) {\n                node = node.next!;\n            }\n        } else {\n            for (index = this.length - index; index > 0; --index) {\n                node = node.prev!;\n            }\n        }\n        return node;\n    }\n}\n","import { CompareFn } from '..';\nimport { LinkedNode } from './linkedNode';\nimport { List } from './list';\nimport { clamp, mergeSort, cwrap } from './utils';\n\n/**\n * A (circular) linked list implementation of the {@link List} interface.\n */\nexport class LinkedList<T> implements List<T> {\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The sentinel node at the fron of the list.\n     */\n    protected root: LinkedNode<T>;\n    /**\n     * The last node of the list.\n     */\n    protected tail: LinkedNode<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as LinkedNode<T>;\n        this.root.next = this.root;\n        this.tail = this._addAll(this.root, elements ?? []);\n    }\n\n    add(index: number, value: T): number {\n        if (index >= 0 && index < this.length) {\n            const prev = this._get(index - 1);\n            prev.next = { value, next: prev.next };\n            ++this.length;\n        } else if (index === this.length) {\n            this.push(value);\n        }\n        return this.length;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index < this.length) {\n            this._addAll(this._get(index - 1), elements);\n        } else if (index === this.length) {\n            this.tail = this._addAll(this.tail, elements);\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.tail = this.root.next = this.root;\n    }\n\n    concat(...lists: Iterable<T>[]): LinkedList<T> {\n        const out = new LinkedList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to itself\n        index = cwrap(index, 0, this.length);\n        min = cwrap(min ?? 0, 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = cwrap(max ?? this.length, 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Copy to earlier in the list\n        if (index < min) {\n            const node = this._get(index - 1);\n            this._copyWithin(this._get(min - index - 1, node), node, max - min);\n            return this;\n        }\n\n        // Copy to later in the list\n        if (index > max) {\n            const node = this._get(min - 1);\n            this._copyWithin(node, this._get(index - min - 1, node), max - min);\n            return this;\n        }\n\n        // Copy to overlapping destination\n        const nodeA = this._get(min - 1);\n        const nodeC = this._get(max - min - 1, nodeA);\n        const nodeD = this._copyWithin(nodeA, nodeC, index - min);\n        if (index + (max - min) >= this.length) {\n            this.tail = nodeC;\n        }\n        const temp = nodeA.next;\n        nodeA.next = nodeC.next;\n        nodeC.next = nodeD.next;\n        nodeD.next = temp;\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.length);\n        max = cwrap(max ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        return index < this.length - 1 ? this._get(index).value : this.tail.value;\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = index < this.length - 1 ? this._get(index) : this.tail;\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const value = this.tail.value;\n        this.tail = this._get(this.length - 2);\n        this.tail.next = this.root;\n        --this.length;\n        return value;\n    }\n\n    push(value: T): number {\n        const tail: LinkedNode<T> = { next: this.root, value };\n        this.tail.next = tail;\n        this.tail = tail;\n        return ++this.length;\n    }\n\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const prev = this._get(index - 1);\n        const node = prev.next!;\n        prev.next = node.next;\n        if (index === --this.length) {\n            this.tail = prev;\n        }\n        return node.value;\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.length);\n        max = cwrap(max ?? this.length, 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        this.tail = max >= this.length ? root.next! : this.tail;\n        const tail = root.next!;\n        let prev = tail;\n        let node = tail.next!;\n        while (++min < max) {\n            const next = node.next!;\n            node.next = prev;\n            prev = node;\n            node = next;\n        }\n        root.next = prev;\n        tail.next = node;\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n\n    shift(): T | undefined {\n        return this.remove(0);\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    slice(min?: number, max?: number): LinkedList<T> {\n        return new LinkedList(this.view(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = cwrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n\n        // If not modifying the list\n        const deleted = new LinkedList<T>();\n        if (elements == null && count < 1) {\n            return deleted;\n        }\n\n        // Delete elements\n        let prev = this._get(start - 1);\n        const newTail = start + count >= this.size;\n        while (count-- > 0) {\n            const node = prev.next!;\n            deleted.push(node.value);\n            prev.next = node.next;\n            --this.length;\n        }\n\n        // Add elements\n        prev = this._addAll(prev, elements ?? []);\n        this.tail = newTail ? prev : this.tail;\n\n        return deleted;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        if (this.length > 1) {\n            const [head, tail] = mergeSort(this.root.next!, this.length, false, compareFn);\n            this.root.next = head;\n            this.tail = tail;\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let node = this.root.next!; node !== this.root; node = node.next!) {\n            yield node.value;\n        }\n    }\n\n    unshift(value: T): number {\n        return this.add(0, value);\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = cwrap((min as number) ?? 0, 0, this.length);\n        max = cwrap((max as number) ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = cwrap(min ?? 0, 0, this.length);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.length;\n        } else if (max >= 0) {\n            len = () => max;\n        } else {\n            len = () => this.length + max;\n        }\n\n        if (min < len()) {\n            let node = this._get(min);\n            do {\n                yield node.value;\n                node = node.next!;\n            } while (++min < len() && node !== this.root);\n        }\n    }\n\n    protected _addAll(prev: LinkedNode<T>, elements: Iterable<T>): LinkedNode<T> {\n        const next = prev.next!;\n        for (const value of elements) {\n            const node = { value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        return prev;\n    }\n    /**\n     * Copy values from 'from' to 'to'.\n     *\n     * @param from - The initial node to copy from\n     * @param prev - The root of the initial node to copy to\n     * @param count - The number of values to copy\n     */\n    protected _copyWithin(from: LinkedNode<T>, to: LinkedNode<T>, count: number): LinkedNode<T> {\n        while (count-- > 0) {\n            from = from.next!;\n            to = to.next!;\n            to.value = from.value;\n        }\n        return to;\n    }\n    /**\n     * Get the node at the given index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number, root: LinkedNode<T> = this.root): LinkedNode<T> {\n        let node = root!;\n        while (index-- >= 0) {\n            node = node.next!;\n        }\n        return node;\n    }\n}\n","import { isArray } from '../array/utils';\nimport { CompareFn } from '..';\nimport { DoublyLinkedNode } from './doublyLinkedNode';\nimport { LinkedNode } from './linkedNode';\n\n/**\n * Groups an iterable into batches of a given size.\n *\n * @param size - The maximum batch size\n * @param iterable - The iterable to batch\n *\n * @returns An iterable of batches\n *\n * @internal\n */\nexport function batch<T>(\n    size: number,\n    iterable: Iterable<T>,\n): Generator<T[], void, number | undefined> {\n    if (isArray(iterable)) {\n        return batchArray(size, iterable);\n    }\n    return batchIterable(size, iterable);\n}\n/**\n * Groups an iterable into batches of a given size.\n *\n * @param size - The maximum batch size\n * @param iterable - The iterable to batch\n *\n * @returns An iterable of batches\n *\n * @internal\n */\nexport function* batchArray<T>(size: number, array: T[]): Generator<T[], void, number | undefined> {\n    let min = 0;\n    while (min < array.length) {\n        const max = min + size;\n        size = (yield array.slice(min, max)) ?? size;\n        min = max;\n    }\n}\n/**\n * Groups an iterable into batches of a given size.\n *\n * @param size - The maximum batch size\n * @param iterable - The iterable to batch\n *\n * @returns An iterable of batches\n *\n * @internal\n */\nexport function* batchIterable<T>(\n    size: number,\n    iterable: Iterable<T>,\n): Generator<T[], void, number | undefined> {\n    let array: T[] = [];\n    for (const value of iterable) {\n        if (array.push(value) >= size) {\n            size = (yield array) ?? size;\n            array = [];\n        }\n    }\n    if (array.length > 0) {\n        yield array;\n    }\n}\n/**\n * Limits a number to be within a given range.\n *\n * f(x, min, max) = y, where min <= y <= max\n *\n * @param num - The number to clamp\n * @param min - The minimum result value, inclusive\n * @param max - The maximum result value, inclusive\n *\n * @returns The clamped number\n *\n * @internal\n */\nexport function clamp(num: number, min: number, max: number): number {\n    return Math.min(max, Math.max(min, num));\n}\n/**\n * Wraps and then clamps a number within a given range.\n *\n * @param num - The number to wrap and then clamp\n * @param min - The minimum result value, inclusive\n * @param max - The wrap pivot and maximum result value, inclusive\n *\n * @returns The crwapped number\n *\n * @internal\n */\nexport function cwrap(num: number, min: number, max: number): number {\n    return clamp(wrap(num, max), min, max);\n}\n/**\n * Sorts a list in place.\n *\n * Works on complete lists as well as sublists and circular lists:\n * - Linked lists will keep the link to the next node beyond the sorted section\n * - Doubly linked lists will keep links to the prev and next nodes outside the sorted section\n *\n * @param node - The head of the list\n * @param len - The length of the list beginning from node\n * @param isDoubly - Whether node is a doubly linked node\n * @param compareFn - A function used to determine the order of elements.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n *\n * @returns The new head and tail of the sorted list\n *\n * @internal\n */\nexport function mergeSort<T, Node extends LinkedNode<T>>(\n    node: Node,\n    len: number,\n    isDoubly: boolean,\n    compareFn: CompareFn<T>,\n): [Node, Node] {\n    // Base case\n    if (len < 2) {\n        return [node, node];\n    }\n\n    // Split the list into two halves and sort them\n    len = len / 2;\n    const lens: [number, number] = [Math.ceil(len), Math.floor(len)];\n    const heads = mergeSort(node, lens[0], isDoubly, compareFn);\n    const tails = mergeSort(heads[1].next as Node, lens[1], isDoubly, compareFn);\n\n    // Group the heads and tails together\n    node = heads[1];\n    heads[1] = tails[0];\n    tails[0] = node;\n    tails[0].next = tails[1].next;\n\n    // Merge the sorted halves\n    const prev = (heads[0] as DoublyLinkedNode<T>).prev;\n    node = mergeSorted(heads, lens, isDoubly, compareFn);\n    isDoubly && ((node as DoublyLinkedNode<T>).prev = prev);\n\n    // Return the head and tail\n    return [node, tails[+(lens[0] < 1)]];\n}\n/**\n * Merges two sorted lists.\n *\n * @param nodes - The heads of the lists\n * @param lens - The lengths of the lists\n * @param isDoubly - Whether the lists are a doubly linked\n * @param compareFn - A function used to determine the order of elements.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n *\n * @returns The new head of the sorted list\n *\n * @internal\n */\nexport function mergeSorted<T, Node extends LinkedNode<T>>(\n    heads: [Node, Node],\n    lens: [number, number],\n    isDoubly: boolean,\n    compareFn: CompareFn<T>,\n): Node {\n    const root = {} as Node;\n\n    let node = root;\n    do {\n        const index = +(compareFn(heads[0].value, heads[1].value) > 0);\n        node.next = heads[index];\n        isDoubly && ((node.next as DoublyLinkedNode<T>).prev = node);\n        node = node.next as Node;\n        heads[index] = node.next as Node;\n        --lens[index];\n    } while (lens[0] > 0 && lens[1] > 0);\n\n    // Add any remaining nodes\n    node.next = heads[+(lens[0] < 1)];\n    isDoubly && node.next && ((node.next as DoublyLinkedNode<T>).prev = node);\n    return root.next as Node;\n}\n/**\n * Wraps a number around a pivot\n *\n * f(x, min, pivot) = {\n *    x, where x >= 0\n *    pivot + x, where x < 0\n * }\n *\n * @param num - The number to wrap\n * @param pivot - The number to pivot on\n *\n * @returns - The wrapped number\n *\n * @internal\n */\nexport function wrap(num: number, pivot: number): number {\n    return num < 0 ? pivot + num : num;\n}\n/**\n * Moves a given number of spaces forward in a list\n *\n * @param head - The head of the list\n * @param len - The number of spaces to move\n *\n * @returns - The node len spaces ahead from head\n *\n * @internal\n *\nexport function next<T, Node extends LinkedNode<T>>(head: Node, len: number): Node {\n    while (len-- > 0) {\n        head = head.next as Node;\n    }\n    return head;\n}\n*/\n","import { Queue } from './queue';\n\n/**\n * An implementation of the {@link Queue} interface using an array\n */\nexport class ArrayQueue<T> implements Queue<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * Instantiate the queue.\n     *\n     * @param elements - A set of elements to initialize the queue with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    dequeue(): T | undefined {\n        return this.size < 1 ? undefined : this.array.shift();\n    }\n\n    enqueue(element: T): number {\n        return this.array.push(element);\n    }\n\n    peek(): T | undefined {\n        return this.size < 1 ? undefined : this.array[0];\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Queue } from './queue';\n\n/**\n * A linked list implementation of the {@link Queue} interface\n */\nexport class LinkedQueue<T> implements Queue<T> {\n    /**\n     * The list containing every element.\n     */\n    protected list: List<T>;\n    /**\n     * Instantiate the queue.\n     *\n     * @param elements - A set of elements to initialize the queue with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList(elements);\n    }\n\n    clear(): void {\n        this.list.clear();\n    }\n\n    dequeue(): T | undefined {\n        return this.list.shift();\n    }\n\n    enqueue(element: T): number {\n        return this.list.push(element);\n    }\n\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","import { Stack } from './stack';\n\n/**\n * An implementation of the {@link Stack} interface using an array\n */\nexport class ArrayStack<T> implements Stack<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * Instantiate the stack.\n     *\n     * @param elements - A set of elements to initialize the stack with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    peek(): T | undefined {\n        return this.array[this.array.length - 1];\n    }\n\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n\n    push(element: T): number {\n        return this.array.push(element);\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        const array = this.array;\n        for (let i = array.length; i > 0; yield array[--i]) {}\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Stack } from './stack';\n\n/**\n * A linked list implementation of the {@link Stack} interface\n */\nexport class LinkedStack<T> implements Stack<T> {\n    /**\n     * The list containing every element.\n     */\n    protected list: List<T>;\n    /**\n     * Instantiate the stack.\n     *\n     * @param elements - A set of elements to initialize the stack with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList();\n        for (const element of elements || []) {\n            this.push(element);\n        }\n    }\n\n    clear(): void {\n        this.list.clear();\n    }\n\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n\n    pop(): T | undefined {\n        return this.list.shift();\n    }\n\n    push(element: T): number {\n        return this.list.unshift(element);\n    }\n\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","import { AATreeNode } from './aaTreeNode';\nimport { CompareFn } from '..';\n\n/**\n *\n * @param value\n * @param node\n * @param compareFn\n *\n * @returns\n *\n * @internal\n */\nexport function insert<T>(\n    value: T,\n    node: AATreeNode<T> | undefined,\n    compareFn: CompareFn<T>,\n): AATreeNode<T> {\n    // If the tree is empty\n    if (node == null) {\n        return { level: 1, value };\n    }\n\n    // If value < node\n    if (compareFn(value, node.value) < 0) {\n        node.left = insert(value, node.left, compareFn);\n\n        // If value >= node\n    } else {\n        node.right = insert(value, node.right, compareFn);\n    }\n\n    // Balance the tree\n    node = skew(node);\n    node = split(node);\n    return node!;\n}\n/**\n *\n * @param value\n * @param node\n * @param compareFn\n *\n * @returns\n *\n * @internal\n */\nexport function remove<T>(\n    value: T,\n    node: AATreeNode<T> | undefined,\n    compareFn: CompareFn<T>,\n): [AATreeNode<T> | undefined, boolean] {\n    if (node == null) {\n        return [undefined, false];\n    }\n\n    let found = false;\n    const comparison = compareFn(value, node.value);\n    if (comparison < 0) {\n        [node.left, found] = remove(value, node.left, compareFn);\n    } else if (comparison > 0) {\n        [node.right, found] = remove(value, node.right, compareFn);\n    } else if (node.left != null) {\n        found = true;\n\n        // Replace node with predecessor\n        let par = node.left;\n        let chi = par.right;\n        if (chi == null) {\n            node.value = par.value;\n            node.left = par.left;\n        } else {\n            while (chi.right != null) {\n                par = chi;\n                chi = chi.right;\n            }\n            node.value = chi.value;\n            par.right = chi.left;\n        }\n    } else if (node.right != null) {\n        found = true;\n\n        // Replace node with successor\n        let par = node.right;\n        let chi = par.left;\n        if (chi == null) {\n            node.value = par.value;\n            node.right = par.right;\n        } else {\n            while (chi.left != null) {\n                par = chi;\n                chi = chi.left;\n            }\n            node.value = chi.value;\n            par.left = chi.right;\n        }\n    } else {\n        return [undefined, true];\n    }\n\n    if (!found) {\n        return [node, false];\n    }\n\n    // Decrease levels.\n    const level = Math.min(node.left?.level ?? 0, node.right?.level ?? 0) + 1;\n    if (level < node.level) {\n        node.level = level;\n        if (node.right != null && level < node.right.level) {\n            node.right.level = level;\n        }\n    }\n\n    // Rebalance the tree.\n    node = skew(node)!;\n    node.right = skew(node.right);\n    if (node.right != null) {\n        node.right.right = skew(node.right.right);\n    }\n    node = split(node)!;\n    node.right = split(node.right);\n    return [node, true];\n}\n\n/**\n *\n * @param node\n *\n * @returns\n *\n * @internal\n */\nexport function skew<T>(node: AATreeNode<T> | undefined): AATreeNode<T> | undefined {\n    if (node == null || node.left == null || node.level != node.left.level) {\n        return node;\n    }\n    const left = node.left;\n    node.left = left.right;\n    left.right = node;\n    return left;\n}\n/**\n *\n * @param node\n *\n * @returns\n *\n * @internal\n */\nexport function split<T>(node: AATreeNode<T> | undefined): AATreeNode<T> | undefined {\n    if (\n        node == null ||\n        node.right == null ||\n        node.right.right == null ||\n        node.level != node.right.right.level\n    ) {\n        return node;\n    }\n    const right = node.right;\n    node.right = right.left;\n    right.left = node;\n    ++right.level;\n    return right;\n}\n","import { CompareFn } from '..';\nimport { AATreeNode } from './aaTreeNode';\nimport { clone, inOrderTraverse, preOrderTraverse } from './binaryTreeUtils';\nimport { SortedTree } from './sortedTree';\nimport { insert, remove } from './aaTreeUtils';\nimport { isArray } from 'src/array/utils';\n\n/**\n * An AA tree is a form of balanced tree used for storing and retrieving ordered data efficiently\n * ([source](https://en.wikipedia.org/wiki/AA_tree)).\n *\n * AA trees are named for Arne Andersson, their inventor. They are a variation of the red–black tree,\n * which supports efficient addition and deletion of entries. Unlike red–black trees, additional\n * constraints on the balancing mechanism greatly simplifies the implementation as well as\n * maintenance operations; While a red–black tree needs to consider seven different shapes\n * to properly balance the tree, an AA tree only needs to consider two shapes.\n *\n * The performance of an AA tree is equivalent to the performance of a red–black tree.\n * While an AA tree makes more rotations than a red-black tree, the simpler algorithms\n * tend to be faster, which balances out to similar performance. A red-black tree is\n * more consistent in its performance, but an AA tree tends to be flatter, which results\n * in slightly faster search times.\n */\nexport class AATree<T> implements SortedTree<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The node at the \"top\" of the heap.\n     */\n    protected root: AATreeNode<T> | undefined;\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>) {\n        this.compare = compareFn;\n        this.length = 0;\n        this.build(elements ?? []);\n    }\n\n    add(element: T): number {\n        this.root = insert(element, this.root, this.compare);\n        return ++this.length;\n    }\n\n    clear(): void {\n        this.root = undefined;\n        this.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        let node = this.root;\n        while (node != null) {\n            if (element === node.value) {\n                return true;\n            }\n            node = this.compare(element, node.value) < 0 ? node.left : node.right;\n        }\n        return false;\n    }\n\n    delete(element: T): boolean {\n        const res = remove(element, this.root, this.compare);\n        this.root = res[0];\n        this.length -= +res[1];\n        return res[1];\n    }\n\n    max(): T | undefined {\n        let node = this.root;\n        if (node == null) {\n            return undefined;\n        }\n        while (node.right != null) {\n            node = node.right;\n        }\n        return node.value;\n    }\n\n    min(): T | undefined {\n        let node = this.root;\n        if (node == null) {\n            return undefined;\n        }\n        while (node.left != null) {\n            node = node.left;\n        }\n        return node.value;\n    }\n\n    pop(): T | undefined {\n        const value = this.max();\n        if (value != null) {\n            this.root = remove(value, this.root, this.compare)[0];\n            --this.length;\n        }\n        return value;\n    }\n\n    shift(): T | undefined {\n        const value = this.min();\n        if (value != null) {\n            this.root = remove(value, this.root, this.compare)[0];\n            --this.length;\n        }\n        return value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        for (const node of inOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.delete(curElement)) {\n            this.add(newElement);\n            return true;\n        }\n        return false;\n    }\n\n    protected build(obj: Iterable<T>): void {\n        if (isArray(obj)) {\n            for (let i = 0; i < obj.length; ++i) {\n                this.add(obj[i]);\n            }\n        } else if (obj instanceof AATree && this.compare === obj.compare) {\n            this.root = clone(obj.root);\n            this.length = obj.size;\n        } else {\n            for (const element of obj) {\n                this.add(element);\n            }\n        }\n    }\n}\n","import { AVLTreeNode } from './avlTreeNode';\nimport { Edge, successor } from './binaryTreeUtils';\nimport { LinkedNode } from 'src/list';\n\n/**\n * @internal\n */\nexport function balance<T>(node: AVLTreeNode<T>): AVLTreeNode<T> {\n    const bf = balanceFactor(node);\n    if (bf > 1) {\n        if (balanceFactor(node.right!) < 0) {\n            node.right = rotateR(node.right!);\n        }\n        node = rotateL(node);\n    } else if (bf < -1) {\n        if (balanceFactor(node.left!) > 0) {\n            node.left = rotateL(node.left!);\n        }\n        node = rotateR(node);\n    }\n    return node;\n}\n/**\n * @internal\n */\nexport function balanceFactor(node: AVLTreeNode<unknown>): number {\n    return (node.right?.height ?? -1) - (node.left?.height ?? -1);\n}\n/**\n * @internal\n */\nexport function height(node: AVLTreeNode<unknown>): number {\n    return 1 + Math.max(node.right?.height ?? -1, node.left?.height ?? -1);\n}\n/**\n * @internal\n */\nexport function remove<T>(stack: LinkedNode<Edge<AVLTreeNode<T>>>): boolean {\n    let edge = stack.value;\n    let node = edge.to;\n\n    // If not found\n    if (node == null) {\n        return false;\n    }\n\n    // Find the replacement\n    if (node.right == null) {\n        // If no right child, replace with left\n        node = node.left;\n    } else if (node.left == null) {\n        // If no left child, replace with right\n        node = node.right;\n    } else {\n        // If two children, find the successor\n        stack = successor(stack);\n        edge = stack.value;\n\n        // Swap with the successor\n        const temp = edge.to!;\n        node.value = temp.value;\n\n        // Replace with the successor's right child\n        node = temp.right;\n    }\n\n    // Make the replacement / update the tree\n    edge.from![edge.label!] = edge.to = node;\n\n    // Balance the tree\n    while (stack.next) {\n        stack = stack.next;\n        const edge = stack.value;\n        edge.to!.height = height(edge.to!);\n        edge.from![edge.label!] = balance(edge.to!);\n    }\n\n    return true;\n}\n/**\n * @internal\n */\nexport function rotateL<T>(P: AVLTreeNode<T>): AVLTreeNode<T> {\n    const R = P.right!;\n    P.right = R.left;\n    R.left = P;\n    P.height = height(P);\n    R.height = height(R);\n    return R;\n}\n/**\n * @internal\n */\nexport function rotateR<T>(P: AVLTreeNode<T>): AVLTreeNode<T> {\n    const L = P.left!;\n    P.left = L.right;\n    L.right = P;\n    P.height = height(P);\n    L.height = height(L);\n    return L;\n}\n","import { CompareFn } from 'src';\nimport { AVLTreeNode } from './avlTreeNode';\nimport {\n    clone,\n    Edge,\n    inOrderTraverse,\n    leftmost,\n    preOrderTraverse,\n    rightmost,\n    search,\n} from './binaryTreeUtils';\nimport { SortedTree } from './sortedTree';\nimport { isArray } from 'src/array/utils';\nimport { balance, height, remove } from './avlTreeUtils';\n\n/**\n * An AVL tree is a self-balancing binary search tree ([source](https://en.wikipedia.org/wiki/AVL_tree)).\n *\n * It is named after inventors Georgy Adelson-Velsky and Evgenii Landis and was the first such\n * data structure to be invented. In an AVL tree, the heights of the two child\n * subtrees of any node differ by at most one; if at any time they differ by more\n * than one, rebalancing is done to restore this property.\n *\n * Lookup, insertion, and deletion all take O(log(n)) time in both the average and worst cases,\n * where n is the number of nodes in the tree prior to the operation. Insertions and deletions\n * may require the tree to be rebalanced by one or more tree rotations.\n *\n * AVL trees are often compared with red–black trees as both take O(log(n))\n * time for the basic operations. For lookup-intensive applications, AVL trees are\n * faster than red–black trees because they are more strictly balanced.\n * Similar to red–black trees, AVL trees are height-balanced.\n */\nexport class AVLTree<T> implements SortedTree<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * Indicates how to handle duplicates:\n     * - < 0 : Add to left subtree\n     * - = 0 : Do now allow duplicates\n     * - > 0 : Add to right subtree\n     */\n    protected dupeWeight: number;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The root of the tree.\n     */\n    protected root: AVLTreeNode<T>;\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>);\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param allowDuplicates - Whether to allow duplicates\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, allowDuplicates: boolean, elements?: Iterable<T>);\n    constructor(\n        compareFn: CompareFn<T>,\n        allowDuplicates?: boolean | Iterable<T>,\n        elements?: Iterable<T>,\n    ) {\n        if (typeof allowDuplicates !== 'boolean') {\n            elements = allowDuplicates;\n            allowDuplicates = true;\n        }\n        this.compare = compareFn;\n        this.dupeWeight = +allowDuplicates;\n        this.length = 0;\n        this.root = {} as AVLTreeNode<T>;\n        this.build(elements ?? []);\n    }\n\n    add(element: T): number {\n        // Find the element\n        const edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        let stack = search(element, { value: edge }, this.compare, this.dupeWeight);\n\n        // If element already exists\n        if (stack.value.to != null) {\n            return this.length;\n        }\n\n        // Add element\n        const node = stack.value.from!;\n        node[stack.value.label!] = { height: 0, value: element };\n\n        // Balance the tree\n        while (stack.next) {\n            stack = stack.next;\n            const edge = stack.value;\n            edge.to!.height = height(edge.to!);\n            edge.from![edge.label!] = balance(edge.to!);\n        }\n\n        // Update state\n        return ++this.length;\n    }\n\n    clear(): void {\n        this.root.left = undefined;\n        this.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        let edge: Edge<AVLTreeNode<T>> = { to: this.root.left };\n        edge = search(element, { value: edge }, this.compare, 0).value;\n        return edge.to != null;\n    }\n\n    delete(element: T): boolean {\n        // Remove the element if found\n        const edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        const stack = search(element, { value: edge }, this.compare, 0);\n        const removed = remove(stack);\n\n        // Update state\n        this.length -= +removed;\n        return removed;\n    }\n\n    max(): T | undefined {\n        let edge: Edge<AVLTreeNode<T>> = { to: this.root.left };\n        edge = rightmost({ value: edge }).value;\n        return edge.to?.value;\n    }\n\n    min(): T | undefined {\n        let edge: Edge<AVLTreeNode<T>> = { to: this.root.left };\n        edge = leftmost({ value: edge }).value;\n        return edge.to?.value;\n    }\n\n    pop(): T | undefined {\n        // Find the maximum value\n        const edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        const stack = rightmost({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.length -= +removed;\n        return value;\n    }\n\n    shift(): T | undefined {\n        // Find the minimum value\n        const edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        const stack = leftmost({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.length -= +removed;\n        return value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        for (const node of inOrderTraverse(this.root.left)) {\n            yield node.value;\n        }\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root.left)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.delete(curElement)) {\n            this.add(newElement);\n            return true;\n        }\n        return false;\n    }\n\n    protected build(obj: Iterable<T>): void {\n        if (isArray(obj)) {\n            for (let i = 0; i < obj.length; ++i) {\n                this.add(obj[i]);\n            }\n        } else if (obj instanceof AVLTree && this.compare === obj.compare) {\n            this.root = clone(obj.root);\n            this.length = obj.size;\n        } else {\n            for (const element of obj) {\n                this.add(element);\n            }\n        }\n    }\n}\n","import { LinkedNode } from 'src/list';\nimport { CompareFn } from '..';\nimport { BinaryTreeNode } from './binaryTreeNode';\n\n/**\n * @internal\n */\nexport interface Edge<Node extends BinaryTreeNode<unknown>> {\n    label?: 'left' | 'right';\n    from?: Node;\n    to?: Node;\n}\n/**\n * [source](https://stackoverflow.com/questions/51419176/how-to-get-a-subset-of-keyof-t-whose-value-tk-are-callable-functions-in-typ)\n * \n * @internal\n *\nexport type KeyOfType<T, U> = {[K in keyof T]: T[K] extends U ? K: never}[keyof T];\n*/\n/**\n * @internal\n */\nexport function debug<N extends BinaryTreeNode<T>, T = any>(\n    root: N | undefined,\n    mapFn?: (node: N) => any,\n): void {\n    mapFn = mapFn == null ? (n) => n.value : mapFn;\n\n    // Turn the tree into an array in level-order\n    const array: string[] = [];\n    for (const node of levelOrderTraverse(root, true)) {\n        array.push(node ? `${mapFn(node)}` : '?');\n    }\n\n    // If empty\n    if (array.length < 1) {\n        console.log('<empty>\\n');\n        return;\n    }\n\n    // Find the longest value string\n    const lenV = array.reduce((p, c) => Math.max(p, c.length), 0);\n\n    // Pad each value\n    for (let i = 0; i < array.length; ++i) {\n        array[i] = pad(array[i], lenV, ' ');\n    }\n\n    // Split values into levels\n    const levels = [];\n    for (let n = 1; array.length > 0; n *= 2) {\n        levels.push(array.splice(0, n));\n    }\n\n    // Initialize formatting variables\n    let branch = '_'.repeat(1 + lenV / 2);\n    let offset = '';\n    const offsetOffset = ' '.repeat(branch.length);\n    let separator = ' '.repeat(1 + ((lenV - 1) & 1));\n    const separatorOffset = ' '.repeat(lenV);\n\n    // Build the last level\n    array.length = levels.length;\n    array[array.length - 1] = levels.pop()!.join(separator);\n\n    // Build remaining levels in reverse\n    for (let n = levels.length - 1; n >= 0; --n) {\n        const level = levels.pop()!;\n        for (let j = 0; j < level.length; ++j) {\n            level[j] = branch + level[j] + branch;\n        }\n        array[n] = offset + level.join(separator);\n        branch += branch;\n        offset += offset + offsetOffset;\n        separator += separator + separatorOffset;\n    }\n\n    // Output\n    console.log(array.join('\\n'), '\\n');\n}\n/**\n * @internal\n */\nexport function clone<T, Node extends BinaryTreeNode<T>>(node?: undefined): undefined;\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: Node): Node;\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: Node | undefined): Node | undefined;\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: Node | undefined): Node | undefined {\n    if (node == null) {\n        return undefined;\n    }\n    const out: Node = Object.assign({}, node);\n    let stack: LinkedNode<Node> | undefined = { value: out };\n    do {\n        node = stack.value;\n        stack = stack.next;\n        if (node.left) {\n            stack = { next: stack, value: (node.left = Object.assign({}, node.left)) };\n        }\n        if (node.right) {\n            stack = { next: stack, value: (node.right = Object.assign({}, node.right)) };\n        }\n    } while (stack);\n    return out;\n}\n/**\n * @internal\n */\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    let node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    while (node.left) {\n        stack = { next: stack, value: { label: 'left', from: node, to: node.left } };\n        node = node.left;\n    }\n    return stack;\n}\n/**\n * @internal\n */\nexport function* inOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    let stack: LinkedNode<Node> | undefined = undefined;\n\n    while (node) {\n        stack = { next: stack, value: node };\n        node = node.left;\n    }\n\n    while (stack) {\n        node = stack.value;\n        stack = stack.next;\n        yield node;\n        node = node.right;\n        while (node) {\n            stack = { next: stack, value: node };\n            node = node.left;\n        }\n    }\n}\n/**\n * @internal\n */\nexport function levelOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n    padded?: false,\n): Generator<Node>;\nexport function levelOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n    padded: true,\n): Generator<Node | undefined>;\nexport function* levelOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n    padded = false,\n): Generator<Node | undefined> {\n    const nil = {} as LinkedNode<Node | undefined>;\n    let head: LinkedNode<Node | undefined> = { value: node };\n    let tail = head;\n    for (let cont = node != null; cont; head = head.next!) {\n        tail = tail.next = nil;\n        for (cont = false; head !== nil; head = head.next!) {\n            node = head.value;\n            if (node) {\n                yield node;\n                cont ||= node.left != null || node.right != null;\n                tail = tail.next = { value: node.left };\n                tail = tail.next = { value: node.right };\n            } else if (padded) {\n                yield undefined;\n                tail = tail.next = { value: undefined };\n                tail = tail.next = { value: undefined };\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nfunction pad(str: string, maxLen: number, fillString: string): string {\n    const len = str.length;\n    if (len >= maxLen) {\n        return str;\n    }\n    const diff = maxLen - len;\n    return str.padStart(len + diff / 2, fillString).padEnd(len + diff, fillString);\n}\n/**\n * @internal\n */\nexport function* postOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    interface Meta {\n        seen: boolean;\n        node?: Node;\n    }\n    let stack: LinkedNode<Meta> | undefined = { value: { seen: false, node } };\n    do {\n        const meta = stack.value;\n        stack = stack.next;\n        if (meta.node) {\n            if (meta.seen) {\n                yield meta.node;\n            } else {\n                meta.seen = true;\n                stack = { next: stack, value: meta };\n                stack = { next: stack, value: { seen: false, node: meta.node.right } };\n                stack = { next: stack, value: { seen: false, node: meta.node.left } };\n            }\n        }\n    } while (stack);\n}\n/**\n * @internal\n */\nexport function predecessor<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    const node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    stack = { next: stack, value: { label: 'left', from: node, to: node.left } };\n    if (node.left == null) {\n        return stack;\n    }\n    return rightmost(stack);\n}\n/**\n * @internal\n */\nexport function* preOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    let stack: LinkedNode<Node | undefined> | undefined = { value: node };\n    do {\n        node = stack.value;\n        stack = stack.next;\n        if (node) {\n            yield node;\n            stack = { next: stack, value: node.right };\n            stack = { next: stack, value: node.left };\n        }\n    } while (stack);\n}\n/**\n * @internal\n */\nexport function reverse<Node extends BinaryTreeNode<unknown>>(root: Node): void {\n    for (const node of preOrderTraverse(root)) {\n        const left = node.left;\n        node.left = node.right;\n        node.right = left;\n    }\n}\n/**\n * @internal\n */\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    let node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    while (node.right) {\n        stack = { next: stack, value: { label: 'right', from: node, to: node.right } };\n        node = node.right;\n    }\n    return stack;\n}\n/**\n * Assumes sorted by compareFn\n * @internal\n */\nexport function search<T, Node extends BinaryTreeNode<T>>(\n    element: T,\n    stack: LinkedNode<Edge<Node>>,\n    compareFn: CompareFn<T>,\n    dupeWeight = 0,\n): LinkedNode<Edge<Node>> {\n    const paths: ['left', 'right'] = ['left', 'right'];\n    let node = stack.value.to;\n    while (node) {\n        const comp: number = compareFn(element, node.value) || dupeWeight;\n        if (comp === 0) {\n            break;\n        }\n        const label = paths[+(comp > 0)];\n        stack = { next: stack, value: { label, from: node, to: node[label] } };\n        node = node[label]!;\n    }\n    return stack;\n}\n/**\n * @internal\n */\nexport function successor<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    const node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    stack = { next: stack, value: { label: 'right', from: node, to: node.right } };\n    if (node.right == null) {\n        return stack;\n    }\n    return leftmost(stack);\n}\n/**\n * @internal\n */\nexport function toBinaryTree<T>(\n    elements: (T | undefined)[] | undefined,\n): BinaryTreeNode<T> | undefined {\n    if (elements == null || elements.length < 1 || elements[0] == null) {\n        return undefined;\n    }\n    const n = elements.length;\n    const nodes: BinaryTreeNode<T>[] = new Array(n);\n    nodes[0] = { value: elements[0] };\n    for (let i = 1; i < n; ++i) {\n        if (elements[i] == null) {\n            continue;\n        }\n        const par = nodes[(i - 1) >>> 1];\n        const node = { value: elements[i]! };\n        nodes[i] = node;\n        if (i & 1) {\n            par.left = node;\n        } else {\n            par.right = node;\n        }\n    }\n    return nodes[0];\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}