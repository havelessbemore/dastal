{"version":3,"sources":["webpack://Dastal/webpack/universalModuleDefinition","webpack://Dastal/./src/list/arrayList.ts","webpack://Dastal/./src/list/doublyLinkedList.ts","webpack://Dastal/./src/list/linkedList.ts","webpack://Dastal/./src/queue/arrayQueue.ts","webpack://Dastal/./src/queue/linkedQueue.ts","webpack://Dastal/./src/stack/arrayStack.ts","webpack://Dastal/./src/stack/linkedStack.ts","webpack://Dastal/./src/utils.ts","webpack://Dastal/webpack/bootstrap","webpack://Dastal/webpack/runtime/compat get default export","webpack://Dastal/webpack/runtime/define property getters","webpack://Dastal/webpack/runtime/hasOwnProperty shorthand","webpack://Dastal/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","self","Symbol","iterator","ArrayList","elements","this","array","Array","from","index","element","length","splice","size","res","next","done","push","value","out","lists","list","min","max","copyWithin","fill","callback","pop","wrap","slice","reverse","prev","shift","unshift","len","Math","DoublyLinkedList","_get","node","nodeA","nodeB","undefined","tail","temp","head","view","i","LinkedList","_reverse","_copyWithin","remove","to","count","ArrayQueue","LinkedQueue","clear","get","ArrayStack","LinkedStack","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","r","toStringTag"],"mappings":"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","file":"dastal.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Dastal\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Dastal\"] = factory();\n\telse\n\t\troot[\"Dastal\"] = factory();\n})(self, function() {\nreturn ","import { List } from './list';\nimport { wrap } from '../utils';\n\n/**\n * An implementation of the {@link List} interface using an array\n */\nexport class ArrayList<T> implements List<T> {\n    /**\n     * @ignore\n     */\n    protected array: Array<T>;\n\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n    /**\n     * Add the element at the specified index.\n     *\n     * A negative index can be used to indicate an offset from the end of the list.\n     * For example, -2 refers to the second to last element of the list.\n     *\n     * @param index - The index to add into\n     * @param element - The element to add\n     *\n     * @returns The new size of the list\n     */\n    add(index: number, element: T): number {\n        if (index >= 0 && index <= this.array.length) {\n            this.array.splice(index, 0, element);\n        }\n        return this.size;\n    }\n    /**\n     * Add elements at the specified index.\n     *\n     * A negative index can be used to indicate an offset from the end of the list.\n     * For example, -2 refers to the second to last element of the list.\n     *\n     * @param index - The index to add into\n     * @param element - The elements to add\n     *\n     * @returns The new size of the list\n     */\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index < 0 || index > this.array.length) {\n            return this.size;\n        }\n\n        const iterator = elements[Symbol.iterator]();\n        const max = 10000;\n        let res = iterator.next();\n        while (!res.done) {\n            const array: T[] = [];\n            do {\n                array.push(res.value);\n                res = iterator.next();\n            } while (!res.done && array.length < max);\n            this.array.splice(index, 0, ...array);\n            index += array.length;\n        }\n\n        return this.size;\n    }\n    /**\n     * Removes all elements\n     */\n    clear(): void {\n        this.array.length = 0;\n    }\n    /**\n     * Combines the list with multiple iterables into a new list.\n     * Does not modify the existing list or inputs.\n     *\n     * @param lists — Additional iterables to add to the end of the list.\n     *\n     * @returns A new list consisting of the elements in the list on which\n     * it is called, followed in order by the elements of each argument. It\n     * does not recurse into nested iterable arguments\n     */\n    concat(...lists: Iterable<T>[]): ArrayList<T> {\n        const out = new ArrayList(this);\n        for (const list of lists) {\n            for (const element of list) {\n                out.push(element);\n            }\n        }\n        return out;\n    }\n    /**\n     * Copies a section of the list identified by min and max to the same array at position index.\n     *\n     * Negative indices can be used for index, min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * Note that this method will not change the size of the list. If index is after min,\n     * the copied sequence will be trimmed to fit list.size\n     *\n     * @param index - Where to copy the sequence to\n     * @param min - Where to start copying elements from, inclusive. Defaults to 0\n     * @param max - Where to end copying elements from, exclusive. Defaults to list.size\n     *\n     * @returns The list\n     */\n    copyWithin(index: number, min?: number, max?: number): this {\n        this.array.copyWithin(index, min ?? 0, max);\n        return this;\n    }\n    /**\n     * Returns the this object after filling the section identified by min and max with element.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param element — element to fill list section with\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param end - Where to stop filling the list, exclusive. Defaults to list.size\n     *\n     * @returns The list on which this method was called\n     */\n    fill(element: T, min?: number, max?: number): this {\n        this.array.fill(element, min, max);\n        return this;\n    }\n    /**\n     * Return the element at the specified index.\n     *\n     * A negative index can be used for to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The element at the index, or `undefined` if index is invalid\n     */\n    get(index: number): T | undefined {\n        if (index < 0 || index >= this.array.length) {\n            return undefined;\n        }\n        return this.array[index];\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * A negative index can be used to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param index - The index to retrieve\n     * @param callback - A function that receives the previous element and returns\n     * the new element. The function is only called if the index is valid\n     *\n     * @returns The previous element at the index, or `undefined` if index is invalid\n     */\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.array.length) {\n            return undefined;\n        }\n        const value = this.array[index];\n        this.array[index] = callback(value);\n        return value;\n    }\n    /**\n     * Retrieves and removes the end of the list\n     *\n     * @returns The element at the end of the list, or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n    /**\n     * Inserts the specified element into the end of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns The new size of the list\n     */\n    push(element: T): number {\n        return this.array.push(element);\n    }\n    /**\n     * Retrieves and removes the element at the given index.\n     *\n     * A negative index can be used to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param index - The index to remove\n     *\n     * @returns The value at the index, or `undefined` if the index is invalid\n     */\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.array.length) {\n            return undefined;\n        }\n        return this.array.splice(index, 1)[0];\n    }\n    /**\n     * Reverses the elements in the list in place.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns a reference to the same list\n     */\n    reverse(min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.array.length);\n        max = wrap(max ?? this.array.length, 0, this.array.length);\n        if (max - min > 1) {\n            this.array.splice(min, max - min, ...this.array.slice(min, max).reverse());\n        }\n        return this;\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * A negative index can be used to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param index - The index to retrieve\n     * @param element - The new element to insert at index\n     *\n     * @returns The previous element in the index, or undefined if the index is invalid\n     */\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.array.length) {\n            return undefined;\n        }\n        const prev = this.array[index];\n        this.array[index] = element;\n        return prev;\n    }\n    /**\n     * Retrieves and removes the first element in the list\n     *\n     * @returns The element at the front of the list or `undefined` if this list is empty.\n     */\n    shift(): T | undefined {\n        return this.array.shift();\n    }\n    /**\n     * The number of elements in this list\n     */\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Returns a copy of a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns A new list with a copy of the indicated section of the original list\n     */\n    slice(min?: number, max?: number): ArrayList<T> {\n        return new ArrayList(this.array.slice(min, max));\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n    /**\n     * Inserts the specified element into the front of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns The new size of the list\n     */\n    unshift(element: T): number {\n        return this.array.unshift(element);\n    }\n    /**\n     * Receive an iterator through a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns An iterator through the indicated section of the list\n     */\n    *view(min?: number, max?: number): Iterable<T> {\n        min = wrap(min ?? 0, 0, this.array.length);\n\n        let len = () => Math.min(max!, this.array.length);\n        if (max == null) {\n            len = () => this.array.length;\n        } else if (max < 0) {\n            len = () => this.array.length + max!;\n        }\n\n        while (min < len()) {\n            yield this.array[min++];\n        }\n    }\n}\n","import { List } from './list';\nimport { wrap } from '../utils';\n\n/**\n * A doubly-linked node version of the {@link LinkedNode} interface.\n *\n * Each node links to its neighbors on the left (prev) and right (next) of it.\n */\nexport interface DoublyLinkedNode<T> {\n    /**\n     * A link to the node's next (right) neighbor\n     */\n    next?: DoublyLinkedNode<T>;\n    /**\n     * A link to the node's previous (left) neighbor\n     */\n    prev?: DoublyLinkedNode<T>;\n    /**\n     * The value of the node\n     */\n    value: T;\n}\n/**\n * A (circular) doubly-linked list implementation of the {@link List} interface.\n *\n * Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.\n */\nexport class DoublyLinkedList<T> implements List<T> {\n    /**\n     * @ignore\n     * The number of elements in this list\n     */\n    protected length: number;\n    /**\n     * @ignore\n     * The first node in the list\n     */\n    protected root: DoublyLinkedNode<T>;\n\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as DoublyLinkedNode<T>;\n        this.root.prev = this.root.next = this.root;\n        for (const element of elements || []) {\n            this.push(element);\n        }\n    }\n    /**\n     * Add the element at the specified index.\n     *\n     * @param index - The index to add into (0 <= index <= size)\n     * @param element - The element to add\n     *\n     * @returns The new size of the list\n     */\n    add(index: number, value: T): number {\n        if (index < 0 || index > this.length) {\n            return this.length;\n        }\n        const prev = this._get(index - 1);\n        const node = { next: prev.next, prev, value };\n        prev.next = node;\n        node.next!.prev = node;\n        return ++this.length;\n    }\n    /**\n     * Add elements at the specified index.\n     *\n     * @param index - The index to add into (0 <= index <= size)\n     * @param element - The elements to add\n     *\n     * @returns The new size of the list\n     */\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index < 0 || index > this.length) {\n            return this.length;\n        }\n        let prev = this._get(index - 1);\n        const next = prev.next!;\n        for (const value of elements) {\n            const node = { prev, value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        next.prev = prev;\n        return this.length;\n    }\n    /**\n     * Removes all elements\n     */\n    clear(): void {\n        this.length = 0;\n        this.root.prev = this.root.next = this.root;\n    }\n    /**\n     * Combines the list with multiple iterables into a new list.\n     * Does not modify the existing list or inputs.\n     *\n     * @param lists — Additional iterables to add to the end of the list.\n     *\n     * @returns A new list consisting of the elements in the list on which\n     * it is called, followed in order by the elements of each argument. It\n     * does not recurse into nested iterable arguments\n     */\n    concat(...lists: Iterable<T>[]): DoublyLinkedList<T> {\n        const out = new DoublyLinkedList(this);\n        for (const list of lists) {\n            for (const element of list) {\n                out.push(element);\n            }\n        }\n        return out;\n    }\n    /**\n     * Copies a section of the list identified by min and max to the same array at position index.\n     *\n     * Negative indices can be used for index, min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * Note that this method will not change the size of the list. If index is after min,\n     * the copied sequence will be trimmed to fit list.size\n     *\n     * @param index - Where to copy the sequence to\n     * @param min - Where to start copying elements from, inclusive. Defaults to 0\n     * @param max - Where to end copying elements from, exclusive. Defaults to list.size\n     *\n     * @returns The list\n     */\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to the same section\n        index = wrap(index, 0, this.length);\n        min = wrap(min ?? 0, 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = wrap(max ?? this.length, 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Check for overlap edge case\n        if (min < index && index < max) {\n            let nodeA = this._get(max);\n            let nodeB = this._get(index + (max - min));\n            do {\n                nodeA = nodeA.prev!;\n                nodeB = nodeB.prev!;\n                nodeB.value = nodeA.value;\n            } while (min < --max);\n            return this;\n        }\n\n        // Copy the section to the destination\n        let nodeA = this._get(min);\n        let nodeB = this._get(index);\n        do {\n            nodeB.value = nodeA.value;\n            nodeA = nodeA.next!;\n            nodeB = nodeB.next!;\n        } while (++min < max);\n        return this;\n    }\n    /**\n     * Returns the this object after filling the section identified by min and max with element.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param element — element to fill list section with\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param end - Where to stop filling the list, exclusive. Defaults to list.size\n     *\n     * @returns The list on which this method was called\n     */\n    fill(element: T, min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.length);\n        max = wrap(max ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n    /**\n     * Return the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     *\n     * @returns The element at the index, or `undefined` if index is invalid\n     */\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.length ? undefined : this._get(index).value;\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     * @param callback - A function that receives the previous element and returns\n     * the new element. The function is only called if the index is valid\n     *\n     * @returns The previous element at the index, or `undefined` if index is invalid\n     */\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n    /**\n     * Retrieves and removes the end of the list\n     *\n     * @returns The element at the end of the list, or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const tail = this.root.prev!;\n        tail.prev!.next = this.root;\n        this.root.prev = tail.prev;\n        --this.length;\n        return tail.value;\n    }\n    /**\n     * Inserts the specified element into the end of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns `true` upon success, otherwise `false`\n     */\n    push(value: T): number {\n        const tail = this.root.prev!;\n        const node = { next: this.root, prev: tail, value };\n        tail.next = this.root.prev = node;\n        return ++this.length;\n    }\n    /**\n     * Retrieves and removes the element at the given index.\n     *\n     * @param index - The index to remove (0 <= index < size)\n     *\n     * @returns The value at the index, or `undefined` if the index is invalid\n     */\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        node.prev!.next = node.next;\n        node.next!.prev = node.prev;\n        --this.length;\n        return node.value;\n    }\n    /**\n     * Reverses the elements in the list in place.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns a reference to the same list\n     */\n    reverse(min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.length);\n        max = wrap(max ?? this.length, 0, this.length);\n        if (max - min > 1) {\n            const root = this._get(min - 1);\n            const tail = root.next!;\n            let node = tail;\n            do {\n                const temp = node.next!;\n                node.next = node.prev;\n                node.prev = temp;\n                root.next = node;\n                node = temp;\n            } while (++min < max);\n            tail.next = node;\n            node.prev = tail;\n            root.next!.prev = root;\n        }\n        return this;\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     * @param element - The new element to insert at index\n     *\n     * @returns The previous element in the index, or undefined if the index is invalid\n     */\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const prev = node.value;\n        node.value = element;\n        return prev;\n    }\n    /**\n     * Retrieves and removes the first element in the list\n     *\n     * @returns The element at the front of the list or `undefined` if this list is empty.\n     */\n    shift(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const head = this.root.next!;\n        head.next!.prev = this.root;\n        this.root.next = head.next;\n        --this.length;\n        return head.value;\n    }\n    /**\n     * The number of elements in this list\n     */\n    get size(): number {\n        return this.length;\n    }\n    /**\n     * Returns a copy of a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns A new list with a copy of the indicated section of the original list\n     */\n    slice(min?: number, max?: number): DoublyLinkedList<T> {\n        return new DoublyLinkedList(this.view(min, max));\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        let node = this.root;\n        for (let i = 0; i < this.length; ++i) {\n            node = node.next!;\n            yield node.value;\n        }\n    }\n    /**\n     * Inserts the specified element into the front of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns `true` upon success, otherwise `false`\n     */\n    unshift(value: T): number {\n        const head = this.root.next!;\n        const node = { next: head, prev: this.root, value };\n        this.root.next = head.prev = node;\n        return ++this.length;\n    }\n    /**\n     * Receive an iterator through a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns An iterator through the indicated section of the list\n     */\n    *view(min?: number, max?: number): Iterable<T> {\n        min = wrap(min ?? 0, 0, this.length);\n\n        let len = () => Math.min(max!, this.length);\n        if (max == null) {\n            len = () => this.length;\n        } else if (max < 0) {\n            len = () => this.length + max!;\n        }\n\n        if (min < len()) {\n            let prev = this._get(min);\n            do {\n                yield prev.value;\n                prev = prev.next!;\n            } while (++min < len());\n        }\n    }\n    /**\n     * @ignore\n     * A helper method to iterate and return the node at the given index.\n     *\n     * Depending on the index, the list will be traversed from beginning or end; whichever is closest to the specified index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number): DoublyLinkedNode<T> {\n        let node = this.root;\n        if (index < this.length / 2) {\n            while (index-- >= 0) {\n                node = node.next!;\n            }\n        } else {\n            for (index = this.length - index; index > 0; --index) {\n                node = node.prev!;\n            }\n        }\n        return node;\n    }\n}\n","import { List } from './list';\nimport { wrap } from '../utils';\n\n/**\n * A linked node interface.\n *\n * Each node links to its next neighbor.\n */\nexport interface LinkedNode<T> {\n    /**\n     * A link to the node's neighbor\n     */\n    next?: LinkedNode<T>;\n    /**\n     * The value of the node\n     */\n    value: T;\n}\n/**\n * A (circular) linked list implementation of the {@link List} interface.\n */\nexport class LinkedList<T> implements List<T> {\n    /**\n     * @ignore\n     */\n    protected length: number;\n    /**\n     * @ignore\n     */\n    protected root: LinkedNode<T>;\n    /**\n     * @ignore\n     */\n    protected tail: LinkedNode<T>;\n\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as LinkedNode<T>;\n        this.tail = this.root.next = this.root;\n        for (const element of elements || []) {\n            this.push(element);\n        }\n    }\n    /**\n     * Add the element at the specified index.\n     *\n     * @param index - The index to add into (0 <= index <= size)\n     * @param element - The element to add\n     *\n     * @returns The new size of the list\n     */\n    add(index: number, value: T): number {\n        if (index < 0 || index >= this.length) {\n            return index == this.length ? this.push(value) : this.length;\n        }\n        const prev = this._get(index - 1);\n        prev.next = { value, next: prev.next };\n        return ++this.length;\n    }\n    /**\n     * Add elements at the specified index.\n     *\n     * @param index - The index to add into (0 <= index <= size)\n     * @param element - The elements to add\n     *\n     * @returns The new size of the list\n     */\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index < 0 || index >= this.length) {\n            if (index == this.length) {\n                for (const element of elements) {\n                    this.push(element);\n                }\n            }\n            return this.length;\n        }\n        let prev = this._get(index - 1);\n        const next = prev.next!;\n        for (const value of elements) {\n            const node = { value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        return this.length;\n    }\n    /**\n     * Removes all elements\n     */\n    clear(): void {\n        this.length = 0;\n        this.tail = this.root.next = this.root;\n    }\n    /**\n     * Combines the list with multiple iterables into a new list.\n     * Does not modify the existing list or inputs.\n     *\n     * @param lists — Additional iterables to add to the end of the list.\n     *\n     * @returns A new list consisting of the elements in the list on which\n     * it is called, followed in order by the elements of each argument. It\n     * does not recurse into nested iterable arguments\n     */\n    concat(...lists: Iterable<T>[]): LinkedList<T> {\n        const out = new LinkedList(this);\n        for (const list of lists) {\n            for (const element of list) {\n                out.push(element);\n            }\n        }\n        return out;\n    }\n    /**\n     * Copies a section of the list identified by min and max to the same array at position index.\n     *\n     * Negative indices can be used for index, min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * Note that this method will not change the size of the list. If index is after min,\n     * the copied sequence will be trimmed to fit list.size\n     *\n     * @param index - Where to copy the sequence to\n     * @param min - Where to start copying elements from, inclusive. Defaults to 0\n     * @param max - Where to end copying elements from, exclusive. Defaults to list.size\n     *\n     * @returns The list\n     */\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to the same section\n        index = wrap(index, 0, this.length);\n        min = wrap(min ?? 0, 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = wrap(max ?? this.length, 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Check for overlap edge case\n        if (min < index && index < max) {\n            let prev = this._get(index - 1);\n            this._reverse(prev, max - min);\n            prev = this._copyWithin(this._get(min - 1), prev, index - min);\n            this._reverse(prev, max - index);\n            return this;\n        }\n\n        // Copy the section to the destination\n        this._copyWithin(this._get(min - 1), this._get(index - 1), max - min);\n        return this;\n    }\n    /**\n     * Returns the this object after filling the section identified by min and max with element.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param element — element to fill list section with\n     * @param min - Where to start filling the list, inclusive. Defaults to 0\n     * @param end - Where to stop filling the list, exclusive. Defaults to list.size\n     *\n     * @returns The list on which this method was called\n     */\n    fill(element: T, min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.length);\n        max = wrap(max ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n    /**\n     * Return the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     *\n     * @returns The element at the index, or `undefined` if index is invalid\n     */\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.length ? undefined : this._get(index).value;\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     * @param callback - A function that receives the previous element and returns\n     * the new element. The function is only called if the index is valid\n     *\n     * @returns The previous element at the index, or `undefined` if index is invalid\n     */\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n    /**\n     * Retrieves and removes the end of the list\n     *\n     * @returns The value at the end of the list, or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        return this.remove(this.length - 1);\n    }\n    /**\n     * Inserts the specified value into the end of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns `true` upon success, otherwise `false`\n     */\n    push(value: T): number {\n        const tail: LinkedNode<T> = { value } as LinkedNode<T>;\n        tail.next = this.root;\n        this.tail.next = tail;\n        this.tail = tail;\n        return ++this.length;\n    }\n    /**\n     * Retrieves and removes the element at the given index.\n     *\n     * @param index - The index to remove (0 <= index < size)\n     *\n     * @returns The value at the index, or `undefined` if the index is invalid\n     */\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const prev = this._get(index - 1);\n        const node = prev.next!;\n        prev.next = node.next;\n        --this.length;\n        return node.value;\n    }\n    /**\n     * Reverses the elements in the list in place.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns a reference to the same list\n     */\n    reverse(min?: number, max?: number): this {\n        min = wrap(min ?? 0, 0, this.length);\n        max = wrap(max ?? this.length, 0, this.length);\n        if (max - min > 1) {\n            const prev = this._get(min - 1);\n            this.tail = max >= this.length ? prev.next! : this.tail;\n            this._reverse(prev, max - min);\n        }\n        return this;\n    }\n    /**\n     * Update the element at the specified index.\n     *\n     * @param index - The index to retrieve (0 <= index < size)\n     * @param element - The new element to insert at index\n     *\n     * @returns The previous element in the index, or undefined if the index is invalid\n     */\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n    /**\n     * Retrieves and removes the first element in the list\n     *\n     * @returns The value at the front of the list or `undefined` if this list is empty.\n     */\n    shift(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const head = this.root.next!;\n        this.root.next = head.next;\n        --this.length;\n        return head.value;\n    }\n    /**\n     * The number of elements in this list\n     */\n    get size(): number {\n        return this.length;\n    }\n    /**\n     * Returns a copy of a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns A new list with a copy of the indicated section of the original list\n     */\n    slice(min?: number, max?: number): LinkedList<T> {\n        return new LinkedList(this.view(min, max));\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        let node = this.root;\n        for (let i = 0; i < this.length; ++i) {\n            node = node!.next!;\n            yield node.value;\n        }\n    }\n    /**\n     * Inserts the specified value into the front of the list\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns `true` upon success, otherwise `false`\n     */\n    unshift(value: T): number {\n        const head: LinkedNode<T> = { value } as LinkedNode<T>;\n        head.next = this.root.next;\n        this.root.next = head;\n        return ++this.length;\n    }\n    /**\n     * Receive an iterator through a section of the list.\n     *\n     * Negative indices can be used for min and max to indicate an offset from the\n     * end of the list. For example, -2 refers to the second to last element of the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @param min - The beginning index of the specified portion of the list, inclusive. Defaults to 0\n     * @param max - The end index of the specified portion of the list, exclusive. Defaults to list.size\n     *\n     * @returns An iterator through the indicated section of the list\n     */\n    *view(min?: number, max?: number): Iterable<T> {\n        min = wrap(min ?? 0, 0, this.length);\n\n        let len = () => Math.min(max!, this.length);\n        if (max == null) {\n            len = () => this.length;\n        } else if (max < 0) {\n            len = () => this.length + max!;\n        }\n\n        if (min < len()) {\n            let prev = this._get(min);\n            do {\n                yield prev.value;\n                prev = prev.next!;\n            } while (++min < len());\n        }\n    }\n    /**\n     * @ignore\n     * Copy values from 'from' to 'to'.\n     *\n     * @param from - The initial node to copy from\n     * @param prev - The root of the initial node to copy to\n     * @param count - The number of values to copy\n     */\n    protected _copyWithin(from: LinkedNode<T>, to: LinkedNode<T>, count: number): LinkedNode<T> {\n        while (count-- > 0) {\n            from = from.next!;\n            to = to.next!;\n            to.value = from.value;\n        }\n        return to;\n    }\n    /**\n     * @ignore\n     * Get the node at the given index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number): LinkedNode<T> {\n        let node = this.root!;\n        while (index-- >= 0) {\n            node = node.next!;\n        }\n        return node;\n    }\n    /**\n     * @ignore\n     * Reverse 'count' nodes beginning from 'node'\n     *\n     * @param node - The initial node to reverse from\n     * @param count - The number of values to reverse\n     *\n     * @returns\n     */\n    protected _reverse(root: LinkedNode<T>, count: number): void {\n        const tail = root.next!;\n        let prev = tail;\n        let node = tail.next!;\n        while (--count > 0) {\n            const next = node.next!;\n            node.next = prev;\n            prev = node;\n            node = next;\n        }\n        root.next = prev;\n        tail.next = node;\n    }\n}\n","import { Queue } from './queue';\n\n/**\n * An implementation of the {@link Queue} interface using an array\n */\nexport class ArrayQueue<T> implements Queue<T> {\n    /**\n     * @ignore\n     */\n    protected array: T[];\n\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n    /**\n     * Removes all elements from this queue\n     */\n    clear(): void {\n        this.array.length = 0;\n    }\n    /**\n     * Retrieves and removes the head of this queue\n     *\n     * @returns The element at the head of the queue or `undefined` if this queue is empty.\n     */\n    dequeue(): T | undefined {\n        return this.size < 1 ? undefined : this.array.shift();\n    }\n    /**\n     * Inserts the specified element into this queue\n     *\n     * @param element - The element to be inserted\n     */\n    enqueue(element: T): number {\n        return this.array.push(element);\n    }\n    /**\n     * Retrieves, but does not remove, the head of this queue\n     *\n     * @returns The value at the head of the queue or `undefined` if this queue is empty.\n     */\n    peek(): T | undefined {\n        return this.size < 1 ? undefined : this.array[0];\n    }\n    /**\n     * The number of elements in this queue\n     */\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Queue } from './queue';\n\n/**\n * A linked list implementation of the {@link Queue} interface\n */\nexport class LinkedQueue<T> implements Queue<T> {\n    /**\n     * @ignore\n     */\n    protected list: List<T>;\n\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList(elements);\n    }\n    /**\n     * Removes all elements from this queue\n     */\n    clear(): void {\n        this.list.clear();\n    }\n    /**\n     * Retrieves and removes the head of this queue\n     *\n     * @returns The element at the head of the queue or `undefined` if this queue is empty.\n     */\n    dequeue(): T | undefined {\n        return this.list.shift();\n    }\n    /**\n     * Inserts the specified element into this queue\n     *\n     * @param element - The element to be inserted\n     */\n    enqueue(element: T): number {\n        return this.list.push(element);\n    }\n    /**\n     * Retrieves, but does not remove, the head of this queue\n     *\n     * @returns The element at the head of the queue or `undefined` if this queue is empty.\n     */\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n    /**\n     * The number of elements in this queue\n     */\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","import { Stack } from './stack';\n\n/**\n * An implementation of the {@link Stack} interface using an array\n */\nexport class ArrayStack<T> implements Stack<T> {\n    /**\n     * @ignore\n     */\n    protected array: T[];\n\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n    /**\n     * Removes all elements from the stack\n     */\n    clear(): void {\n        this.array.length = 0;\n    }\n    /**\n     * Retrieves, but does not remove, the top of the stack\n     *\n     * @returns The element at the top of the stack or `undefined` if empty.\n     */\n    peek(): T | undefined {\n        return this.array[this.array.length - 1];\n    }\n    /**\n     * Retrieves and removes the top of the stack\n     *\n     * @returns The element at the top of the stack or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n    /**\n     * Inserts a element into the stack\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns The new size of the stack\n     */\n    push(element: T): number {\n        return this.array.push(element);\n    }\n    /**\n     * The number of elements in the stack\n     */\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        const array = this.array;\n        for (let i = array.length; i > 0; yield array[--i]) {}\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Stack } from './stack';\n\n/**\n * A linked list implementation of the {@link Stack} interface\n */\nexport class LinkedStack<T> implements Stack<T> {\n    /**\n     * @ignore\n     */\n    protected list: List<T>;\n\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList();\n        for (const element of elements || []) {\n            this.push(element);\n        }\n    }\n    /**\n     * Removes all elements from the stack\n     */\n    clear(): void {\n        this.list.clear();\n    }\n    /**\n     * Retrieves, but does not remove, the top of the stack\n     *\n     * @returns The element at the top of the stack or `undefined` if empty.\n     */\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n    /**\n     * Retrieves and removes the top of the stack\n     *\n     * @returns The element at the top of the stack or `undefined` if empty.\n     */\n    pop(): T | undefined {\n        return this.list.shift();\n    }\n    /**\n     * Inserts a element into the stack\n     *\n     * @param element - The element to be inserted\n     *\n     * @returns The new size of the stack\n     */\n    push(element: T): number {\n        return this.list.unshift(element);\n    }\n    /**\n     * The number of elements in the stack\n     */\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","/**\n * @ignore\n */\nexport function wrap(index: number, min: number, max: number): number {\n    return Math.min(max, Math.max(min, index < 0 ? max + index : index));\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}