{"version":3,"sources":["webpack://Dastal/webpack/universalModuleDefinition","webpack://Dastal/webpack/bootstrap","webpack://Dastal/webpack/runtime/define property getters","webpack://Dastal/webpack/runtime/hasOwnProperty shorthand","webpack://Dastal/webpack/runtime/make namespace object","webpack://Dastal/./src/array/utils.ts","webpack://Dastal/./src/heap/utils.ts","webpack://Dastal/./src/heap/binaryHeap.ts","webpack://Dastal/./src/tree/binaryTreeUtils.ts","webpack://Dastal/./src/heap/skewHeap.ts","webpack://Dastal/./src/math/num.ts","webpack://Dastal/./src/list/utils.ts","webpack://Dastal/./src/list/arrayList.ts","webpack://Dastal/./src/list/doublyLinkedList.ts","webpack://Dastal/./src/list/linkedList.ts","webpack://Dastal/./src/math/u32.ts","webpack://Dastal/./src/queue/arrayQueue.ts","webpack://Dastal/./src/queue/linkedQueue.ts","webpack://Dastal/./src/segmentTree/inOrderSegmentTree.ts","webpack://Dastal/./src/segmentTree/levelOrderSegmentTree.ts","webpack://Dastal/./src/collection/index.ts","webpack://Dastal/./src/stack/arrayStack.ts","webpack://Dastal/./src/stack/linkedStack.ts","webpack://Dastal/./src/tree/aaTree.ts","webpack://Dastal/./src/tree/avlTree.ts"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","MAX_ARRAY_LENGTH","isArray","Array","isTypedArray","TypedArray","getPrototypeOf","Uint8Array","bubbleUp","index","compareFn","array","parentIndex","Math","floor","parent","heapify","i","length","sinkDown","n","childIndex","child","skewMerge","heaps","lists","push","list","tree","right","next","compare","a","b","tail","pop","mergeKSorted","heap","node","left","iterator","BinaryHeap","elements","this","addAll","RangeError","element","indexOf","last","size","undefined","curElement","newElement","inOrderTraverse","preOrderTraverse","removeStack","stack","dir","edge","to","temp","successorStack","predecessorStack","from","label","clone","out","assign","leftmost","leftmostStack","rightmostStack","rightmost","search","comp","searchStack","dupeWeight","paths","toBinaryTree","nodes","par","SkewHeap","merge","comparator","clamp","num","min","max","batchArray","batchIterable","batch","iterable","slice","f","cwrap","pivot","nwrap","linkedMergeSort","len","isDoubly","lens","ceil","heads","tails","prev","linkedMergeSorted","ArrayList","splice","items","copyWithin","fill","callback","shift","start","count","sort","unshift","arguments","DoublyLinkedList","_addAll","_get","nodeA","nodeB","head","view","LinkedList","_copyWithin","nodeC","nodeD","remove","deleted","newTail","add","bitsSet","invert","msp","u32","isPow2","lsb","lsp","lsps","mlsp","msb","msps","reverse","ArrayQueue","LinkedQueue","clear","InOrderSegmentTree","combine","build","mask","MAX_SIZE","set","offset","operation","dc","dp","LevelOrderSegmentTree","level","shrink","grow","aggregate","cap","ArrayStack","LinkedStack","AATree","allowDuplicates","sentinel","split","skew","removed","delete","AVLTree","balanceFactor","balance","rotateR","rotateL","P","R","L"],"mappings":"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","file":"dastal.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Dastal\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Dastal\"] = factory();\n\telse\n\t\troot[\"Dastal\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * The maximum length of an array.\n *\n * According to [ECMA-262](https://tc39.es/ecma262/#array-index):\n *     0 <= array.length <= 2^32 - 1\n */\nexport const MAX_ARRAY_LENGTH = 4294967295;\n/**\n * Check if a value is an Array or TypedArray.\n *\n * @param obj - The value to check.\n *\n * @returns `true` if an Array or TypedArray, otherwise `false`.\n */\nexport function isArray<T = any>(obj: unknown): obj is T[] {\n    return obj instanceof Array || isTypedArray(obj);\n}\n/**\n * Check if a value is a TypedArray.\n *\n * See [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)\n * for more details.\n *\n * @param obj - The value to check.\n *\n * @returns `true` if a TypedArray, otherwise `false`.\n */\nexport const isTypedArray = (() => {\n    const TypedArray = Object.getPrototypeOf(Uint8Array);\n    return function isTypedArray<T = any>(obj: unknown): obj is T[] {\n        return obj instanceof TypedArray;\n    };\n})();\n","import { LinkedNode } from 'src/list';\nimport { BinaryTreeNode } from 'src/tree/binaryTreeNode';\nimport { CompareFn } from '..';\n\n/**\n * @internal\n */\nexport function bubbleUp<T>(index: number, compareFn: CompareFn<T>, array: Array<T>): void {\n    const value = array[index];\n\n    // Until we reach the top of the heap\n    while (index > 0) {\n        // Get the parent\n        const parentIndex = Math.floor((index + 1) / 2) - 1;\n        const parent = array[parentIndex]!;\n\n        // If the parent is above or equal to value, the heap is in order\n        if (compareFn(parent, value) <= 0) {\n            break;\n        }\n\n        // Swap the parent with value and continue\n        array[parentIndex] = value;\n        array[index] = parent;\n        index = parentIndex;\n    }\n}\n/**\n * @internal\n */\nexport function heapify<T>(compareFn: CompareFn<T>, array: T[]): void {\n    for (let i = (array.length + 1) >>> 1; i > 0; sinkDown(--i, compareFn, array)) {}\n}\n/**\n * @internal\n */\nexport function mergeKSorted<T>(compareFn: CompareFn<T>, lists: LinkedNode<T>[]): LinkedNode<T> {\n    // Heapify the list of lists based on\n    // the value at the head of each list.\n    const compare: CompareFn<LinkedNode<T>> = (a, b) => compareFn(a.value, b.value);\n    heapify(compare, lists);\n\n    // Combine the lists into a single list.\n    const list: LinkedNode<T> = lists[0];\n    for (let tail = list; lists.length > 1; tail = tail.next) {\n        lists[0] = lists[0].next ?? lists.pop()!;\n        sinkDown(0, compare, lists);\n        tail.next = lists[0];\n    }\n\n    return list;\n}\n/**\n * @internal\n */\nexport function sinkDown<T>(index: number, compareFn: CompareFn<T>, array: Array<T>): void {\n    const n = array.length;\n    const value = array[index];\n    do {\n        // Compute the left child's index\n        let childIndex = 2 * index + 1;\n\n        // If no children exist\n        if (childIndex >= n) {\n            break;\n        }\n\n        // Decide which child to compare with\n        let child = array[childIndex];\n        if (childIndex + 1 < n && compareFn(array[childIndex + 1], child) <= 0) {\n            child = array[++childIndex]!;\n        }\n\n        // If value <= child\n        if (compareFn(value, child) <= 0) {\n            break;\n        }\n\n        // Swap value and child\n        array[index] = child;\n        array[childIndex] = value;\n        index = childIndex;\n    } while (true);\n}\n/**\n * See: https://en.wikipedia.org/wiki/Skew_heap#Merging_two_heaps\n *\n * @param compareFn - A function used to determine the order of the heap.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n * @param heaps - An iterable of heaps to merge\n *\n * @returns The new heap\n */\nexport function skewMerge<T>(\n    compareFn: CompareFn<T>,\n    heaps: (BinaryTreeNode<T> | undefined)[],\n): BinaryTreeNode<T> | undefined {\n    // Remove undefineds and initialize a list for each heap\n    const lists: LinkedNode<BinaryTreeNode<T>>[] = [];\n    for (let i = 0; i < heaps.length; ++i) {\n        if (heaps[i] != null) {\n            lists.push({ value: heaps[i]! });\n        }\n    }\n\n    // Check if nothing to merge with\n    if (lists.length < 2) {\n        return lists[0]?.value;\n    }\n\n    // Split each heap into subheaps by cutting every right path; From the root\n    // node, sever the right node to make the right child its own heap. Repeat\n    // until you can't go right. This will turn each heap into a list of heaps\n    // where the root either only has a left child or no children at all. The\n    // lists of heaps will be in desc order (from bottom to top).\n    for (let i = 0; i < lists.length; ++i) {\n        let list = lists[i];\n        let tree: BinaryTreeNode<T> | undefined = list.value;\n        while ((tree = tree.right)) {\n            list = { next: list, value: tree };\n        }\n        lists[i] = list;\n    }\n\n    // Combine the lists into a single list in desc order\n    let list: LinkedNode<BinaryTreeNode<T>> | undefined = mergeKSorted(\n        (a, b) => compareFn(b.value, a.value),\n        lists,\n    );\n\n    // While there are still multiple heaps, iteratively combine\n    // the first two (from left to right). If the root of the second-to-first\n    // subtree has a left child, swap it to be the right child. Link the root\n    // of the last subtree as the left child of the second-to-first subtree.\n    let heap = list.value;\n    while ((list = list.next)) {\n        const node = list.value;\n        node.right = node.left;\n        node.left = heap;\n        heap = node;\n    }\n\n    return heap;\n}\n","import { isArray, MAX_ARRAY_LENGTH } from 'src/array/utils';\nimport { CompareFn } from '..';\nimport { Heap } from './heap';\nimport { bubbleUp, heapify, sinkDown } from './utils';\n\n/**\n * A binary heap is a heap implemented as a binary tree with an additional shape property\n * ([source](https://en.wikipedia.org/wiki/Binary_heap)).\n *\n * **Shape property**: Must be a complete binary tree. This means all levels of the tree\n * (except possibly the last one) are fully filled. If the last level of the tree is incomplete,\n * the nodes of that level are filled from left to right.\n *\n * #### Complexity\n *\n * | Property | Average | Worst |\n * | :------- | :------ | :---- |\n * | Space    | O(n)    | O(n)\n * | Push     | O(1)    | O(log n)\n * | Peek     | O(1)\t| O(1)\n * | Pop      | O(log n)| O(log n)\n * | Search   | O(n)    | O(n)\n */\nexport class BinaryHeap<T> implements Heap<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * Instantiate a heap.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>) {\n        this.compare = compareFn;\n        this.array = [];\n        this.addAll(elements ?? []);\n    }\n\n    addAll(elements: Iterable<T>): number {\n        const array = this.array;\n        const length = array.length;\n\n        if (isArray(elements)) {\n            if (array.length + elements.length > MAX_ARRAY_LENGTH) {\n                throw new RangeError('Invalid heap length');\n            }\n            for (let i = 0; i < elements.length; ++i) {\n                array.push(elements[i]);\n            }\n        } else {\n            for (const element of elements) {\n                if (array.length >= MAX_ARRAY_LENGTH) {\n                    throw new RangeError('Invalid heap length');\n                }\n                array.push(element);\n            }\n        }\n\n        // Update the heap\n        if (length < array.length) {\n            heapify(this.compare, array);\n        }\n\n        return array.length;\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        return this.array.indexOf(element) >= 0;\n    }\n\n    delete(element: T): boolean {\n        const index = this.array.indexOf(element);\n        if (index < 0) {\n            return false;\n        }\n\n        // If deleting the last value\n        const last = this.array.pop()!;\n        if (index >= this.array.length) {\n            return true;\n        }\n\n        // Add the last value to the\n        // deleted index and update the heap\n        this.array[index] = last;\n        sinkDown(index, this.compare, this.array);\n        bubbleUp(index, this.compare, this.array);\n        return true;\n    }\n\n    merge(heap: Heap<T>): this {\n        const array = this.array;\n\n        if (heap.size < 1) {\n            return this;\n        }\n\n        if (array.length + heap.size > MAX_ARRAY_LENGTH) {\n            throw new RangeError('Invalid heap length');\n        }\n\n        for (const element of heap) {\n            array.push(element);\n        }\n\n        heapify(this.compare, array);\n        return this;\n    }\n\n    peek(): T | undefined {\n        return this.array.length > 0 ? this.array[0] : undefined;\n    }\n\n    pop(): T | undefined {\n        if (this.array.length < 1) {\n            return undefined;\n        }\n\n        // Get the root and the last value\n        const value = this.array[0];\n        const last = this.array.pop();\n\n        // If value != last\n        if (this.array.length > 0) {\n            // Move the last value to the root and update the heap\n            this.array[0] = last!;\n            sinkDown(0, this.compare, this.array);\n        }\n\n        return value;\n    }\n\n    push(value: T): number {\n        // Add new value to the end of the heap\n        this.array.push(value);\n\n        // Update the heap\n        bubbleUp(this.array.length - 1, this.compare, this.array);\n        return this.size;\n    }\n\n    pushPop(value: T): T {\n        // If empty or value is <= to root\n        if (this.array.length < 1 || this.compare(value, this.array[0]) <= 0) {\n            return value;\n        }\n\n        // Swap the root and value\n        const root = this.array[0];\n        this.array[0] = value;\n        sinkDown(0, this.compare, this.array);\n        return root;\n    }\n\n    replace(value: T): T | undefined {\n        // If empty\n        if (this.array.length < 1) {\n            this.array.push(value);\n            return undefined;\n        }\n\n        // Swap the root with value\n        const root = this.array[0];\n        this.array[0] = value;\n        value = root;\n\n        // Update the heap\n        sinkDown(0, this.compare, this.array);\n        return value;\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    *sorted(): Iterable<T> {\n        if (this.array.length < 1) {\n            return;\n        }\n        const array = this.array;\n        const heap = new BinaryHeap<number>((a, b) => this.compare(array[a], array[b]), [0]);\n        do {\n            let index = heap.pop()!;\n            if (index < array.length) {\n                yield array[index];\n                index = 2 * index + 1;\n                index < array.length && heap.push(index);\n                ++index < array.length && heap.push(index);\n            }\n        } while (heap.size > 0);\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        const index = this.array.indexOf(curElement);\n        if (index < 0) {\n            return false;\n        }\n        this.array[index] = newElement;\n        sinkDown(index, this.compare, this.array);\n        bubbleUp(index, this.compare, this.array);\n        return true;\n    }\n}\n","import { LinkedNode } from 'src/list';\nimport { CompareFn } from '..';\nimport { BinaryTreeNode } from './binaryTreeNode';\n\n/**\n * @internal\n */\nexport interface Edge<Node extends BinaryTreeNode<unknown>> {\n    label?: 'left' | 'right';\n    from?: Node;\n    to?: Node;\n}\n/**\n * [source](https://stackoverflow.com/questions/51419176/how-to-get-a-subset-of-keyof-t-whose-value-tk-are-callable-functions-in-typ)\n * \n * @internal\n *\nexport type KeyOfType<T, U> = {[K in keyof T]: T[K] extends U ? K: never}[keyof T];\n*/\n/**\n * @internal\n */\nexport function debug<N extends BinaryTreeNode<T>, T = any>(\n    root: N | undefined,\n    mapFn?: (node: N) => any,\n): void {\n    mapFn = mapFn == null ? (n) => n.value : mapFn;\n\n    // Turn the tree into an array in level-order\n    const array: string[] = [];\n    for (const node of levelOrderTraverse(root, true)) {\n        array.push(node ? `${mapFn(node)}` : '?');\n    }\n\n    // If empty\n    if (array.length < 1) {\n        console.log('<empty>\\n');\n        return;\n    }\n\n    // Find the longest value string\n    const lenV = array.reduce((p, c) => Math.max(p, c.length), 0);\n\n    // Pad each value\n    for (let i = 0; i < array.length; ++i) {\n        array[i] = pad(array[i], lenV, ' ');\n    }\n\n    // Split values into levels\n    const levels = [];\n    for (let n = 1; array.length > 0; n *= 2) {\n        levels.push(array.splice(0, n));\n    }\n\n    // Initialize formatting variables\n    let branch = '_'.repeat(1 + lenV / 2);\n    let offset = '';\n    const offsetOffset = ' '.repeat(branch.length);\n    let separator = ' '.repeat(1 + ((lenV - 1) & 1));\n    const separatorOffset = ' '.repeat(lenV);\n\n    // Build the last level\n    array.length = levels.length;\n    array[array.length - 1] = levels.pop()!.join(separator);\n\n    // Build remaining levels in reverse\n    for (let n = levels.length - 1; n >= 0; --n) {\n        const level = levels.pop()!;\n        for (let j = 0; j < level.length; ++j) {\n            level[j] = branch + level[j] + branch;\n        }\n        array[n] = offset + level.join(separator);\n        branch += branch;\n        offset += offset + offsetOffset;\n        separator += separator + separatorOffset;\n    }\n\n    // Output\n    console.log(array.join('\\n'), '\\n');\n}\n/**\n * @internal\n */\nexport function removeStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n    dir = true,\n): LinkedNode<Edge<Node>> {\n    let edge = stack.value;\n    let node = edge.to;\n\n    // Input check\n    if (node == null) {\n        return stack;\n    }\n\n    // Find the replacement\n    if (node.right == null) {\n        // If no right child, replace with left\n        node = node.left;\n    } else if (node.left == null) {\n        // If no left child, replace with right\n        node = node.right;\n    } else if (dir) {\n        // Replace with the successor\n        stack = successorStack(stack);\n        edge = stack.value;\n        const temp = edge.to!;\n        node.value = temp.value;\n        node = temp.right;\n    } else {\n        // Replace with the predecessor\n        stack = predecessorStack(stack);\n        edge = stack.value;\n        const temp = edge.to!;\n        node.value = temp.value;\n        node = temp.left;\n    }\n\n    // Make the replacement / update the tree\n    edge.to = node;\n    if (edge.from) {\n        edge.from[edge.label!] = edge.to = node;\n    }\n\n    return stack;\n}\n/**\n * @internal\n */\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: undefined): undefined;\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: Node): Node;\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: Node | undefined): Node | undefined;\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: Node | undefined): Node | undefined {\n    if (node == null) {\n        return undefined;\n    }\n    const out: Node = Object.assign({}, node);\n    let stack: LinkedNode<Node> | undefined = { value: out };\n    do {\n        node = stack.value;\n        stack = stack.next;\n        if (node.left) {\n            stack = { next: stack, value: (node.left = Object.assign({}, node.left)) };\n        }\n        if (node.right) {\n            stack = { next: stack, value: (node.right = Object.assign({}, node.right)) };\n        }\n    } while (stack);\n    return out;\n}\n/**\n * @internal\n */\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(node: undefined): undefined;\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(node: Node): Node;\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined;\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined {\n    if (node == null) {\n        return undefined;\n    }\n    while (node.left) {\n        node = node.left;\n    }\n    return node;\n}\n/**\n * @internal\n */\nexport function leftmostStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    let node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    while (node.left) {\n        stack = { next: stack, value: { label: 'left', from: node, to: node.left } };\n        node = node.left;\n    }\n    return stack;\n}\n/**\n * @internal\n */\nexport function* inOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    let stack: LinkedNode<Node> | undefined = undefined;\n\n    while (node) {\n        stack = { next: stack, value: node };\n        node = node.left;\n    }\n\n    while (stack) {\n        node = stack.value;\n        stack = stack.next;\n        yield node;\n        node = node.right;\n        while (node) {\n            stack = { next: stack, value: node };\n            node = node.left;\n        }\n    }\n}\n/**\n * @internal\n */\nexport function levelOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n    padded?: false,\n): Generator<Node>;\nexport function levelOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n    padded: true,\n): Generator<Node | undefined>;\nexport function* levelOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n    padded = false,\n): Generator<Node | undefined> {\n    const nil = {} as LinkedNode<Node | undefined>;\n    let head: LinkedNode<Node | undefined> = { value: node };\n    let tail = head;\n    for (let cont = node != null; cont; head = head.next!) {\n        tail = tail.next = nil;\n        for (cont = false; head !== nil; head = head.next!) {\n            node = head.value;\n            if (node) {\n                yield node;\n                cont ||= node.left != null || node.right != null;\n                tail = tail.next = { value: node.left };\n                tail = tail.next = { value: node.right };\n            } else if (padded) {\n                yield undefined;\n                tail = tail.next = { value: undefined };\n                tail = tail.next = { value: undefined };\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nfunction pad(str: string, maxLen: number, fillString: string): string {\n    const len = str.length;\n    if (len >= maxLen) {\n        return str;\n    }\n    const diff = maxLen - len;\n    return str.padStart(len + diff / 2, fillString).padEnd(len + diff, fillString);\n}\n/**\n * @internal\n */\nexport function* postOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    interface Meta {\n        seen: boolean;\n        node?: Node;\n    }\n    let stack: LinkedNode<Meta> | undefined = { value: { seen: false, node } };\n    do {\n        const meta = stack.value;\n        stack = stack.next;\n        if (meta.node) {\n            if (meta.seen) {\n                yield meta.node;\n            } else {\n                meta.seen = true;\n                stack = { next: stack, value: meta };\n                stack = { next: stack, value: { seen: false, node: meta.node.right } };\n                stack = { next: stack, value: { seen: false, node: meta.node.left } };\n            }\n        }\n    } while (stack);\n}\n/**\n * @internal\n */\nexport function predecessor<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined {\n    return node == null ? undefined : rightmost(node.left);\n}\n/**\n * @internal\n */\nexport function predecessorStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    const node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    stack = { next: stack, value: { label: 'left', from: node, to: node.left } };\n    return rightmostStack(stack);\n}\n/**\n * @internal\n */\nexport function* preOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    let stack: LinkedNode<Node | undefined> | undefined = { value: node };\n    do {\n        node = stack.value;\n        stack = stack.next;\n        if (node) {\n            yield node;\n            stack = { next: stack, value: node.right };\n            stack = { next: stack, value: node.left };\n        }\n    } while (stack);\n}\n/**\n * @internal\n */\nexport function reverse<Node extends BinaryTreeNode<unknown>>(root?: Node): void {\n    if (root == null) {\n        return;\n    }\n    for (const node of preOrderTraverse(root)) {\n        const left = node.left;\n        node.left = node.right;\n        node.right = left;\n    }\n}\n/**\n * @internal\n */\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(node: undefined): undefined;\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(node: Node): Node;\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined;\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined {\n    if (node == null) {\n        return undefined;\n    }\n    while (node.right) {\n        node = node.right;\n    }\n    return node;\n}\n/**\n * @internal\n */\nexport function rightmostStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    let node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    while (node.right) {\n        stack = { next: stack, value: { label: 'right', from: node, to: node.right } };\n        node = node.right;\n    }\n    return stack;\n}\n/**\n * Assumes sorted by compareFn\n * @internal\n */\nexport function search<T, Node extends BinaryTreeNode<T>>(\n    element: T,\n    node: Node | undefined,\n    compareFn: CompareFn<T>,\n): Node | undefined {\n    while (node) {\n        const comp: number = compareFn(element, node.value);\n        if (comp == 0) {\n            break;\n        }\n        node = comp < 0 ? node.left : node.right;\n    }\n    return node;\n}\n/**\n * Assumes sorted by compareFn\n * @internal\n */\nexport function searchStack<T, Node extends BinaryTreeNode<T>>(\n    element: T,\n    stack: LinkedNode<Edge<Node>>,\n    compareFn: CompareFn<T>,\n    dupeWeight = 0,\n): LinkedNode<Edge<Node>> {\n    const paths: ['left', 'right'] = ['left', 'right'];\n    let node = stack.value.to;\n    while (node) {\n        const comp: number = compareFn(element, node.value) || dupeWeight;\n        if (comp === 0) {\n            break;\n        }\n        const label = paths[+(comp > 0)];\n        stack = { next: stack, value: { label, from: node, to: node[label] } };\n        node = node[label]!;\n    }\n    return stack;\n}\n/**\n * @internal\n */\nexport function successor<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined {\n    return node == null ? undefined : leftmost(node.right);\n}\n/**\n * @internal\n */\nexport function successorStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    const node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    stack = { next: stack, value: { label: 'right', from: node, to: node.right } };\n    return leftmostStack(stack);\n}\n/**\n * @internal\n */\nexport function toBinaryTree<T>(\n    elements: (T | undefined)[] | undefined,\n): BinaryTreeNode<T> | undefined {\n    if (elements == null || elements.length < 1 || elements[0] == null) {\n        return undefined;\n    }\n    const n = elements.length;\n    const nodes: BinaryTreeNode<T>[] = new Array(n);\n    nodes[0] = { value: elements[0] };\n    for (let i = 1; i < n; ++i) {\n        if (elements[i] == null) {\n            continue;\n        }\n        const par = nodes[(i - 1) >>> 1];\n        const node = { value: elements[i]! };\n        nodes[i] = node;\n        if (i & 1) {\n            par.left = node;\n        } else {\n            par.right = node;\n        }\n    }\n    return nodes[0];\n}\n","import { isArray } from 'src/array/utils';\nimport { BinaryTreeNode } from 'src/tree/binaryTreeNode';\nimport { clone, preOrderTraverse, toBinaryTree } from 'src/tree/binaryTreeUtils';\nimport { CompareFn } from '..';\nimport { BinaryHeap } from './binaryHeap';\nimport { Heap } from './heap';\nimport { skewMerge } from './utils';\n\n/**\n * A skew heap is a heap implemented as a binary tree\n * ([source](https://en.wikipedia.org/wiki/Skew_heap)).\n *\n * A skew heap is a self-adjusting heap which attempts to maintain balance\n * by unconditionally swapping all nodes in the merge path when merging two heaps. Every\n * operation that modifies the heap (e.g. push, pop, merge) is considered a merge and is done\n * by using a skew heap merge.\n *\n * Skew heaps can merge more quickly than binary heaps. This can seem contradictory, since\n * skew heaps have no structural constraints and no guarantee that the height of the tree is\n * logarithmic (i.e. balanced). However, amortized complexity analysis can demonstrate that\n * all operations on a skew heap can be done in O(log(n). More specifically, the\n * amortized complexity is known to be log<sub></sub>(n) where  is the golden ratio. This is\n * approximately 1.44*log<sub>2</sub>(n).\n *\n * #### Complexity\n *\n * | Property | Average  | Worst |\n * | :------- | :------  | :---- |\n * | Space    | O(n)     | O(n)\n * | Push     | O(log n) | O(log n)\n * | Peek     | O(1)\t | O(1)\n * | Pop      | O(log n) | O(log n)\n * | Search   | O(n)     | O(n)\n */\nexport class SkewHeap<T> implements Heap<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The node at the \"top\" of the heap.\n     */\n    protected root: BinaryTreeNode<T> | undefined;\n    /**\n     * Instantiate a heap.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the heap with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>) {\n        this.compare = compareFn;\n        this.length = 0;\n        this.addAll(elements ?? []);\n    }\n\n    addAll(elements: Iterable<T>): number {\n        if (isArray(elements)) {\n            for (let i = 0; i < elements.length; ++i) {\n                this.push(elements[i]);\n            }\n        } else if (elements instanceof SkewHeap || elements instanceof BinaryHeap) {\n            this.merge(elements);\n        } else {\n            for (const element of elements) {\n                this.push(element);\n            }\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.root = undefined;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        for (const node of preOrderTraverse(this.root)) {\n            if (element === node.value) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    delete(element: T): boolean {\n        if (this.root == null) {\n            return false;\n        }\n        if (this.root.value === element) {\n            this.pop()!;\n            return true;\n        }\n        for (const par of preOrderTraverse(this.root)) {\n            const key: keyof BinaryTreeNode<T> | undefined =\n                par.left && par.left.value === element\n                    ? 'left'\n                    : par.right && par.right.value === element\n                    ? 'right'\n                    : undefined;\n            if (key != null) {\n                const node = par[key]!;\n                par[key] = skewMerge(this.compare, [node.left, node.right]);\n                --this.length;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    merge(heap: Heap<T>): this {\n        if (this.compare !== heap.comparator()) {\n            this.addAll(heap);\n        } else if (heap instanceof SkewHeap) {\n            this.root = skewMerge(this.compare, [this.root, clone(heap.root)]);\n            this.length += heap.size;\n        } else if (heap instanceof BinaryHeap) {\n            this.root = skewMerge(this.compare, [this.root, toBinaryTree(heap['array'])!]);\n            this.length += heap.size;\n        } else {\n            this.addAll(heap);\n        }\n        return this;\n    }\n\n    peek(): T | undefined {\n        return this.root?.value;\n    }\n\n    pop(): T | undefined {\n        if (this.root == null) {\n            return undefined;\n        }\n        const value = this.root.value;\n        this.root = skewMerge(this.compare, [this.root.left, this.root.right]);\n        --this.length;\n        return value;\n    }\n\n    push(value: T): number {\n        this.root = skewMerge(this.compare, [this.root, { value }]);\n        return ++this.length;\n    }\n\n    pushPop(value: T): T {\n        this.push(value);\n        return this.pop()!;\n    }\n\n    replace(value: T): T | undefined {\n        if (this.root == null) {\n            this.root = { value };\n            this.length = 1;\n            return undefined;\n        }\n        const out = this.root.value;\n        this.root = skewMerge(this.compare, [this.root.left, this.root.right, { value }]);\n        return out;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        if (this.root == null) {\n            return;\n        }\n        const heap = new SkewHeap<BinaryTreeNode<T>>(\n            (a, b) => this.compare(a.value, b.value),\n            [this.root],\n        );\n        do {\n            const node = heap.pop()!;\n            yield node.value;\n            node.left && heap.push(node.left);\n            node.right && heap.push(node.right);\n        } while (heap.size > 0);\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.root == null) {\n            return false;\n        }\n\n        if (this.root.value === curElement) {\n            this.root = skewMerge(this.compare, [\n                this.root.left,\n                this.root.right,\n                { value: newElement },\n            ]);\n            return true;\n        }\n\n        let node: BinaryTreeNode<T> | undefined = undefined;\n        for (const par of preOrderTraverse(this.root)) {\n            if (par.left && par.left.value === curElement) {\n                node = par.left;\n                par.left = undefined;\n                break;\n            }\n            if (par.right && par.right.value === curElement) {\n                node = par.right;\n                par.right = undefined;\n                break;\n            }\n        }\n\n        if (node == null) {\n            return false;\n        }\n\n        this.root = skewMerge(this.compare, [\n            this.root,\n            node.left,\n            node.right,\n            { value: newElement },\n        ]);\n        return true;\n    }\n}\n","/**\n * Limits a number to be within a given range.\n *\n * f(x, min, max) = y, where min <= y <= max\n *\n * @param num - The number to clamp\n * @param min - The minimum result value, inclusive\n * @param max - The maximum result value, inclusive\n *\n * @returns The clamped number\n */\nexport function clamp(num: number, min: number, max: number): number {\n    return Math.min(max, Math.max(min, num));\n}\n","import { isArray } from '../array/utils';\nimport { CompareFn } from '..';\nimport { DoublyLinkedNode } from './doublyLinkedNode';\nimport { LinkedNode } from './linkedNode';\nimport { clamp } from 'src/math';\n\n/**\n * Groups an iterable into batches of a given size.\n *\n * @param size - The maximum batch size\n * @param iterable - The iterable to batch\n *\n * @returns An iterable of batches\n *\n * @internal\n */\nexport function batch<T>(\n    size: number,\n    iterable: Iterable<T>,\n): Generator<T[], void, number | undefined> {\n    if (isArray(iterable)) {\n        return batchArray(size, iterable);\n    }\n    return batchIterable(size, iterable);\n}\n/**\n * Groups an iterable into batches of a given size.\n *\n * @param size - The maximum batch size\n * @param iterable - The iterable to batch\n *\n * @returns An iterable of batches\n *\n * @internal\n */\nexport function* batchArray<T>(size: number, array: T[]): Generator<T[], void, number | undefined> {\n    let min = 0;\n    while (min < array.length) {\n        const max = min + size;\n        size = (yield array.slice(min, max)) ?? size;\n        min = max;\n    }\n}\n/**\n * Groups an iterable into batches of a given size.\n *\n * @param size - The maximum batch size\n * @param iterable - The iterable to batch\n *\n * @returns An iterable of batches\n *\n * @internal\n */\nexport function* batchIterable<T>(\n    size: number,\n    iterable: Iterable<T>,\n): Generator<T[], void, number | undefined> {\n    let array: T[] = [];\n    for (const value of iterable) {\n        if (array.push(value) >= size) {\n            size = (yield array) ?? size;\n            array = [];\n        }\n    }\n    if (array.length > 0) {\n        yield array;\n    }\n}\n/**\n * Wraps and then clamps a number within a given range.\n *\n * @param num - The number to wrap and then clamp\n * @param min - The minimum result value, inclusive\n * @param max - The wrap pivot and maximum result value, inclusive\n *\n * @returns The crwapped number\n *\n * @internal\n */\nexport function cwrap(num: number, min: number, max: number): number {\n    return clamp(nwrap(num, max), min, max);\n}\n/**\n * Sorts a list in place.\n *\n * Works on complete lists as well as sublists and circular lists:\n * - Linked lists will keep the link to the next node beyond the sorted section\n * - Doubly linked lists will keep links to the prev and next nodes outside the sorted section\n *\n * @param node - The head of the list\n * @param len - The length of the list beginning from node\n * @param isDoubly - Whether node is a doubly linked node\n * @param compareFn - A function used to determine the order of elements.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n *\n * @returns The new head and tail of the sorted list\n *\n * @internal\n */\nexport function linkedMergeSort<T, Node extends LinkedNode<T>>(\n    node: Node,\n    len: number,\n    isDoubly: boolean,\n    compareFn: CompareFn<T>,\n): [Node, Node] {\n    // Base case\n    if (len < 2) {\n        return [node, node];\n    }\n\n    // Split the list into two halves and sort them\n    len = len / 2;\n    const lens: [number, number] = [Math.ceil(len), Math.floor(len)];\n    const heads = linkedMergeSort(node, lens[0], isDoubly, compareFn);\n    const tails = linkedMergeSort(heads[1].next as Node, lens[1], isDoubly, compareFn);\n\n    // Group the heads and tails together\n    node = heads[1];\n    heads[1] = tails[0];\n    tails[0] = node;\n    tails[0].next = tails[1].next;\n\n    // Merge the sorted halves\n    const prev = (heads[0] as DoublyLinkedNode<T>).prev;\n    node = linkedMergeSorted(heads, lens, isDoubly, compareFn);\n    if (isDoubly) {\n        (node as DoublyLinkedNode<T>).prev = prev;\n    }\n\n    // Return the head and tail\n    return [node, tails[+(lens[0] < 1)]];\n}\n/**\n * Merges two sorted lists.\n *\n * @param nodes - The heads of the lists\n * @param lens - The lengths of the lists\n * @param isDoubly - Whether the lists are a doubly linked\n * @param compareFn - A function used to determine the order of elements.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n *\n * @returns The new head of the sorted list\n *\n * @internal\n */\nexport function linkedMergeSorted<T, Node extends LinkedNode<T>>(\n    heads: [Node, Node],\n    lens: [number, number],\n    isDoubly: boolean,\n    compareFn: CompareFn<T>,\n): Node {\n    const root = {} as Node;\n\n    let node = root;\n    do {\n        const index = +(compareFn(heads[0].value, heads[1].value) > 0);\n        node.next = heads[index];\n        if (isDoubly) {\n            (node.next as DoublyLinkedNode<T>).prev = node;\n        }\n        node = node.next as Node;\n        heads[index] = node.next as Node;\n        --lens[index];\n    } while (lens[0] > 0 && lens[1] > 0);\n\n    // Add any remaining nodes\n    node.next = heads[+(lens[0] < 1)];\n    if (isDoubly && node.next) {\n        (node.next as DoublyLinkedNode<T>).prev = node;\n    }\n    return root.next as Node;\n}\n/**\n * Wraps negative numbers around a pivot\n *\n * f(x, min, pivot) = {\n *    x, where x >= 0\n *    pivot + x, where x < 0\n * }\n *\n * @param num - The number to wrap\n * @param pivot - The number to pivot on\n *\n * @returns - The wrapped number\n *\n * @internal\n */\nexport function nwrap(num: number, pivot: number): number {\n    return num < 0 ? pivot + num : num;\n}\n","import { clamp } from 'src/math';\nimport { CompareFn } from '..';\nimport { List } from './list';\nimport { batch, cwrap } from './utils';\n\n/**\n * An implementation of the {@link List} interface using an array\n */\nexport class ArrayList<T> implements List<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: Array<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    add(index: number, element: T): number {\n        if (index >= 0 && index <= this.size) {\n            this.array.splice(index, 0, element);\n        }\n        return this.size;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.size) {\n            for (const items of batch(10000, elements)) {\n                this.array.splice(index, 0, ...items);\n                index += items.length;\n            }\n        }\n        return this.size;\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    concat(...lists: Iterable<T>[]): ArrayList<T> {\n        const out = new ArrayList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        index = cwrap(index ?? 0, 0, this.size);\n        min = cwrap(min ?? 0, 0, this.size);\n        max = cwrap(max ?? this.size, 0, this.size);\n        this.array.copyWithin(index, min, max);\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.size);\n        max = cwrap(max ?? this.size, 0, this.size);\n        this.array.fill(element, min, max);\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array[index];\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        let value: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            value = this.array[index];\n            this.array[index] = callback(value);\n        }\n        return value;\n    }\n\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n\n    push(element: T): number {\n        return this.array.push(element);\n    }\n\n    remove(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array.splice(index, 1)[0];\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.size);\n        max = cwrap(max ?? this.size, 0, this.size) - 1;\n        while (min < max) {\n            const temp = this.array[min];\n            this.array[min++] = this.array[max];\n            this.array[max--] = temp;\n        }\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        let prev: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            prev = this.array[index];\n            this.array[index] = element;\n        }\n        return prev;\n    }\n\n    shift(): T | undefined {\n        return this.array.shift();\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    slice(min?: number, max?: number): ArrayList<T> {\n        return new ArrayList(this.array.slice(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = cwrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n        const list = new ArrayList(this.array.splice(start, count));\n        for (const items of batch(10000, elements ?? [])) {\n            this.array.splice(start, 0, ...items);\n            start += items.length;\n        }\n        return list;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        this.array.sort(compareFn);\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n\n    unshift(element: T): number {\n        return this.array.unshift(element);\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = cwrap((min as number) ?? 0, 0, this.size);\n        max = cwrap((max as number) ?? this.size, 0, this.size);\n        while (min < max) {\n            this.array[min] = callback(this.array[min], min);\n            ++min;\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = cwrap(min ?? 0, 0, this.size);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.size;\n        } else if (max >= 0) {\n            len = () => Math.min(max, this.size);\n        } else {\n            len = () => this.size + max;\n        }\n\n        while (min < len()) {\n            yield this.array[min++];\n        }\n    }\n}\n","import { clamp } from 'src/math';\nimport { CompareFn } from '..';\nimport { DoublyLinkedNode } from './doublyLinkedNode';\nimport { List } from './list';\nimport { linkedMergeSort, cwrap } from './utils';\n\n/**\n * A (circular) doubly-linked list implementation of the {@link List} interface.\n *\n * Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.\n */\nexport class DoublyLinkedList<T> implements List<T> {\n    /**\n     * The number of elements in the list\n     */\n    protected length: number;\n    /**\n     * The sentinel node at the fron of the list\n     */\n    protected root: DoublyLinkedNode<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as DoublyLinkedNode<T>;\n        this.root.prev = this.root.next = this.root;\n        this._addAll(this.root, elements ?? []);\n    }\n\n    add(index: number, value: T): number {\n        if (index < 0 || index > this.length) {\n            return this.length;\n        }\n        const prev = this._get(index - 1);\n        const node = { next: prev.next, prev, value };\n        prev.next = node;\n        node.next!.prev = node;\n        return ++this.length;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.length) {\n            this._addAll(this._get(index), elements);\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.root.prev = this.root.next = this.root;\n    }\n\n    concat(...lists: Iterable<T>[]): DoublyLinkedList<T> {\n        const out = new DoublyLinkedList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to the same section\n        index = cwrap(index, 0, this.length);\n        min = cwrap(min ?? 0, 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = cwrap(max ?? this.length, 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Check for overlap edge case\n        if (min < index && index < max) {\n            let nodeA = this._get(max);\n            let nodeB = this._get(index + (max - min));\n            do {\n                nodeA = nodeA.prev!;\n                nodeB = nodeB.prev!;\n                nodeB.value = nodeA.value;\n            } while (++min < max);\n            return this;\n        }\n\n        // Copy the section to the destination\n        let nodeA = this._get(min);\n        let nodeB = this._get(index);\n        do {\n            nodeB.value = nodeA.value;\n            nodeA = nodeA.next!;\n            nodeB = nodeB.next!;\n        } while (++min < max);\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.length);\n        max = cwrap(max ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.length ? undefined : this._get(index).value;\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const tail = this.root.prev!;\n        tail.prev!.next = this.root;\n        this.root.prev = tail.prev;\n        --this.length;\n        return tail.value;\n    }\n\n    push(value: T): number {\n        const prev = this.root.prev!;\n        const node = { next: this.root, prev, value };\n        prev.next = this.root.prev = node;\n        return ++this.length;\n    }\n\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        node.prev!.next = node.next;\n        node.next!.prev = node.prev;\n        --this.length;\n        return node.value;\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.length);\n        max = cwrap(max ?? this.length, 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        const tail = root.next!;\n        let node = tail;\n        do {\n            const temp = node.next!;\n            node.next = node.prev;\n            node.prev = temp;\n            root.next = node;\n            node = temp;\n        } while (++min < max);\n        tail.next = node;\n        node.prev = tail;\n        root.next!.prev = root;\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n\n    shift(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const head = this.root.next!;\n        head.next!.prev = this.root;\n        this.root.next = head.next;\n        --this.length;\n        return head.value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    slice(min?: number, max?: number): DoublyLinkedList<T> {\n        return new DoublyLinkedList(this.view(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = cwrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n\n        // If not modifying the list\n        const list = new DoublyLinkedList<T>();\n        if (elements == null && count < 1) {\n            return list;\n        }\n\n        // Delete elements\n        let node = this._get(start);\n        while (count-- > 0) {\n            list.push(node.value);\n            node.prev!.next = node.next!;\n            node.next!.prev = node.prev!;\n            node = node.next!;\n            --this.length;\n        }\n\n        // Add elements\n        this._addAll(node, elements ?? []);\n\n        return list;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        if (this.length > 1) {\n            const [head, tail] = linkedMergeSort(this.root.next!, this.length, true, compareFn);\n            this.root.next = head;\n            tail.next!.prev = tail;\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let node = this.root.next!; node !== this.root; node = node.next!) {\n            yield node.value;\n        }\n    }\n\n    unshift(value: T): number {\n        const head = this.root.next!;\n        const node = { next: head, prev: this.root, value };\n        this.root.next = head.prev = node;\n        return ++this.length;\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = cwrap((min as number) ?? 0, 0, this.length);\n        max = cwrap((max as number) ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = cwrap(min ?? 0, 0, this.length);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.length;\n        } else if (max >= 0) {\n            len = () => max;\n        } else {\n            len = () => this.length + max;\n        }\n\n        if (min < len()) {\n            let node = this._get(min);\n            do {\n                yield node.value;\n                node = node.next!;\n            } while (++min < len() && node !== this.root);\n        }\n    }\n    /**\n     *\n     */\n    protected _addAll(next: DoublyLinkedNode<T>, elements: Iterable<T>): void {\n        let prev = next.prev!;\n        for (const value of elements) {\n            const node = { prev, value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        next.prev = prev;\n    }\n    /**\n     * A helper method to iterate and return the node at the given index.\n     *\n     * Depending on the index, the list will be traversed from beginning or end; whichever is closest to the specified index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number): DoublyLinkedNode<T> {\n        let node = this.root;\n        if (index < this.length / 2) {\n            while (index-- >= 0) {\n                node = node.next!;\n            }\n        } else {\n            for (index = this.length - index; index > 0; --index) {\n                node = node.prev!;\n            }\n        }\n        return node;\n    }\n}\n","import { clamp } from 'src/math';\nimport { CompareFn } from '..';\nimport { LinkedNode } from './linkedNode';\nimport { List } from './list';\nimport { linkedMergeSort, cwrap } from './utils';\n\n/**\n * A (circular) linked list implementation of the {@link List} interface.\n */\nexport class LinkedList<T> implements List<T> {\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The sentinel node at the front of the list.\n     */\n    protected root: LinkedNode<T>;\n    /**\n     * The last node of the list.\n     */\n    protected tail: LinkedNode<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as LinkedNode<T>;\n        this.root.next = this.root;\n        this.tail = this._addAll(this.root, elements ?? []);\n    }\n\n    add(index: number, value: T): number {\n        if (index >= 0 && index < this.length) {\n            const prev = this._get(index - 1);\n            prev.next = { value, next: prev.next };\n            ++this.length;\n        } else if (index === this.length) {\n            this.push(value);\n        }\n        return this.length;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index < this.length) {\n            this._addAll(this._get(index - 1), elements);\n        } else if (index === this.length) {\n            this.tail = this._addAll(this.tail, elements);\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.tail = this.root.next = this.root;\n    }\n\n    concat(...lists: Iterable<T>[]): LinkedList<T> {\n        const out = new LinkedList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to itself\n        index = cwrap(index, 0, this.length);\n        min = cwrap(min ?? 0, 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = cwrap(max ?? this.length, 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Copy to earlier in the list\n        if (index < min) {\n            const node = this._get(index - 1);\n            this._copyWithin(this._get(min - index - 1, node), node, max - min);\n            return this;\n        }\n\n        // Copy to later in the list\n        if (index > max) {\n            const node = this._get(min - 1);\n            this._copyWithin(node, this._get(index - min - 1, node), max - min);\n            return this;\n        }\n\n        // Copy to overlapping destination\n        const nodeA = this._get(min - 1);\n        const nodeC = this._get(max - min - 1, nodeA);\n        const nodeD = this._copyWithin(nodeA, nodeC, index - min);\n        if (index + (max - min) >= this.length) {\n            this.tail = nodeC;\n        }\n        const temp = nodeA.next;\n        nodeA.next = nodeC.next;\n        nodeC.next = nodeD.next;\n        nodeD.next = temp;\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.length);\n        max = cwrap(max ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        return index < this.length - 1 ? this._get(index).value : this.tail.value;\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = index < this.length - 1 ? this._get(index) : this.tail;\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const value = this.tail.value;\n        this.tail = this._get(this.length - 2);\n        this.tail.next = this.root;\n        --this.length;\n        return value;\n    }\n\n    push(value: T): number {\n        const tail: LinkedNode<T> = { next: this.root, value };\n        this.tail.next = tail;\n        this.tail = tail;\n        return ++this.length;\n    }\n\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const prev = this._get(index - 1);\n        const node = prev.next!;\n        prev.next = node.next;\n        if (index === --this.length) {\n            this.tail = prev;\n        }\n        return node.value;\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.length);\n        max = cwrap(max ?? this.length, 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        this.tail = max >= this.length ? root.next! : this.tail;\n        const tail = root.next!;\n        let prev = tail;\n        let node = tail.next!;\n        while (++min < max) {\n            const next = node.next!;\n            node.next = prev;\n            prev = node;\n            node = next;\n        }\n        root.next = prev;\n        tail.next = node;\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n\n    shift(): T | undefined {\n        return this.remove(0);\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    slice(min?: number, max?: number): LinkedList<T> {\n        return new LinkedList(this.view(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = cwrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n\n        // If not modifying the list\n        const deleted = new LinkedList<T>();\n        if (elements == null && count < 1) {\n            return deleted;\n        }\n\n        // Delete elements\n        let prev = this._get(start - 1);\n        const newTail = start + count >= this.size;\n        while (count-- > 0) {\n            const node = prev.next!;\n            deleted.push(node.value);\n            prev.next = node.next;\n            --this.length;\n        }\n\n        // Add elements\n        prev = this._addAll(prev, elements ?? []);\n        this.tail = newTail ? prev : this.tail;\n\n        return deleted;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        if (this.length > 1) {\n            const [head, tail] = linkedMergeSort(this.root.next!, this.length, false, compareFn);\n            this.root.next = head;\n            this.tail = tail;\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let node = this.root.next!; node !== this.root; node = node.next!) {\n            yield node.value;\n        }\n    }\n\n    unshift(value: T): number {\n        return this.add(0, value);\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = cwrap((min as number) ?? 0, 0, this.length);\n        max = cwrap((max as number) ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = cwrap(min ?? 0, 0, this.length);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.length;\n        } else if (max >= 0) {\n            len = () => max;\n        } else {\n            len = () => this.length + max;\n        }\n\n        if (min < len()) {\n            let node = this._get(min);\n            do {\n                yield node.value;\n                node = node.next!;\n            } while (++min < len() && node !== this.root);\n        }\n    }\n\n    protected _addAll(prev: LinkedNode<T>, elements: Iterable<T>): LinkedNode<T> {\n        const next = prev.next!;\n        for (const value of elements) {\n            const node = { value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        return prev;\n    }\n    /**\n     * Copy values from 'from' to 'to'.\n     *\n     * @param from - The initial node to copy from\n     * @param prev - The root of the initial node to copy to\n     * @param count - The number of values to copy\n     */\n    protected _copyWithin(from: LinkedNode<T>, to: LinkedNode<T>, count: number): LinkedNode<T> {\n        while (count-- > 0) {\n            from = from.next!;\n            to = to.next!;\n            to.value = from.value;\n        }\n        return to;\n    }\n    /**\n     * Get the node at the given index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number, root: LinkedNode<T> = this.root): LinkedNode<T> {\n        let node = root!;\n        while (index-- >= 0) {\n            node = node.next!;\n        }\n        return node;\n    }\n}\n","/**\n * Bit hacks for 32-bit unsigned numbers.\n */\n\n/**\n * Get the number of bits set of a 32-bit unsigned number ([source](https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan))\n *\n * @param a\n */\nexport function bitsSet(a: number): number {\n    let b = 0;\n    while (a) {\n        ++b;\n        a &= a - 1;\n    }\n    return b;\n}\n/**\n * Invert the bits of a 32-bit unsigned number.\n *\n * Example: 11 (1011) -> 4 (0100)\n *\n * @param a The number to invert\n *\n * @returns The inverted number\n */\nexport function invert(a: number): number {\n    const b = msp(a);\n    return u32(a ^ (b | (b - 1)));\n}\n/**\n * Check whether a 32-bit unsigned number is a power of 2.\n *\n * Example: 8 (1000) -> true\n *\n * @param a The number to check\n */\nexport function isPow2(a: number): boolean {\n    return (a & (a - 1)) === 0;\n}\n/**\n * Get the Least Significant Bit of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns The lowest bit set\n */\nexport function lsb(a: number): number {\n    let b = -1;\n    for (a = lsp(a); a; a >>>= 1) {\n        ++b;\n    }\n    return b;\n}\n/**\n * Get the Least Significant Power of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns 2**lsb(a)\n */\nexport function lsp(a: number): number {\n    return u32(a & -a);\n}\n/**\n * Get the Least Significant Power Set of a 32-bit unsigned number.\n *\n * Example: 54 (110110) -> 6 (000110)\n *\n * @param a\n */\nexport function lsps(a: number): number {\n    return u32(a & (lsp(a + lsp(a)) - 1));\n}\n/**\n * Get the Most Significant Power of the Least Significant Power Set of a 32-bit unsigned number.\n *\n * Example: 54 (110110) -> 4 (000100)\n *\n * 111111\n * 000000\n * 000000\n *\n * 000010\n * 111000\n * 001000\n * 000100\n *\n * @param a\n */\nexport function mlsp(a: number): number {\n    return lsp(a + lsp(a)) >>> 1 || u32(0x80000000 & a);\n}\n/**\n * Get the Most Significant Bit of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns log2(a) : the highest bit set\n */\nexport function msb(a: number): number {\n    let b = -1;\n    while (a !== 0) {\n        ++b;\n        a >>>= 1;\n    }\n    return b;\n}\n/**\n * Get the Most Significant Power of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns 2**msb(a)\n */\nexport function msp(a: number): number {\n    let b = a & -a;\n    while (a != b) {\n        a ^= b;\n        b = a & -a;\n    }\n    return u32(b);\n}\n/**\n * Get the Most Significant Power Set of a 32-bit unsigned number.\n *\n * Example: 50 (110010) -> 48 (110000)\n *\n * @param a\n */\nexport function msps(a: number): number {\n    let b = a & -a;\n    while (a & (a + b)) {\n        a ^= b;\n        b = a & -a;\n    }\n    return u32(a);\n}\n/**\n * Reverse a 32-bit unsigned number.\n *\n * Example: 50 (110010) -> 19 (010011)\n *\n * @param a\n */\nexport function reverse(a: number): number {\n    a = ((a & 0xaaaaaaaa) >>> 1) | ((a & 0x55555555) << 1);\n    a = ((a & 0xcccccccc) >>> 2) | ((a & 0x33333333) << 2);\n    a = ((a & 0xf0f0f0f0) >>> 4) | ((a & 0x0f0f0f0f) << 4);\n    a = ((a & 0xff00ff00) >>> 8) | ((a & 0x00ff00ff) << 8);\n    return u32((a >>> 16) | (a << 16));\n}\n/**\n * Turn a number into an unsigned 32-bit number\n *\n * @param a\n */\nexport function u32(a: number): number {\n    return a >>> 0;\n}\n","import { Queue } from './queue';\n\n/**\n * An implementation of the {@link Queue} interface using an array\n */\nexport class ArrayQueue<T> implements Queue<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * Instantiate the queue.\n     *\n     * @param elements - A set of elements to initialize the queue with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    dequeue(): T | undefined {\n        return this.size < 1 ? undefined : this.array.shift();\n    }\n\n    enqueue(element: T): number {\n        return this.array.push(element);\n    }\n\n    peek(): T | undefined {\n        return this.size < 1 ? undefined : this.array[0];\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Queue } from './queue';\n\n/**\n * A linked list implementation of the {@link Queue} interface\n */\nexport class LinkedQueue<T> implements Queue<T> {\n    /**\n     * The list containing every element.\n     */\n    protected list: List<T>;\n    /**\n     * Instantiate the queue.\n     *\n     * @param elements - A set of elements to initialize the queue with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList(elements);\n    }\n\n    clear(): void {\n        this.list.clear();\n    }\n\n    dequeue(): T | undefined {\n        return this.list.shift();\n    }\n\n    enqueue(element: T): number {\n        return this.list.push(element);\n    }\n\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","import { lsb, lsp, msb, msp } from '../math/u32';\nimport { CombineFn } from '..';\nimport { MAX_ARRAY_LENGTH } from 'src/array/utils';\nimport { SegmentTree } from './segmentTree';\n\n/*\n    mca(a, b) = lsp(a | msp(b - a)) ; // where a <= b\n    left(i) = i - (lsp(i + 1) >>> 1)\n    right(i) = i + (lsp(i + 1) >>> 1)\n    parent(i) =\n        offset = lsp(i + 1)\n        i + offset - ((i & 2*offset) >>> 0)\n*/\n\n/**\n * A {@link SegmentTree} with entries stored in in-order traversal.\n * Inspired by [Tristan Hume's IForestIndex](https://thume.ca/2021/03/14/iforests) ([github](https://github.com/trishume/gigatrace))\n */\nexport class InOrderSegmentTree<T> implements SegmentTree<T> {\n    /**\n     * The maximum amount of elements that can be added.\n     *\n     * n elements require 2n memory.\n     */\n    static readonly MAX_SIZE: number = MAX_ARRAY_LENGTH >>> 1;\n    /**\n     * The set of elements and aggregation nodes for the tree\n     */\n    protected array: T[];\n    /**\n     * The function used to aggregate elements\n     */\n    protected combine: CombineFn<T>;\n    /**\n     * Construct a new segment tree\n     *\n     * @param combine - The function used to aggregate segment information\n     * @param elements - A set of elements to add into the initial tree\n     */\n    constructor(combine: CombineFn<T>, elements: Iterable<T> = []) {\n        this.array = [];\n        this.combine = combine;\n        this.build(elements);\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    pop(): T | undefined {\n        // Sanitize range\n        if (this.size < 1) {\n            return undefined;\n        }\n\n        // Un-complete aggregation nodes\n        const i = this.array.length - 1;\n        for (let mask = 2; i & mask; mask *= 2) {\n            this.array[i - mask] = this.array[i - mask - (mask >>> 1)];\n        }\n\n        // Return element\n        const out = this.array[i - 1];\n        this.array.length -= 2;\n        return out;\n    }\n\n    push(element: T): number {\n        // Sanitize range\n        if (this.size >= InOrderSegmentTree.MAX_SIZE) {\n            throw new RangeError(`Invalid length`);\n        }\n\n        // Add element\n        const i = this.array.length;\n        this.array[i + 1] = this.set(i, element);\n\n        return this.size;\n    }\n\n    query(min: number, max: number): T {\n        // Sanitize range\n        if (min >= max) {\n            throw new RangeError(`Range [${min}..${max}) is empty`);\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min *= 2;\n        max *= 2;\n\n        // Jump to min's highest aggregation node that is fully within the range\n        let offset = lsp(min | msp(max - min));\n        let value = this.array[min - 1 + (offset >>> 1)];\n\n        // Continue jumping aggregation nodes until max is reached\n        for (min += offset; min < max; min += offset) {\n            offset = lsp(min | msp(max - min));\n            value = this.combine(value, this.array[min - 1 + (offset >>> 1)]);\n        }\n\n        return value;\n    }\n\n    get size(): number {\n        return this.array.length >>> 1;\n    }\n\n    /**\n     * Return an iterator through the tree's elements\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let i = 0; i < this.array.length; i += 2) {\n            yield this.array[i];\n        }\n    }\n\n    update(min: number, max: number, operation: (element: T, index: number) => T): void {\n        // Sanitize range\n        if (min >= max) {\n            return;\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min *= 2;\n        max *= 2;\n\n        // Update the values\n        let value: T;\n        do {\n            value = this.set(min, operation(this.array[min], min >>> 1));\n            min += 2;\n        } while (min < max);\n\n        // Update remaining aggregation nodes\n        let dc = 0;\n        let dp = lsp(min);\n        max = msb(min ^ this.array.length) - lsb(min);\n        for (--min; max > 0; --max) {\n            value = this.combine(value, this.array[min + (dp >>> 1) - dc]);\n            this.array[min] = value;\n            dc = (min & (2 * dp)) >>> 0;\n            min += dp - dc;\n            dp *= 2;\n        }\n\n        // Update the incomplete aggregation node\n        this.array[min] = value;\n    }\n    /**\n     * A helper method used to build the tree\n     *\n     * @param elements The initial set of elements to add into the tree\n     */\n    protected build(elements: Iterable<T>) {\n        for (const element of elements) {\n            this.push(element);\n        }\n    }\n    /**\n     * A helper method to update complete aggregation nodes for an index\n     */\n    protected set(index: number, element: T): T {\n        // Set the index\n        this.array[index++] = element;\n\n        // Update complete aggregation nodes, from lowest to highest\n        for (let mask = 2; index & mask; mask *= 2) {\n            element = this.combine(this.array[index - mask - (mask >>> 1)], element);\n            this.array[index - mask] = element;\n        }\n\n        return element;\n    }\n}\n","/**\n *  Thanks to [Douglas Wilhelm Harder](https://ece.uwaterloo.ca/~dwharder/aads/Algorithms/Array_resizing/)\n *  for their analysis on array resizing\n */\nimport { isArray, MAX_ARRAY_LENGTH } from 'src/array/utils';\nimport { isCollection } from 'src/collection';\nimport { Collection } from 'src/collection/collection';\nimport { CombineFn } from '..';\nimport { isPow2, lsp, msp } from '../math/u32';\nimport { SegmentTree } from './segmentTree';\n\n/**\n * A {@link SegmentTree} with entries stored in level-order traversal.\n * Memory usage: n elements require between 2n-1 to 4(n-1)-1 entries\n *\n */\nexport class LevelOrderSegmentTree<T> implements SegmentTree<T> {\n    /**\n     * The maximum number of elements that can be added.\n     *\n     * n elements require 2^log2(2n) - 1 memory:\n     */\n    static readonly MAX_SIZE: number = (MAX_ARRAY_LENGTH + 1) / 2;\n    /**\n     * The internal array used to store elements and aggregation nodes\n     */\n    protected array: Array<T>;\n    /**\n     * The function used to aggregate elements\n     */\n    protected combine: CombineFn<T>;\n    /**\n     * The used length (size) of our internal array\n     */\n    protected length: number;\n    /**\n     * The start index for the lowest level\n     */\n    protected level: number;\n    /**\n     * Construct a new {@link SegmentTree}\n     *\n     * @param combinFn - The function used to aggregate elements\n     * @param elements - Initial elements to build into the tree\n     */\n    constructor(combine: CombineFn<T>, elements: Iterable<T> = []) {\n        this.array = [];\n        this.combine = combine;\n        this.length = 0;\n        this.level = 0;\n        this.build(elements);\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.level = 0;\n        this.array.length = 0;\n    }\n\n    pop(): T | undefined {\n        // Sanitize range\n        if (this.length <= this.level) {\n            return undefined;\n        }\n\n        // Remove element\n        const out = this.array[--this.length];\n\n        // If level is <= 1/4 full\n        if (this.length <= (this.array.length + 1) >>> 2) {\n            this.shrink();\n        }\n\n        return out;\n    }\n\n    push(element: T): number {\n        // If array is full\n        if (this.length >= this.array.length) {\n            this.grow();\n        }\n\n        // Add the new element\n        this.array[this.length++] = element;\n\n        // Update aggregation nodes\n        for (let i = this.length; i & 1; this.array[i - 1] = element) {\n            element = this.combine(this.array[i - 2], element);\n            i >>>= 1;\n        }\n\n        return this.size;\n    }\n\n    query(min: number, max: number): T {\n        // Sanitize range\n        if (min >= max) {\n            throw new RangeError(`Range [${min}..${max}) is empty`);\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices and align with powers of 2\n        min += this.level + 1;\n        max += this.level + 1;\n\n        // Take the longest possible jump from min\n        let offset = lsp(min | msp(max - min));\n        let value: T = this.array[min / offset - 1];\n        min += offset;\n\n        // Continue jumping until max\n        while (min < max) {\n            offset = lsp(min | msp(max - min));\n            value = this.combine(value, this.array[min / offset - 1]);\n            min += offset;\n        }\n\n        return value;\n    }\n\n    get size(): number {\n        return this.length - this.level;\n    }\n\n    /**\n     * Return an iterator through the elements\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let i = 0; i < this.size; ++i) {\n            yield this.array[this.level + i];\n        }\n    }\n\n    update(min: number, max: number, operation: (element: T, index: number) => T): void {\n        // Sanitize range\n        if (min >= max) {\n            return;\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min += this.level;\n        max += this.level;\n\n        // Update the range\n        for (let i = min; i < max; ++i) {\n            this.array[i] = operation(this.array[i], i - this.level);\n        }\n\n        // Update the range's aggregation nodes\n        this.aggregate(min, max);\n    }\n    /**\n     * A helper method to aggregate a range of elements\n     */\n    protected aggregate(min: number, max: number): void {\n        // Align indices with powers of 2\n        ++min;\n        ++max;\n\n        // Aggregate elements\n        for (let cap = this.length + 1; min < max; cap >>>= 1) {\n            max += max & ((max - cap) >>> 31);\n            for (let i = (min | 1) >>> 0; i < max; i += 2) {\n                this.array[(i >>> 1) - 1] = this.combine(this.array[i - 2], this.array[i - 1]);\n            }\n            min >>>= 1;\n            max >>>= 1;\n        }\n    }\n    /**\n     * A helper method used to build the tree\n     *\n     * @param elements The initial set of elements to add into the tree\n     */\n    protected build(elements: Collection<T> | Iterable<T>): void {\n        let key: string | undefined = undefined;\n\n        // Check if the iterable's size can be known.\n        if (isArray(elements)) {\n            key = 'length';\n        } else if (isCollection(elements)) {\n            key = 'size';\n        } else {\n            for (const element of elements) {\n                this.push(element);\n            }\n            return;\n        }\n\n        // Get the iterable's size\n        const n: number = (elements as any)[key];\n\n        // Check for base case\n        if (n < 1) {\n            this.array.length = 0;\n            this.length = 0;\n            this.level = 0;\n            return;\n        }\n\n        // Check if max capacity reached\n        if (n >= LevelOrderSegmentTree.MAX_SIZE) {\n            throw new RangeError('Invalid length');\n        }\n\n        // Allocate the array\n        this.level = 2 * msp(n - 1) - 1;\n        this.length = this.level;\n        this.array.length = 2 * this.level + 1;\n\n        // Add the elements\n        for (const element of elements) {\n            this.array[this.length++] = element;\n        }\n\n        // Update aggregation nodes\n        this.aggregate(this.level, this.length);\n    }\n    /**\n     * Shift the tree down a level\n     */\n    protected grow(): void {\n        // Check base case\n        if (this.size < 1) {\n            this.array.length = 1;\n            return;\n        }\n\n        // Check if max capacity reached\n        if (this.size >= LevelOrderSegmentTree.MAX_SIZE) {\n            throw new RangeError('Invalid length');\n        }\n\n        // Extend capacity\n        this.array.length += this.array.length + 1;\n\n        // Shift the tree down a level\n        let min = this.level + 1;\n        for (let max = this.length + 1; min < max; max >>>= 1) {\n            this.array.copyWithin(2 * min - 1, min - 1, max - 1);\n            min >>>= 1;\n        }\n\n        // Update pointers\n        this.length += this.level + 1;\n        this.level += this.level + 1;\n    }\n    /**\n     * Shrink the tree to the smallest size\n     */\n    protected shrink(): void {\n        const length = this.length - this.level;\n\n        // Check base case\n        if (length < 2) {\n            this.array.copyWithin(0, this.level, this.length);\n            this.level = 0;\n            this.length = length;\n            this.array.length = length;\n            return;\n        }\n\n        // Get the highest node\n        let min = this.level + 1;\n        let mask = msp(length);\n        min = min / lsp(min | mask) - 1;\n\n        // Update the tree\n        this.level = +!isPow2(length);\n        for (let max = min + 1; mask; this.level += this.level + 1) {\n            this.array.copyWithin(this.level, min, max);\n            mask >>>= 1;\n            min += min + 1;\n            max += max + 2 + +((length & mask) > 0);\n        }\n\n        // Update pointers\n        this.length = this.level + length;\n        this.array.length = 2 * this.level + 1;\n    }\n}\n","import { Collection } from './collection';\n\nexport * from './collection';\n\nexport function isCollection(obj: any): obj is Collection<unknown> {\n    return 'size' in obj && typeof obj['size'] === 'number';\n}\n","import { Stack } from './stack';\n\n/**\n * An implementation of the {@link Stack} interface using an array\n */\nexport class ArrayStack<T> implements Stack<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * Instantiate the stack.\n     *\n     * @param elements - A set of elements to initialize the stack with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    peek(): T | undefined {\n        return this.array[this.array.length - 1];\n    }\n\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n\n    push(element: T): number {\n        return this.array.push(element);\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        const array = this.array;\n        for (let i = array.length; i > 0; yield array[--i]) {}\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Stack } from './stack';\n\n/**\n * A linked list implementation of the {@link Stack} interface\n */\nexport class LinkedStack<T> implements Stack<T> {\n    /**\n     * The list containing every element.\n     */\n    protected list: List<T>;\n    /**\n     * Instantiate the stack.\n     *\n     * @param elements - A set of elements to initialize the stack with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList();\n        for (const element of elements || []) {\n            this.push(element);\n        }\n    }\n\n    clear(): void {\n        this.list.clear();\n    }\n\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n\n    pop(): T | undefined {\n        return this.list.shift();\n    }\n\n    push(element: T): number {\n        return this.list.unshift(element);\n    }\n\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","import { CompareFn } from '..';\nimport { AATreeNode } from './aaTreeNode';\nimport {\n    clone,\n    search,\n    Edge,\n    inOrderTraverse,\n    leftmost,\n    leftmostStack,\n    preOrderTraverse,\n    removeStack,\n    rightmost,\n    rightmostStack,\n    searchStack,\n    debug,\n} from './binaryTreeUtils';\nimport { SortedTree } from './sortedTree';\nimport { isArray } from 'src/array/utils';\nimport { LinkedNode } from 'src/list';\n\n/**\n * An AA tree is a form of balanced tree used for storing and retrieving ordered data efficiently\n * ([source](https://en.wikipedia.org/wiki/AA_tree)).\n *\n * AA trees are named for Arne Andersson, their inventor. They are a variation of the redblack tree,\n * which supports efficient addition and deletion of entries. Unlike redblack trees, additional\n * constraints on the balancing mechanism greatly simplifies the implementation as well as\n * maintenance operations; While a redblack tree needs to consider seven different shapes\n * to properly balance the tree, an AA tree only needs to consider two shapes.\n *\n * The performance of an AA tree is equivalent to the performance of a redblack tree.\n * While an AA tree makes more rotations than a red-black tree, the simpler algorithms\n * tend to be faster, which balances out to similar performance. A red-black tree is\n * more consistent in its performance, but an AA tree tends to be flatter, which results\n * in slightly faster search times.\n */\nexport class AATree<T> implements SortedTree<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * Indicates how to handle duplicates:\n     * - < 0 : Add to left subtree\n     * - = 0 : Do now allow duplicates\n     * - > 0 : Add to right subtree\n     */\n    protected dupeWeight: number;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The node at the \"top\" of the heap.\n     */\n    protected root: AATreeNode<T> | undefined;\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>);\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param allowDuplicates - Whether to allow duplicates\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, allowDuplicates: boolean, elements?: Iterable<T>);\n    constructor(\n        compareFn: CompareFn<T>,\n        allowDuplicates?: boolean | Iterable<T>,\n        elements?: Iterable<T>,\n    ) {\n        if (typeof allowDuplicates !== 'boolean') {\n            elements = allowDuplicates;\n            allowDuplicates = true;\n        }\n        this.compare = compareFn;\n        this.dupeWeight = +allowDuplicates;\n        this.length = 0;\n        this.build(elements ?? []);\n    }\n\n    add(element: T): this {\n        // Find the element\n        const sentinel = { left: this.root } as AATreeNode<T>;\n        let edge: Edge<AATreeNode<T>> = { from: sentinel, label: 'left', to: this.root };\n        let stack = searchStack(element, { value: edge }, this.compare, this.dupeWeight);\n\n        // If element already exists\n        if (stack.value.to != null) {\n            return this;\n        }\n\n        // Add element\n        edge = stack.value;\n        let label = edge.label;\n        edge.from![label!] = { level: 1, value: element };\n\n        // Balance the tree\n        while (stack.next) {\n            stack = stack.next;\n            edge = stack.value;\n            edge.to = split(skew(edge.to));\n            edge.from![(label = edge.label!)] = edge.to;\n        }\n\n        // Update state\n        ++this.length;\n        this.root = sentinel.left;\n        return this;\n    }\n\n    clear(): void {\n        this.root = undefined;\n        this.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    delete(element: T): boolean {\n        // Remove the element if found\n        const sentinel = { left: this.root } as AATreeNode<T>;\n        const edge: Edge<AATreeNode<T>> = { from: sentinel, label: 'left', to: this.root };\n        const stack = searchStack(element, { value: edge }, this.compare, 0);\n        const removed = remove(stack);\n\n        // Update state\n        this.root = sentinel.left;\n        this.length -= +removed;\n        return removed;\n    }\n\n    has(element: T): boolean {\n        return search(element, this.root, this.compare) != null;\n    }\n\n    max(): T | undefined {\n        return rightmost(this.root)?.value;\n    }\n\n    min(): T | undefined {\n        return leftmost(this.root)?.value;\n    }\n\n    pop(): T | undefined {\n        // Find the maximum value\n        const sentinel = { left: this.root } as AATreeNode<T>;\n        const edge: Edge<AATreeNode<T>> = { from: sentinel, label: 'left', to: this.root };\n        const stack = rightmostStack({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.root = sentinel.left;\n        this.length -= +removed;\n        return value;\n    }\n\n    shift(): T | undefined {\n        // Find the minimum value\n        const sentinel = { left: this.root } as AATreeNode<T>;\n        const edge: Edge<AATreeNode<T>> = { from: sentinel, label: 'left', to: this.root };\n        const stack = leftmostStack({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.root = sentinel.left;\n        this.length -= +removed;\n        return value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        for (const node of inOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.delete(curElement)) {\n            this.add(newElement);\n            return true;\n        }\n        return false;\n    }\n\n    protected build(obj: Iterable<T>): void {\n        if (isArray(obj)) {\n            for (let i = 0; i < obj.length; ++i) {\n                this.add(obj[i]);\n            }\n        } else if (obj instanceof AATree && this.compare === obj.compare) {\n            this.root = clone(obj.root);\n            this.length = obj.size;\n        } else {\n            for (const element of obj) {\n                this.add(element);\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nexport function remove<T>(stack: LinkedNode<Edge<AATreeNode<T>>>): boolean {\n    let edge = stack.value;\n    let node = edge.to;\n\n    // If not found\n    if (node == null) {\n        return false;\n    }\n\n    // Remove the node\n    stack = removeStack(stack);\n\n    // Update the tree\n    while (stack.next) {\n        stack = stack.next;\n        edge = stack.value;\n        node = edge.to!;\n\n        // Decrease levels\n        const level = 1 + Math.min(node.left?.level ?? 0, node.right?.level ?? 0);\n        if (level < node.level) {\n            node.level = level;\n            if (node.right != null && level < node.right.level) {\n                node.right.level = level;\n            }\n        }\n\n        // Balance\n        node = skew(node);\n        node.right = skew(node.right);\n        if (node.right != null) {\n            node.right.right = skew(node.right.right);\n        }\n        node = split(node);\n        node.right = split(node.right);\n\n        // Make the update\n        edge.from![edge.label!] = edge.to = node;\n    }\n\n    return true;\n}\n/**\n * @internal\n */\nexport function skew<T>(node?: undefined): undefined;\nexport function skew<T>(node: AATreeNode<T>): AATreeNode<T>;\nexport function skew<T>(node?: AATreeNode<T>): AATreeNode<T> | undefined;\nexport function skew<T>(node?: AATreeNode<T>): AATreeNode<T> | undefined {\n    if (node == null || node.left == null || node.level != node.left.level) {\n        return node;\n    }\n    const left = node.left;\n    node.left = left.right;\n    left.right = node;\n    return left;\n}\n/**\n * @internal\n */\nexport function split<T>(node?: undefined): undefined;\nexport function split<T>(node: AATreeNode<T>): AATreeNode<T>;\nexport function split<T>(node?: AATreeNode<T>): AATreeNode<T> | undefined;\nexport function split<T>(node?: AATreeNode<T>): AATreeNode<T> | undefined {\n    if (\n        node == null ||\n        node.right == null ||\n        node.right.right == null ||\n        node.level != node.right.right.level\n    ) {\n        return node;\n    }\n    const right = node.right;\n    node.right = right.left;\n    right.left = node;\n    ++right.level;\n    return right;\n}\n","import { CompareFn } from 'src';\nimport { AVLTreeNode } from './avlTreeNode';\nimport {\n    clone,\n    search,\n    Edge,\n    inOrderTraverse,\n    leftmost,\n    leftmostStack,\n    preOrderTraverse,\n    rightmost,\n    rightmostStack,\n    searchStack,\n    removeStack,\n} from './binaryTreeUtils';\nimport { SortedTree } from './sortedTree';\nimport { isArray } from 'src/array/utils';\nimport { LinkedNode } from 'src/list';\n\n/**\n * An AVL tree is a self-balancing binary search tree ([source](https://en.wikipedia.org/wiki/AVL_tree)).\n *\n * It is named after inventors Georgy Adelson-Velsky and Evgenii Landis and was the first such\n * data structure to be invented. In an AVL tree, the heights of the two child\n * subtrees of any node differ by at most one; if at any time they differ by more\n * than one, rebalancing is done to restore this property.\n *\n * Lookup, insertion, and deletion all take O(log(n)) time in both the average and worst cases,\n * where n is the number of nodes in the tree prior to the operation. Insertions and deletions\n * may require the tree to be rebalanced by one or more tree rotations.\n *\n * AVL trees are often compared with redblack trees as both take O(log(n))\n * time for the basic operations. For lookup-intensive applications, AVL trees are\n * faster than redblack trees because they are more strictly balanced.\n * Similar to redblack trees, AVL trees are height-balanced.\n */\nexport class AVLTree<T> implements SortedTree<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * Indicates how to handle duplicates:\n     * - < 0 : Add to left subtree\n     * - = 0 : Do now allow duplicates\n     * - > 0 : Add to right subtree\n     */\n    protected dupeWeight: number;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The root of the tree.\n     */\n    protected root: AVLTreeNode<T>;\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>);\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param allowDuplicates - Whether to allow duplicates\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, allowDuplicates: boolean, elements?: Iterable<T>);\n    constructor(\n        compareFn: CompareFn<T>,\n        allowDuplicates?: boolean | Iterable<T>,\n        elements?: Iterable<T>,\n    ) {\n        if (typeof allowDuplicates !== 'boolean') {\n            elements = allowDuplicates;\n            allowDuplicates = true;\n        }\n        this.compare = compareFn;\n        this.dupeWeight = +allowDuplicates;\n        this.length = 0;\n        this.root = {} as AVLTreeNode<T>;\n        this.build(elements ?? []);\n    }\n\n    add(element: T): this {\n        // Find the element\n        let edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        let stack = searchStack(element, { value: edge }, this.compare, this.dupeWeight);\n\n        // If element already exists\n        if (stack.value.to != null) {\n            return this;\n        }\n\n        // Add element\n        edge = stack.value;\n        let label = edge.label;\n        edge.from![label!] = { balanceFactor: 0, value: element };\n\n        // Balance the tree\n        while (stack.next) {\n            stack = stack.next;\n            edge = stack.value;\n            edge.to!.balanceFactor += label === 'left' ? -1 : 1;\n            edge.to = balance(edge.to!);\n            edge.from![(label = edge.label!)] = edge.to;\n            if (edge.to!.balanceFactor === 0) {\n                break;\n            }\n        }\n\n        // Update state\n        ++this.length;\n        return this;\n    }\n\n    clear(): void {\n        this.root.left = undefined;\n        this.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    delete(element: T): boolean {\n        // Remove the element if found\n        const edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        const stack = searchStack(element, { value: edge }, this.compare, 0);\n        const removed = remove(stack);\n\n        // Update state\n        this.length -= +removed;\n        return removed;\n    }\n\n    has(element: T): boolean {\n        return search(element, this.root.left, this.compare) != null;\n    }\n\n    max(): T | undefined {\n        return rightmost(this.root.left)?.value;\n    }\n\n    min(): T | undefined {\n        return leftmost(this.root.left)?.value;\n    }\n\n    pop(): T | undefined {\n        // Find the maximum value\n        const edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        const stack = rightmostStack({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.length -= +removed;\n        return value;\n    }\n\n    shift(): T | undefined {\n        // Find the minimum value\n        const edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        const stack = leftmostStack({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.length -= +removed;\n        return value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        for (const node of inOrderTraverse(this.root.left)) {\n            yield node.value;\n        }\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root.left)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.delete(curElement)) {\n            this.add(newElement);\n            return true;\n        }\n        return false;\n    }\n\n    protected build(obj: Iterable<T>): void {\n        if (isArray(obj)) {\n            for (let i = 0; i < obj.length; ++i) {\n                this.add(obj[i]);\n            }\n        } else if (obj instanceof AVLTree && this.compare === obj.compare) {\n            this.root = clone(obj.root);\n            this.length = obj.size;\n        } else {\n            for (const element of obj) {\n                this.add(element);\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nexport function balance<T>(node: AVLTreeNode<T>): AVLTreeNode<T> {\n    if (node.balanceFactor > 1) {\n        if (node.right!.balanceFactor < 0) {\n            node.right = rotateR(node.right!);\n        }\n        node = rotateL(node);\n    } else if (node.balanceFactor < -1) {\n        if (node.left!.balanceFactor > 0) {\n            node.left = rotateL(node.left!);\n        }\n        node = rotateR(node);\n    }\n    return node;\n}\n/**\n * @internal\n */\nexport function remove<T>(stack: LinkedNode<Edge<AVLTreeNode<T>>>): boolean {\n    let edge = stack.value;\n    const node = edge.to;\n\n    // If not found\n    if (node == null) {\n        return false;\n    }\n\n    // Remove the node\n    stack = removeStack(stack);\n\n    // Balance the tree\n    let label = stack.value.label;\n    while (stack.next) {\n        stack = stack.next;\n        edge = stack.value;\n        edge.to!.balanceFactor -= label === 'left' ? -1 : 1;\n        edge.to = balance(edge.to!);\n        edge.from![(label = edge.label)!] = edge.to;\n        if (edge.to!.balanceFactor !== 0) {\n            break;\n        }\n    }\n\n    return true;\n}\n/**\n * @internal\n */\nexport function rotateL<T>(P: AVLTreeNode<T>): AVLTreeNode<T> {\n    const R = P.right!;\n    P.right = R.left;\n    R.left = P;\n    P.balanceFactor -= 1 + Math.max(0, R.balanceFactor);\n    R.balanceFactor -= 1 - Math.min(0, P.balanceFactor);\n    return R;\n}\n/**\n * @internal\n */\nexport function rotateR<T>(P: AVLTreeNode<T>): AVLTreeNode<T> {\n    const L = P.left!;\n    P.left = L.right;\n    L.right = P;\n    P.balanceFactor += 1 - Math.min(0, L.balanceFactor);\n    L.balanceFactor += 1 + Math.max(0, P.balanceFactor);\n    return L;\n}\n"],"sourceRoot":""}