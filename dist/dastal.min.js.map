{"version":3,"sources":["webpack://Dastal/webpack/universalModuleDefinition","webpack://Dastal/./src/array/utils.ts","webpack://Dastal/./src/heap/binaryHeap.ts","webpack://Dastal/./src/heap/skewHeap.ts","webpack://Dastal/./src/heap/utils.ts","webpack://Dastal/./src/list/arrayList.ts","webpack://Dastal/./src/list/doublyLinkedList.ts","webpack://Dastal/./src/list/linkedList.ts","webpack://Dastal/./src/list/utils.ts","webpack://Dastal/./src/queue/arrayQueue.ts","webpack://Dastal/./src/queue/linkedQueue.ts","webpack://Dastal/./src/stack/arrayStack.ts","webpack://Dastal/./src/stack/linkedStack.ts","webpack://Dastal/./src/tree/aaTreeUtils.ts","webpack://Dastal/./src/tree/aaTree.ts","webpack://Dastal/./src/tree/binaryTreeUtils.ts","webpack://Dastal/webpack/bootstrap","webpack://Dastal/webpack/runtime/compat get default export","webpack://Dastal/webpack/runtime/define property getters","webpack://Dastal/webpack/runtime/hasOwnProperty shorthand","webpack://Dastal/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","self","MAX_ARRAY_LENGTH","isArray","obj","Array","isTypedArray","TypedArray","Object","getPrototypeOf","Uint8Array","Symbol","iterator","BinaryHeap","compareFn","elements","this","compare","array","addAll","length","RangeError","i","push","element","heapify","indexOf","index","last","pop","sinkDown","bubbleUp","heap","size","undefined","value","a","b","curElement","newElement","SkewHeap","preOrderTraverse","par","key","left","right","node","skewMerge","comparator","clone","toBinaryTree","out","parentIndex","Math","floor","parent","n","childIndex","child","heaps","lists","list","tree","next","tail","mergeKSorted","ArrayList","from","splice","batch","items","min","max","cwrap","copyWithin","fill","callback","temp","prev","shift","slice","start","count","clamp","sort","unshift","arguments","len","DoublyLinkedList","_addAll","_get","nodeA","nodeB","head","view","mergeSort","LinkedList","_copyWithin","nodeC","nodeD","remove","deleted","newTail","add","to","batchArray","batchIterable","iterable","f","num","pivot","wrap","isDoubly","lens","ceil","heads","tails","mergeSorted","ArrayQueue","LinkedQueue","clear","get","ArrayStack","LinkedStack","insert","level","split","skew","found","comparison","chi","AATree","build","res","inOrderTraverse","delete","assign","stack","nodes","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","d","definition","o","defineProperty","enumerable","prop","prototype","hasOwnProperty","call","r","toStringTag"],"mappings":"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","file":"dastal.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Dastal\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Dastal\"] = factory();\n\telse\n\t\troot[\"Dastal\"] = factory();\n})(self, function() {\nreturn ","/**\n * The maximum length of an array.\n *\n * According to [ECMA-262](https://tc39.es/ecma262/#array-index):\n *     0 <= array.length <= 2^32 - 1\n */\nexport const MAX_ARRAY_LENGTH = 4294967295;\n/**\n * Check if a value is an Array or TypedArray.\n * \n * @param obj - The value to check.\n * \n * @returns `true` if an Array or TypedArray, otherwise `false`.\n */\nexport function isArray<T = any>(obj: unknown): obj is T[] {\n    return obj instanceof Array || isTypedArray(obj);\n}\n/**\n * Check if a value is a TypedArray.\n * \n * See [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)\n * for more details.\n * \n * @param obj - The value to check.\n * \n * @returns `true` if a TypedArray, otherwise `false`.\n */\nexport const isTypedArray = (() => {\n    const TypedArray = Object.getPrototypeOf(Uint8Array);\n    return function isTypedArray<T = any>(obj: unknown): obj is T[] {\n        return obj instanceof TypedArray;\n    }\n})();","import { isArray, MAX_ARRAY_LENGTH } from 'src/array/utils';\nimport { CompareFn } from '..';\nimport { Heap } from './heap';\nimport { bubbleUp, heapify, sinkDown } from './utils';\n\n/**\n * A binary heap is a heap implemented as a binary tree with an additional shape property\n * ([source](https://en.wikipedia.org/wiki/Binary_heap)).\n *\n * **Shape property**: Must be a complete binary tree. This means all levels of the tree\n * (except possibly the last one) are fully filled. If the last level of the tree is incomplete,\n * the nodes of that level are filled from left to right.\n *\n * #### Complexity\n *\n * | Property | Average | Worst |\n * | :------- | :------ | :---- |\n * | Space    | O(n)    | O(n)\n * | Push     | O(1)    | O(log n)\n * | Peek     | O(1)\t| O(1)\n * | Pop      | O(log n)| O(log n)\n * | Search   | O(n)    | O(n)\n */\nexport class BinaryHeap<T> implements Heap<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * Instantiate a heap.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>) {\n        this.compare = compareFn;\n        this.array = [];\n        this.addAll(elements ?? []);\n    }\n\n    addAll(elements: Iterable<T>): number {\n        const array = this.array;\n        const length = array.length;\n\n        if (isArray(elements)) {\n            if (array.length + elements.length > MAX_ARRAY_LENGTH) {\n                throw new RangeError('Invalid heap length');\n            }\n            for (let i = 0; i < elements.length; ++i) {\n                array.push(elements[i]);\n            }\n        } else {\n            for (const element of elements) {\n                if (array.length >= MAX_ARRAY_LENGTH) {\n                    throw new RangeError('Invalid heap length');\n                }\n                array.push(element);\n            }\n        }\n        \n        // Update the heap\n        if (length < array.length) {\n            heapify(this.compare, array);\n        }\n\n        return array.length;\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        return this.array.indexOf(element) >= 0;\n    }\n\n    delete(element: T): boolean {\n        const index = this.array.indexOf(element);\n        if (index < 0) {\n            return false;\n        }\n\n        // If deleting the last value\n        const last = this.array.pop()!;\n        if (index >= this.array.length) {\n            return true;\n        }\n\n        // Add the last value to the\n        // deleted index and update the heap\n        this.array[index] = last;\n        sinkDown(index, this.compare, this.array);\n        bubbleUp(index, this.compare, this.array);\n        return true;\n    }\n\n    merge(heap: Heap<T>): this {\n        const array = this.array;\n\n        if (heap.size < 1) {\n            return this;\n        }\n\n        if (array.length + heap.size > MAX_ARRAY_LENGTH) {\n            throw new RangeError('Invalid heap length');\n        }\n\n        for (const element of heap) {\n            array.push(element);\n        }\n\n        heapify(this.compare, array);\n        return this;\n    }\n\n    peek(): T | undefined {\n        return this.array.length > 0 ? this.array[0] : undefined;\n    }\n\n    pop(): T | undefined {\n        if (this.array.length < 1) {\n            return undefined;\n        }\n\n        // Get the root and the last value\n        const value = this.array[0];\n        const last = this.array.pop();\n\n        // If value != last\n        if (this.array.length > 0) {\n            // Move the last value to the root and update the heap\n            this.array[0] = last!;\n            sinkDown(0, this.compare, this.array);\n        }\n\n        return value;\n    }\n\n    push(value: T): number {\n        // Add new value to the end of the heap\n        this.array.push(value);\n\n        // Update the heap\n        bubbleUp(this.array.length - 1, this.compare, this.array);\n        return this.size;\n    }\n\n    pushPop(value: T): T {\n        // If empty or value is <= to root\n        if (this.array.length < 1 || this.compare(value, this.array[0]) <= 0) {\n            return value;\n        }\n\n        // Swap the root and value\n        const root = this.array[0];\n        this.array[0] = value;\n        sinkDown(0, this.compare, this.array);\n        return root;\n    }\n\n    replace(value: T): T | undefined {\n        // If empty\n        if (this.array.length < 1) {\n            this.array.push(value);\n            return undefined;\n        }\n\n        // Swap the root with value\n        const root = this.array[0];\n        this.array[0] = value;\n        value = root;\n\n        // Update the heap\n        sinkDown(0, this.compare, this.array);\n        return value;\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    *sorted(): Iterable<T> {\n        if (this.array.length < 1) {\n            return;\n        }\n        const array = this.array;\n        const heap = new BinaryHeap<number>((a, b) => this.compare(array[a], array[b]), [0]);\n        do {\n            let index = heap.pop()!;\n            if (index < array.length) {\n                yield array[index];\n                index = 2 * index + 1;\n                index < array.length && heap.push(index);\n                ++index < array.length && heap.push(index);\n            }\n        } while (heap.size > 0);\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        const index = this.array.indexOf(curElement);\n        if (index < 0) {\n            return false;\n        }\n        this.array[index] = newElement;\n        sinkDown(index, this.compare, this.array);\n        bubbleUp(index, this.compare, this.array);\n        return true;\n    }\n}\n","import { isArray } from \"src/array/utils\";\nimport { BinaryTreeNode } from \"src/tree/binaryTreeNode\";\nimport { clone, preOrderTraverse, toBinaryTree } from 'src/tree/binaryTreeUtils';\nimport { CompareFn } from '..';\nimport { BinaryHeap } from './binaryHeap';\nimport { Heap } from './heap';\nimport { skewMerge } from './utils';\n\n/**\n * A skew heap is a heap implemented as a binary tree\n * ([source](https://en.wikipedia.org/wiki/Skew_heap)).\n *\n * A skew heap is a self-adjusting heap which attempts to maintain balance\n * by unconditionally swapping all nodes in the merge path when merging two heaps. Every\n * operation that modifies the heap (e.g. push, pop, merge) is considered a merge and is done\n * by using a skew heap merge.\n *\n * Skew heaps can merge more quickly than binary heaps. This can seem contradictory, since\n * skew heaps have no structural constraints and no guarantee that the height of the tree is\n * logarithmic (i.e. balanced). However, amortized complexity analysis can demonstrate that\n * all operations on a skew heap can be done in O(log(n). More specifically, the\n * amortized complexity is known to be log<sub>φ</sub>(n) where φ is the golden ratio. This is\n * approximately 1.44*log<sub>2</sub>(n).\n *\n * #### Complexity\n *\n * | Property | Average  | Worst |\n * | :------- | :------  | :---- |\n * | Space    | O(n)     | O(n)\n * | Push     | O(log n) | O(log n)\n * | Peek     | O(1)\t | O(1)\n * | Pop      | O(log n) | O(log n)\n * | Search   | O(n)     | O(n)\n */\nexport class SkewHeap<T> implements Heap<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The node at the \"top\" of the heap.\n     */\n    protected root: BinaryTreeNode<T> | undefined;\n    /**\n     * Instantiate a heap.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the heap with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>) {\n        this.compare = compareFn;\n        this.length = 0;\n        this.addAll(elements ?? []);\n    }\n\n    addAll(elements: Iterable<T>): number {\n        if (isArray(elements)) {\n            for (let i = 0; i < elements.length; ++i) {\n                this.push(elements[i]);\n            }\n        } else {\n            for (const element of elements) {\n                this.push(element);\n            }\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.root = undefined;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        for (const node of preOrderTraverse(this.root)) {\n            if (element === node.value) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    delete(element: T): boolean {\n        if (this.root == null) {\n            return false;\n        }\n        if (this.root.value === element) {\n            this.pop()!;\n            return true;\n        }\n        for (const par of preOrderTraverse(this.root)) {\n            const key: keyof BinaryTreeNode<T> | undefined =\n                par.left && par.left.value === element\n                    ? 'left'\n                    : par.right && par.right.value === element\n                    ? 'right'\n                    : undefined;\n            if (key != null) {\n                const node = par[key]!;\n                par[key] = skewMerge(this.compare, [node.left, node.right]);\n                --this.length;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    merge(heap: Heap<T>): this {\n        if (this.compare !== heap.comparator()) {\n            this.addAll(heap);\n        } else if (heap instanceof SkewHeap) {\n            this.root = skewMerge(this.compare, [this.root, clone(heap.root)]);\n            this.length += heap.size;\n        } else if (heap instanceof BinaryHeap) {\n            this.root = skewMerge(this.compare, [this.root, toBinaryTree(heap['array'])!]);\n            this.length += heap.size;\n        } else {\n            this.addAll(heap);\n        }\n        return this;\n    }\n\n    peek(): T | undefined {\n        return this.root?.value;\n    }\n\n    pop(): T | undefined {\n        if (this.root == null) {\n            return undefined;\n        }\n        const value = this.root.value;\n        this.root = skewMerge(this.compare, [this.root.left, this.root.right]);\n        --this.length;\n        return value;\n    }\n\n    push(value: T): number {\n        this.root = skewMerge(this.compare, [this.root, { value }]);\n        return ++this.length;\n    }\n\n    pushPop(value: T): T {\n        this.push(value);\n        return this.pop()!;\n    }\n\n    replace(value: T): T | undefined {\n        if (this.root == null) {\n            this.root = { value };\n            this.length = 1;\n            return undefined;\n        }\n        const out = this.root.value;\n        this.root = skewMerge(this.compare, [this.root.left, this.root.right, { value }]);\n        return out;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        if (this.root == null) {\n            return;\n        }\n        const heap = new SkewHeap<BinaryTreeNode<T>>((a, b) => this.compare(a.value, b.value), [\n            this.root,\n        ]);\n        do {\n            const node = heap.pop()!;\n            yield node.value;\n            node.left && heap.push(node.left);\n            node.right && heap.push(node.right);\n        } while (heap.size > 0);\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.root == null) {\n            return false;\n        }\n        \n        if (this.root.value === curElement) {\n            this.root = skewMerge(this.compare, [\n                this.root.left,\n                this.root.right,\n                { value: newElement },\n            ]);\n            return true;\n        }\n\n        let node: BinaryTreeNode<T> | undefined = undefined;\n        for (const par of preOrderTraverse(this.root)) {\n            if (par.left && par.left.value === curElement) {\n                node = par.left;\n                par.left = undefined;\n                break;\n            }\n            if (par.right && par.right.value === curElement) {\n                node = par.right;\n                par.right = undefined;\n                break;\n            }\n        }\n\n        if (node == null) {\n            return false;\n        }\n\n        this.root = skewMerge(this.compare, [\n            this.root,\n            node.left,\n            node.right,\n            { value: newElement },\n        ]);\n        return true;\n    }\n}\n","import { LinkedNode } from 'src/list';\nimport { BinaryTreeNode } from \"src/tree/binaryTreeNode\";\nimport { CompareFn } from '..';\n\n/**\n * @internal\n */\nexport function bubbleUp<T>(index: number, compareFn: CompareFn<T>, array: Array<T>): void {\n    const value = array[index];\n\n    // Until we reach the top of the heap\n    while (index > 0) {\n        // Get the parent\n        const parentIndex = Math.floor((index + 1) / 2) - 1;\n        const parent = array[parentIndex]!;\n\n        // If the parent is above or equal to value, the heap is in order\n        if (compareFn(parent, value) <= 0) {\n            break;\n        }\n\n        // Swap the parent with value and continue\n        array[parentIndex] = value;\n        array[index] = parent;\n        index = parentIndex;\n    }\n}\n/**\n * @internal\n */\nexport function heapify<T>(compareFn: CompareFn<T>, array: T[]): void {\n    for (let i = (array.length + 1) >>> 1; i > 0; sinkDown(--i, compareFn, array)) {}\n}\n/**\n * @internal\n */\nexport function mergeKSorted<T>(compareFn: CompareFn<T>, lists: LinkedNode<T>[]): LinkedNode<T> {\n    // Heapify the list of lists based on\n    // the value at the head of each list.\n    const compare: CompareFn<LinkedNode<T>> = (a, b) => compareFn(a.value, b.value);\n    heapify(compare, lists);\n\n    // Combine the lists into a single list.\n    const list: LinkedNode<T> = lists[0];\n    for (let tail = list; lists.length > 1; tail = tail.next) {\n        lists[0] = lists[0].next ?? lists.pop()!;\n        sinkDown(0, compare, lists);\n        tail.next = lists[0];\n    }\n\n    return list;\n}\n/**\n * @internal\n */\nexport function sinkDown<T>(index: number, compareFn: CompareFn<T>, array: Array<T>): void {\n    const n = array.length;\n    const value = array[index];\n    do {\n        // Compute the left child's index\n        let childIndex = 2 * index + 1;\n\n        // If no children exist\n        if (childIndex >= n) {\n            break;\n        }\n\n        // Decide which child to compare with\n        let child = array[childIndex];\n        if (childIndex + 1 < n && compareFn(array[childIndex + 1], child) <= 0) {\n            child = array[++childIndex]!;\n        }\n\n        // If value <= child\n        if (compareFn(value, child) <= 0) {\n            break;\n        }\n\n        // Swap value and child\n        array[index] = child;\n        array[childIndex] = value;\n        index = childIndex;\n    } while (true);\n}\n/**\n * See: https://en.wikipedia.org/wiki/Skew_heap#Merging_two_heaps\n *\n * @param compareFn - A function used to determine the order of the heap.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n * @param heaps - An iterable of heaps to merge\n *\n * @returns The new heap\n */\nexport function skewMerge<T>(\n    compareFn: CompareFn<T>,\n    heaps: (BinaryTreeNode<T> | undefined)[],\n): BinaryTreeNode<T> | undefined {\n    // Remove undefineds and initialize a list for each heap\n    const lists: LinkedNode<BinaryTreeNode<T>>[] = [];\n    for (let i = 0; i < heaps.length; ++i) {\n        if (heaps[i] != null) {\n            lists.push({ value: heaps[i]! });\n        }\n    }\n\n    // Check if nothing to merge with\n    if (lists.length < 2) {\n        return lists[0]?.value;\n    }\n\n    // Split each heap into subheaps by cutting every right path; From the root\n    // node, sever the right node to make the right child its own heap. Repeat\n    // until you can't go right. This will turn each heap into a list of heaps\n    // where the root either only has a left child or no children at all. The\n    // lists of heaps will be in desc order (from bottom to top).\n    for (let i = 0; i < lists.length; ++i) {\n        let list = lists[i];\n        let tree: BinaryTreeNode<T> | undefined = list.value;\n        while ((tree = tree.right)) {\n            list = { next: list, value: tree };\n        }\n        lists[i] = list;\n    }\n\n    // Combine the lists into a single list in desc order\n    let list: LinkedNode<BinaryTreeNode<T>> | undefined = mergeKSorted(\n        (a, b) => compareFn(b.value, a.value),\n        lists,\n    );\n\n    // While there are still multiple heaps, iteratively combine\n    // the first two (from left to right). If the root of the second-to-first\n    // subtree has a left child, swap it to be the right child. Link the root\n    // of the last subtree as the left child of the second-to-first subtree.\n    let heap = list.value;\n    while ((list = list.next)) {\n        const node = list.value;\n        node.right = node.left;\n        node.left = heap;\n        heap = node;\n    }\n\n    return heap;\n}\n","import { CompareFn } from '..';\nimport { List } from './list';\nimport { batch, clamp, cwrap } from './utils';\n\n/**\n * An implementation of the {@link List} interface using an array\n */\nexport class ArrayList<T> implements List<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: Array<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    add(index: number, element: T): number {\n        if (index >= 0 && index <= this.size) {\n            this.array.splice(index, 0, element);\n        }\n        return this.size;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.size) {\n            for (const items of batch(10000, elements)) {\n                this.array.splice(index, 0, ...items);\n                index += items.length;\n            }\n        }\n        return this.size;\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    concat(...lists: Iterable<T>[]): ArrayList<T> {\n        const out = new ArrayList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        index = cwrap(index ?? 0, 0, this.size);\n        min = cwrap(min ?? 0, 0, this.size);\n        max = cwrap(max ?? this.size, 0, this.size);\n        this.array.copyWithin(index, min, max);\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.size);\n        max = cwrap(max ?? this.size, 0, this.size);\n        this.array.fill(element, min, max);\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array[index];\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        let value: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            value = this.array[index];\n            this.array[index] = callback(value);\n        }\n        return value;\n    }\n\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n\n    push(element: T): number {\n        return this.array.push(element);\n    }\n\n    remove(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array.splice(index, 1)[0];\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.size);\n        max = cwrap(max ?? this.size, 0, this.size) - 1;\n        while (min < max) {\n            const temp = this.array[min];\n            this.array[min++] = this.array[max];\n            this.array[max--] = temp;\n        }\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        let prev: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            prev = this.array[index];\n            this.array[index] = element;\n        }\n        return prev;\n    }\n\n    shift(): T | undefined {\n        return this.array.shift();\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    slice(min?: number, max?: number): ArrayList<T> {\n        return new ArrayList(this.array.slice(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = cwrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n        const list = new ArrayList(this.array.splice(start, count));\n        for (const items of batch(10000, elements ?? [])) {\n            this.array.splice(start, 0, ...items);\n            start += items.length;\n        }\n        return list;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        this.array.sort(compareFn);\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n\n    unshift(element: T): number {\n        return this.array.unshift(element);\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = cwrap((min as number) ?? 0, 0, this.size);\n        max = cwrap((max as number) ?? this.size, 0, this.size);\n        while (min < max) {\n            this.array[min] = callback(this.array[min], min);\n            ++min;\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = cwrap(min ?? 0, 0, this.size);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.size;\n        } else if (max >= 0) {\n            len = () => Math.min(max, this.size);\n        } else {\n            len = () => this.size + max;\n        }\n\n        while (min < len()) {\n            yield this.array[min++];\n        }\n    }\n}\n","import { CompareFn } from '..';\nimport { DoublyLinkedNode } from './doublyLinkedNode';\nimport { List } from './list';\nimport { clamp, mergeSort, cwrap } from './utils';\n\n/**\n * A (circular) doubly-linked list implementation of the {@link List} interface.\n *\n * Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.\n */\nexport class DoublyLinkedList<T> implements List<T> {\n    /**\n     * The number of elements in the list\n     */\n    protected length: number;\n    /**\n     * The sentinel node at the fron of the list\n     */\n    protected root: DoublyLinkedNode<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as DoublyLinkedNode<T>;\n        this.root.prev = this.root.next = this.root;\n        this._addAll(this.root, elements ?? []);\n    }\n\n    add(index: number, value: T): number {\n        if (index < 0 || index > this.length) {\n            return this.length;\n        }\n        const prev = this._get(index - 1);\n        const node = { next: prev.next, prev, value };\n        prev.next = node;\n        node.next!.prev = node;\n        return ++this.length;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.length) {\n            this._addAll(this._get(index), elements);\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.root.prev = this.root.next = this.root;\n    }\n\n    concat(...lists: Iterable<T>[]): DoublyLinkedList<T> {\n        const out = new DoublyLinkedList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to the same section\n        index = cwrap(index, 0, this.length);\n        min = cwrap(min ?? 0, 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = cwrap(max ?? this.length, 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Check for overlap edge case\n        if (min < index && index < max) {\n            let nodeA = this._get(max);\n            let nodeB = this._get(index + (max - min));\n            do {\n                nodeA = nodeA.prev!;\n                nodeB = nodeB.prev!;\n                nodeB.value = nodeA.value;\n            } while (++min < max);\n            return this;\n        }\n\n        // Copy the section to the destination\n        let nodeA = this._get(min);\n        let nodeB = this._get(index);\n        do {\n            nodeB.value = nodeA.value;\n            nodeA = nodeA.next!;\n            nodeB = nodeB.next!;\n        } while (++min < max);\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.length);\n        max = cwrap(max ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.length ? undefined : this._get(index).value;\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const tail = this.root.prev!;\n        tail.prev!.next = this.root;\n        this.root.prev = tail.prev;\n        --this.length;\n        return tail.value;\n    }\n\n    push(value: T): number {\n        const prev = this.root.prev!;\n        const node = { next: this.root, prev, value };\n        prev.next = this.root.prev = node;\n        return ++this.length;\n    }\n\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        node.prev!.next = node.next;\n        node.next!.prev = node.prev;\n        --this.length;\n        return node.value;\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.length);\n        max = cwrap(max ?? this.length, 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        const tail = root.next!;\n        let node = tail;\n        do {\n            const temp = node.next!;\n            node.next = node.prev;\n            node.prev = temp;\n            root.next = node;\n            node = temp;\n        } while (++min < max);\n        tail.next = node;\n        node.prev = tail;\n        root.next!.prev = root;\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n\n    shift(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const head = this.root.next!;\n        head.next!.prev = this.root;\n        this.root.next = head.next;\n        --this.length;\n        return head.value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    slice(min?: number, max?: number): DoublyLinkedList<T> {\n        return new DoublyLinkedList(this.view(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = cwrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n\n        // If not modifying the list\n        const list = new DoublyLinkedList<T>();\n        if (elements == null && count < 1) {\n            return list;\n        }\n\n        // Delete elements\n        let node = this._get(start);\n        while (count-- > 0) {\n            list.push(node.value);\n            node.prev!.next = node.next!;\n            node.next!.prev = node.prev!;\n            node = node.next!;\n            --this.length;\n        }\n\n        // Add elements\n        this._addAll(node, elements ?? []);\n\n        return list;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        if (this.length > 1) {\n            const [head, tail] = mergeSort(this.root.next!, this.length, true, compareFn);\n            this.root.next = head;\n            tail.next!.prev = tail;\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let node = this.root.next!; node !== this.root; node = node.next!) {\n            yield node.value;\n        }\n    }\n\n    unshift(value: T): number {\n        const head = this.root.next!;\n        const node = { next: head, prev: this.root, value };\n        this.root.next = head.prev = node;\n        return ++this.length;\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = cwrap((min as number) ?? 0, 0, this.length);\n        max = cwrap((max as number) ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = cwrap(min ?? 0, 0, this.length);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.length;\n        } else if (max >= 0) {\n            len = () => max;\n        } else {\n            len = () => this.length + max;\n        }\n\n        if (min < len()) {\n            let node = this._get(min);\n            do {\n                yield node.value;\n                node = node.next!;\n            } while (++min < len() && node !== this.root);\n        }\n    }\n    /**\n     *\n     */\n    protected _addAll(next: DoublyLinkedNode<T>, elements: Iterable<T>): void {\n        let prev = next.prev!;\n        for (const value of elements) {\n            const node = { prev, value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        next.prev = prev;\n    }\n    /**\n     * A helper method to iterate and return the node at the given index.\n     *\n     * Depending on the index, the list will be traversed from beginning or end; whichever is closest to the specified index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number): DoublyLinkedNode<T> {\n        let node = this.root;\n        if (index < this.length / 2) {\n            while (index-- >= 0) {\n                node = node.next!;\n            }\n        } else {\n            for (index = this.length - index; index > 0; --index) {\n                node = node.prev!;\n            }\n        }\n        return node;\n    }\n}\n","import { CompareFn } from '..';\nimport { LinkedNode } from './linkedNode';\nimport { List } from './list';\nimport { clamp, mergeSort, cwrap } from './utils';\n\n/**\n * A (circular) linked list implementation of the {@link List} interface.\n */\nexport class LinkedList<T> implements List<T> {\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The sentinel node at the fron of the list.\n     */\n    protected root: LinkedNode<T>;\n    /**\n     * The last node of the list.\n     */\n    protected tail: LinkedNode<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as LinkedNode<T>;\n        this.root.next = this.root;\n        this.tail = this._addAll(this.root, elements ?? []);\n    }\n\n    add(index: number, value: T): number {\n        if (index >= 0 && index < this.length) {\n            const prev = this._get(index - 1);\n            prev.next = { value, next: prev.next };\n            ++this.length;\n        } else if (index === this.length) {\n            this.push(value);\n        }\n        return this.length;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index < this.length) {\n            this._addAll(this._get(index - 1), elements);\n        } else if (index === this.length) {\n            this.tail = this._addAll(this.tail, elements);\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.tail = this.root.next = this.root;\n    }\n\n    concat(...lists: Iterable<T>[]): LinkedList<T> {\n        const out = new LinkedList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to itself\n        index = cwrap(index, 0, this.length);\n        min = cwrap(min ?? 0, 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = cwrap(max ?? this.length, 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Copy to earlier in the list\n        if (index < min) {\n            const node = this._get(index - 1);\n            this._copyWithin(this._get(min - index - 1, node), node, max - min);\n            return this;\n        }\n\n        // Copy to later in the list\n        if (index > max) {\n            const node = this._get(min - 1);\n            this._copyWithin(node, this._get(index - min - 1, node), max - min);\n            return this;\n        }\n\n        // Copy to overlapping destination\n        const nodeA = this._get(min - 1);\n        const nodeC = this._get(max - min - 1, nodeA);\n        const nodeD = this._copyWithin(nodeA, nodeC, index - min);\n        if (index + (max - min) >= this.length) {\n            this.tail = nodeC;\n        }\n        const temp = nodeA.next;\n        nodeA.next = nodeC.next;\n        nodeC.next = nodeD.next;\n        nodeD.next = temp;\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.length);\n        max = cwrap(max ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        return index < this.length - 1 ? this._get(index).value : this.tail.value;\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = index < this.length - 1 ? this._get(index) : this.tail;\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const value = this.tail.value;\n        this.tail = this._get(this.length - 2);\n        this.tail.next = this.root;\n        --this.length;\n        return value;\n    }\n\n    push(value: T): number {\n        const tail: LinkedNode<T> = { next: this.root, value };\n        this.tail.next = tail;\n        this.tail = tail;\n        return ++this.length;\n    }\n\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const prev = this._get(index - 1);\n        const node = prev.next!;\n        prev.next = node.next;\n        if (index === --this.length) {\n            this.tail = prev;\n        }\n        return node.value;\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = cwrap(min ?? 0, 0, this.length);\n        max = cwrap(max ?? this.length, 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        this.tail = max >= this.length ? root.next! : this.tail;\n        const tail = root.next!;\n        let prev = tail;\n        let node = tail.next!;\n        while (++min < max) {\n            const next = node.next!;\n            node.next = prev;\n            prev = node;\n            node = next;\n        }\n        root.next = prev;\n        tail.next = node;\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n\n    shift(): T | undefined {\n        return this.remove(0);\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    slice(min?: number, max?: number): LinkedList<T> {\n        return new LinkedList(this.view(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = cwrap(start ?? 0, 0, this.size);\n        count = clamp(count ?? this.size, 0, this.size - start);\n\n        // If not modifying the list\n        const deleted = new LinkedList<T>();\n        if (elements == null && count < 1) {\n            return deleted;\n        }\n\n        // Delete elements\n        let prev = this._get(start - 1);\n        const newTail = start + count >= this.size;\n        while (count-- > 0) {\n            const node = prev.next!;\n            deleted.push(node.value);\n            prev.next = node.next;\n            --this.length;\n        }\n\n        // Add elements\n        prev = this._addAll(prev, elements ?? []);\n        this.tail = newTail ? prev : this.tail;\n\n        return deleted;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        if (this.length > 1) {\n            const [head, tail] = mergeSort(this.root.next!, this.length, false, compareFn);\n            this.root.next = head;\n            this.tail = tail;\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let node = this.root.next!; node !== this.root; node = node.next!) {\n            yield node.value;\n        }\n    }\n\n    unshift(value: T): number {\n        return this.add(0, value);\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = cwrap((min as number) ?? 0, 0, this.length);\n        max = cwrap((max as number) ?? this.length, 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = cwrap(min ?? 0, 0, this.length);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.length;\n        } else if (max >= 0) {\n            len = () => max;\n        } else {\n            len = () => this.length + max;\n        }\n\n        if (min < len()) {\n            let node = this._get(min);\n            do {\n                yield node.value;\n                node = node.next!;\n            } while (++min < len() && node !== this.root);\n        }\n    }\n\n    protected _addAll(prev: LinkedNode<T>, elements: Iterable<T>): LinkedNode<T> {\n        const next = prev.next!;\n        for (const value of elements) {\n            const node = { value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        return prev;\n    }\n    /**\n     * Copy values from 'from' to 'to'.\n     *\n     * @param from - The initial node to copy from\n     * @param prev - The root of the initial node to copy to\n     * @param count - The number of values to copy\n     */\n    protected _copyWithin(from: LinkedNode<T>, to: LinkedNode<T>, count: number): LinkedNode<T> {\n        while (count-- > 0) {\n            from = from.next!;\n            to = to.next!;\n            to.value = from.value;\n        }\n        return to;\n    }\n    /**\n     * Get the node at the given index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number, root: LinkedNode<T> = this.root): LinkedNode<T> {\n        let node = root!;\n        while (index-- >= 0) {\n            node = node.next!;\n        }\n        return node;\n    }\n}\n","import { isArray } from '../array/utils';\nimport { CompareFn } from '..';\nimport { DoublyLinkedNode } from \"./doublyLinkedNode\";\nimport { LinkedNode } from \"./linkedNode\";\n\n/**\n * Groups an iterable into batches of a given size.\n *\n * @param size - The maximum batch size\n * @param iterable - The iterable to batch\n *\n * @returns An iterable of batches\n *\n * @internal\n */\nexport function batch<T>(\n    size: number,\n    iterable: Iterable<T>,\n): Generator<T[], void, number | undefined> {\n    if (isArray(iterable)) {\n        return batchArray(size, iterable);\n    }\n    return batchIterable(size, iterable);\n}\n/**\n * Groups an iterable into batches of a given size.\n *\n * @param size - The maximum batch size\n * @param iterable - The iterable to batch\n *\n * @returns An iterable of batches\n *\n * @internal\n */\nexport function* batchArray<T>(\n    size: number,\n    array: T[],\n): Generator<T[], void, number | undefined> {\n    let min = 0;\n    while (min < array.length) {\n        const max = min + size;\n        size = (yield array.slice(min, max)) ?? size;\n        min = max;\n    }\n}\n/**\n * Groups an iterable into batches of a given size.\n *\n * @param size - The maximum batch size\n * @param iterable - The iterable to batch\n *\n * @returns An iterable of batches\n *\n * @internal\n */\nexport function* batchIterable<T>(\n    size: number,\n    iterable: Iterable<T>,\n): Generator<T[], void, number | undefined> {\n    let array: T[] = [];\n    for (const value of iterable) {\n        if (array.push(value) >= size) {\n            size = (yield array) ?? size;\n            array = [];\n        }\n    }\n    if (array.length > 0) {\n        yield array;\n    }\n}\n/**\n * Limits a number to be within a given range.\n *\n * f(x, min, max) = y, where min <= y <= max\n *\n * @param num - The number to clamp\n * @param min - The minimum result value, inclusive\n * @param max - The maximum result value, inclusive\n *\n * @returns The clamped number\n *\n * @internal\n */\nexport function clamp(num: number, min: number, max: number): number {\n    return Math.min(max, Math.max(min, num));\n}\n/**\n * Wraps and then clamps a number within a given range.\n *\n * @param num - The number to wrap and then clamp\n * @param min - The minimum result value, inclusive\n * @param max - The wrap pivot and maximum result value, inclusive\n *\n * @returns The crwapped number\n *\n * @internal\n */\nexport function cwrap(num: number, min: number, max: number): number {\n    return clamp(wrap(num, max), min, max);\n}\n/**\n * Sorts a list in place.\n *\n * Works on complete lists as well as sublists and circular lists:\n * - Linked lists will keep the link to the next node beyond the sorted section\n * - Doubly linked lists will keep links to the prev and next nodes outside the sorted section\n *\n * @param node - The head of the list\n * @param len - The length of the list beginning from node\n * @param isDoubly - Whether node is a doubly linked node\n * @param compareFn - A function used to determine the order of elements.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n *\n * @returns The new head and tail of the sorted list\n *\n * @internal\n */\nexport function mergeSort<T, Node extends LinkedNode<T>>(\n    node: Node,\n    len: number,\n    isDoubly: boolean,\n    compareFn: CompareFn<T>,\n): [Node, Node] {\n    // Base case\n    if (len < 2) {\n        return [node, node];\n    }\n\n    // Split the list into two halves and sort them\n    len = len / 2;\n    const lens: [number, number] = [Math.ceil(len), Math.floor(len)];\n    const heads = mergeSort(node, lens[0], isDoubly, compareFn);\n    const tails = mergeSort(heads[1].next as Node, lens[1], isDoubly, compareFn);\n\n    // Group the heads and tails together\n    node = heads[1];\n    heads[1] = tails[0];\n    tails[0] = node;\n    tails[0].next = tails[1].next;\n\n    // Merge the sorted halves\n    const prev = (heads[0] as DoublyLinkedNode<T>).prev;\n    node = mergeSorted(heads, lens, isDoubly, compareFn);\n    isDoubly && ((node as DoublyLinkedNode<T>).prev = prev);\n\n    // Return the head and tail\n    return [node, tails[+(lens[0] < 1)]];\n}\n/**\n * Merges two sorted lists.\n *\n * @param nodes - The heads of the lists\n * @param lens - The lengths of the lists\n * @param isDoubly - Whether the lists are a doubly linked\n * @param compareFn - A function used to determine the order of elements.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n *\n * @returns The new head of the sorted list\n *\n * @internal\n */\nexport function mergeSorted<T, Node extends LinkedNode<T>>(\n    heads: [Node, Node],\n    lens: [number, number],\n    isDoubly: boolean,\n    compareFn: CompareFn<T>,\n): Node {\n    const root = {} as Node;\n\n    let node = root;\n    do {\n        const index = +(compareFn(heads[0].value, heads[1].value) > 0);\n        node.next = heads[index];\n        isDoubly && ((node.next as DoublyLinkedNode<T>).prev = node);\n        node = node.next as Node;\n        heads[index] = node.next as Node;\n        --lens[index];\n    } while (lens[0] > 0 && lens[1] > 0);\n\n    // Add any remaining nodes\n    node.next = heads[+(lens[0] < 1)];\n    isDoubly && node.next && ((node.next as DoublyLinkedNode<T>).prev = node);\n    return root.next as Node;\n}\n/**\n * Wraps a number around a pivot\n *\n * f(x, min, pivot) = {\n *    x, where x >= 0\n *    pivot + x, where x < 0\n * }\n *\n * @param num - The number to wrap\n * @param pivot - The number to pivot on\n *\n * @returns - The wrapped number\n *\n * @internal\n */\nexport function wrap(num: number, pivot: number): number {\n    return num < 0 ? pivot + num : num;\n}\n/**\n * Moves a given number of spaces forward in a list\n *\n * @param head - The head of the list\n * @param len - The number of spaces to move\n *\n * @returns - The node len spaces ahead from head\n *\n * @internal\n *\nexport function next<T, Node extends LinkedNode<T>>(head: Node, len: number): Node {\n    while (len-- > 0) {\n        head = head.next as Node;\n    }\n    return head;\n}\n*/","import { Queue } from './queue';\n\n/**\n * An implementation of the {@link Queue} interface using an array\n */\nexport class ArrayQueue<T> implements Queue<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * Instantiate the queue.\n     *\n     * @param elements - A set of elements to initialize the queue with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    dequeue(): T | undefined {\n        return this.size < 1 ? undefined : this.array.shift();\n    }\n\n    enqueue(element: T): number {\n        return this.array.push(element);\n    }\n\n    peek(): T | undefined {\n        return this.size < 1 ? undefined : this.array[0];\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Queue } from './queue';\n\n/**\n * A linked list implementation of the {@link Queue} interface\n */\nexport class LinkedQueue<T> implements Queue<T> {\n    /**\n     * The list containing every element.\n     */\n    protected list: List<T>;\n    /**\n     * Instantiate the queue.\n     *\n     * @param elements - A set of elements to initialize the queue with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList(elements);\n    }\n\n    clear(): void {\n        this.list.clear();\n    }\n\n    dequeue(): T | undefined {\n        return this.list.shift();\n    }\n\n    enqueue(element: T): number {\n        return this.list.push(element);\n    }\n\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","import { Stack } from './stack';\n\n/**\n * An implementation of the {@link Stack} interface using an array\n */\nexport class ArrayStack<T> implements Stack<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * Instantiate the stack.\n     *\n     * @param elements - A set of elements to initialize the stack with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    peek(): T | undefined {\n        return this.array[this.array.length - 1];\n    }\n\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n\n    push(element: T): number {\n        return this.array.push(element);\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        const array = this.array;\n        for (let i = array.length; i > 0; yield array[--i]) {}\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Stack } from './stack';\n\n/**\n * A linked list implementation of the {@link Stack} interface\n */\nexport class LinkedStack<T> implements Stack<T> {\n    /**\n     * The list containing every element.\n     */\n    protected list: List<T>;\n    /**\n     * Instantiate the stack.\n     *\n     * @param elements - A set of elements to initialize the stack with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList();\n        for (const element of elements || []) {\n            this.push(element);\n        }\n    }\n\n    clear(): void {\n        this.list.clear();\n    }\n\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n\n    pop(): T | undefined {\n        return this.list.shift();\n    }\n\n    push(element: T): number {\n        return this.list.unshift(element);\n    }\n\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","import { AATreeNode } from './aaTreeNode';\nimport { CompareFn } from '..';\n\n/**\n * \n * @param value \n * @param node \n * @param compareFn \n * \n * @returns \n * \n * @internal\n */\nexport function insert<T>(value: T, node: AATreeNode<T> | undefined, compareFn: CompareFn<T>): AATreeNode<T> {\n    // If the tree is empty\n    if (node == null) {\n        return {level: 1, value};\n    }\n\n    // If value <= node\n    if (compareFn(value, node.value) < 0) {\n        node.left = insert(value, node.left, compareFn);\n    \n    // If value > node\n    } else {\n        node.right = insert(value, node.right, compareFn);\n    }\n\n    // Balance the tree\n    node = skew(node);\n    node = split(node);\n    return node!;\n}\n/**\n * \n * @param value \n * @param node \n * @param compareFn \n * \n * @returns \n * \n * @internal\n */\nexport function remove<T>(value: T, node: AATreeNode<T> | undefined, compareFn: CompareFn<T>): [AATreeNode<T> | undefined, boolean] {\n    if (node == null) {\n        return [undefined, false];\n    }\n\n    let found = false;\n    const comparison = compareFn(value, node.value);\n    if (comparison < 0) {\n        [node.left, found] = remove(value, node.left, compareFn);\n    } else if (comparison > 0) {\n        [node.right, found] = remove(value, node.right, compareFn);\n    } else if (node.left != null) {\n        found = true;\n\n        // Replace node with predecessor\n        let par = node.left;\n        let chi = par.right;\n        if (chi == null) {\n            node.value = par.value;\n            node.left = par.left;\n        } else {\n            while (chi.right != null) {\n                par = chi;\n                chi = chi.right;\n            }\n            node.value = chi.value;\n            par.right = chi.left;\n        }\n\n    } else if (node.right != null) {\n        found = true;\n\n        // Replace node with successor\n        let par = node.right;\n        let chi = par.left;\n        if (chi == null) {\n            node.value = par.value;\n            node.right = par.right;\n        } else {\n            while (chi.left != null) {\n                par = chi;\n                chi = chi.left;\n            }\n            node.value = chi.value;\n            par.left = chi.right;\n        }\n\n    } else {\n        return [undefined, true];\n    }\n\n    if (!found) {\n        return [node, false];\n    }\n\n    // Decrease levels.\n    let level = Math.min(node.left?.level ?? 0, node.right?.level ?? 0) + 1;\n    if (level < node.level) {\n        node.level = level;\n        if (node.right != null && level < node.right.level) {\n            node.right.level = level;\n        }\n    }\n\n    // Rebalance the tree.\n    node = skew(node)!;\n    node.right = skew(node.right);\n    if (node.right != null) {\n        node.right.right = skew(node.right.right);\n    }\n    node = split(node)!;\n    node.right = split(node.right);\n    return [node, true];\n}\n\n/**\n * \n * @param node \n * \n * @returns \n * \n * @internal\n */\nexport function skew<T>(node: AATreeNode<T> | undefined): AATreeNode<T> | undefined {\n    if (node == null || node.left == null || node.level != node.left.level) {\n        return node;\n    }\n    const left = node.left;\n    node.left = left.right;\n    left.right = node;\n    return left;\n}\n/**\n * \n * @param node \n * \n * @returns \n * \n * @internal\n */\nexport function split<T>(node: AATreeNode<T> | undefined): AATreeNode<T> | undefined {\n    if (node == null \n    || node.right == null \n    || node.right.right == null \n    || node.level != node.right.right.level) {\n        return node;\n    }\n    const right = node.right;\n    node.right = right.left;\n    right.left = node;\n    ++right.level;\n    return right;\n}","import { CompareFn } from \"..\";\nimport { AATreeNode } from \"./aaTreeNode\";\nimport { clone, inOrderTraverse, preOrderTraverse } from \"./binaryTreeUtils\";\nimport { SortedTree } from \"./sortedTree\";\nimport { insert, remove } from './aaTreeUtils';\nimport { isArray } from \"src/array/utils\";\n\n/**\n * An AA tree is a form of balanced tree used for storing and retrieving ordered data efficiently\n * ([source](https://en.wikipedia.org/wiki/AA_tree)).\n * \n * AA trees are named for Arne Andersson, their inventor. They are a variation of the red–black tree, \n * which supports efficient addition and deletion of entries. Unlike red–black trees, additional \n * constraints on the balancing mechanism greatly simplifies the implementation as well as \n * maintenance operations; While a red–black tree needs to consider seven different shapes \n * to properly balance the tree, an AA tree only needs to consider two shapes.\n * \n * The performance of an AA tree is equivalent to the performance of a red–black tree. \n * While an AA tree makes more rotations than a red-black tree, the simpler algorithms \n * tend to be faster, which balances out to similar performance. A red-black tree is \n * more consistent in its performance, but an AA tree tends to be flatter, which results \n * in slightly faster search times.\n */\nexport class AATree<T> implements SortedTree<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The node at the \"top\" of the heap.\n     */\n    protected root: AATreeNode<T> | undefined;\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>) {\n        this.compare = compareFn;\n        this.length = 0;\n        this.build(elements ?? []);\n    }\n\n    add(element: T): number {\n        this.root = insert(element, this.root, this.compare);\n        return ++this.length;\n    }\n\n    clear(): void {\n        this.root = undefined;\n        this.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        let node = this.root;\n        while (node != null) {\n            if (element === node.value) {\n                return true;\n            }\n            node = (this.compare(element, node.value) < 0) ? node.left : node.right;\n        }\n        return false;\n    }\n\n    delete(element: T): boolean {\n        const res = remove(element, this.root, this.compare);\n        this.root = res[0];\n        this.length -= +res[1];\n        return res[1];\n    }\n\n    max(): T | undefined {\n        let node = this.root;\n        if (node == null) {\n            return undefined;\n        }\n        while (node.right != null) {\n            node = node.right;\n        }\n        return node.value;\n    }\n\n    min(): T | undefined {\n        let node = this.root;\n        if (node == null) {\n            return undefined;\n        }\n        while (node.left != null) {\n            node = node.left;\n        }\n        return node.value;\n    }\n\n    pop(): T | undefined {\n        const value = this.max();\n        if (value != null) {\n            this.root = remove(value, this.root, this.compare)[0];\n            --this.length;\n        }\n        return value;\n    }\n\n    shift(): T | undefined {\n        const value = this.min();\n        if (value != null) {\n            this.root = remove(value, this.root, this.compare)[0];\n            --this.length;\n        }\n        return value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        for (const node of inOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.delete(curElement)) {\n            this.add(newElement);\n            return true;\n        }\n        return false;\n    }\n\n    protected build(obj: Iterable<T>): void {\n        if (isArray(obj)) {\n            for(let i = 0; i < obj.length; ++i) {\n                this.add(obj[i]);\n            }\n        } else if (obj instanceof AATree\n        && this.compare === obj.compare) {\n            this.root = clone(obj.root);\n            this.length = obj.size;\n        } else {\n            for (const element of obj) {\n                this.add(element);\n            }\n        }\n    }\n}\n","import { LinkedNode } from 'src/list';\nimport { BinaryTreeNode } from \"./binaryTreeNode\";\n\n/**\n *\n * @param node\n *\n * @returns\n *\n * @internal\n */\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: Node | undefined): Node | undefined {\n    if (node == null) {\n        return undefined;\n    }\n    const out: Node = Object.assign({}, node);\n    let stack: LinkedNode<Node> | undefined = {value: out};\n    do {\n        node = stack.value;\n        stack = stack.next;\n        if (node.left) {\n            stack = {next: stack, value: node.left = Object.assign({}, node.left)};\n        } \n        if (node.right) {\n            stack = {next: stack, value: node.right = Object.assign({}, node.right)};\n        }\n    } while (stack != null);\n    return out;\n}\n/**\n *\n * @param node\n *\n * @returns\n *\n * @internal\n */\nexport function *inOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    let stack: LinkedNode<Node> | undefined = undefined;\n\n    while (node != null) {\n        stack = {next: stack, value: node};\n        node = node.left;\n    }\n\n    while (stack != null) {\n        node = stack.value;\n        stack = stack.next;\n        yield node;\n        node = node.right;\n        while (node != null) {\n            stack = {next: stack, value: node};\n            node = node.left;\n        }\n    }\n}\n/*\n *\n * @param node\n *\n * @returns\n *\n * @internal\n *\n export function *inOrderArrayTraverse<T>(array: T[]): Generator<T> {\n    const stack: number[] = [];\n\n    for (let i = 0; i < array.length; i += i + 1) {\n        stack.push(i);\n    }\n    \n    while (stack.length > 0) {\n        let i = stack.pop()!;\n        yield array[i];\n        for (i += i + 2; i < array.length; i += i + 1) {\n            stack.push(i);\n        }\n    }\n}\n*/\n/*\n *\n * @param node\n *\n * @returns\n *\n * @internal\n *\nexport function *levelOrderTraverse<T>(\n    node: BinaryTreeNode<T> | undefined,\n): Generator<BinaryTreeNode<T>> {\n    const q = new LinkedQueue<BinaryTreeNode<T> | undefined>([node]);\n    do {\n        const node = q.dequeue()!;\n        if (node != null) {\n            yield node;\n            q.enqueue(node.left);\n            q.enqueue(node.right);\n        }\n    } while (q.size > 0);\n}\n*/\n/*\n *\n * @param node\n *\n * @returns\n *\n * @internal\n *\nexport function *postOrderTraverse<T>(\n    node: BinaryTreeNode<T> | undefined,\n): Generator<BinaryTreeNode<T>> {\n    interface Meta {\n        seen: boolean;\n        node?: BinaryTreeNode<T>;\n    }\n    const stack = new LinkedStack<Meta>([{ seen: false, node }]);\n    do {\n        const meta = stack.pop()!;\n        if (meta.node != null) {\n            if (meta.seen) {\n                yield meta.node;\n            } else {\n                meta.seen = true;\n                stack.push(meta);\n                stack.push({ seen: false, node: meta.node.right });\n                stack.push({ seen: false, node: meta.node.left });\n            }\n        }\n    } while (stack.size > 0);\n}\n*/\n/**\n *\n * @param node\n *\n * @returns\n *\n * @internal\n */\nexport function *preOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    let stack: LinkedNode<Node | undefined> | undefined = {value: node};\n    do {\n        node = stack.value;\n        stack = stack.next;\n        if (node != null) {\n            yield node;\n            stack = {next: stack, value: node.right};\n            stack = {next: stack, value: node.left};\n        }\n    } while (stack != null);\n}\n/**\n *\n * @param elements\n *\n * @returns\n *\n * @internal\n */\n export function toBinaryTree<T>(elements: T[] | undefined): BinaryTreeNode<T> | undefined {\n    if (elements == null || elements.length < 1) {\n        return undefined;\n    }\n    const n = elements.length;\n    const nodes = new Array(n);\n    nodes[0] = { value: elements[0] };\n    for (let i = 1; i < n; ++i) {\n        const par = nodes[(i - 1) >>> 1];\n        const node = { value: elements[i] };\n        nodes[i] = node;\n        if (i & 1) {\n            par.left = node;\n        } else {\n            par.right = node;\n        }\n    }\n    return nodes[0];\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}