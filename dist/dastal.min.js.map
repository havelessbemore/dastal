{"version":3,"sources":["webpack://Dastal/webpack/universalModuleDefinition","webpack://Dastal/webpack/bootstrap","webpack://Dastal/webpack/runtime/define property getters","webpack://Dastal/webpack/runtime/hasOwnProperty shorthand","webpack://Dastal/webpack/runtime/make namespace object","webpack://Dastal/./src/collection/iteratorUtils.ts","webpack://Dastal/./src/math/numberUtils.ts","webpack://Dastal/./src/collection/arrayUtils.ts","webpack://Dastal/./src/collection/stringUtils.ts","webpack://Dastal/./src/collection/index.ts","webpack://Dastal/./src/heap/utils.ts","webpack://Dastal/./src/heap/binaryHeap.ts","webpack://Dastal/./src/tree/binaryTreeUtils.ts","webpack://Dastal/./src/heap/skewHeap.ts","webpack://Dastal/./src/list/arrayList.ts","webpack://Dastal/./src/list/utils.ts","webpack://Dastal/./src/list/doublyLinkedList.ts","webpack://Dastal/./src/list/linkedList.ts","webpack://Dastal/./src/math/u32.ts","webpack://Dastal/./src/queue/arrayQueue.ts","webpack://Dastal/./src/queue/linkedQueue.ts","webpack://Dastal/./src/segmentTree/inOrderSegmentTree.ts","webpack://Dastal/./src/segmentTree/levelOrderSegmentTree.ts","webpack://Dastal/./src/stack/arrayStack.ts","webpack://Dastal/./src/stack/linkedStack.ts","webpack://Dastal/./src/tree/aaTree.ts","webpack://Dastal/./src/tree/avlTree.ts"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","always","fn","next","done","fill","length","undefined","first","n","iterator","res","join","iterators","res2","never","once","skip","bind","split","iter","clamp","num","min","max","Math","wrapLeft","wrapRight","wrap","MAX_ARRAY_LENGTH","MAX_SAFE_ARGUMENT_LENGTH","isArray","Array","isTypedArray","TypedArray","getPrototypeOf","Uint8Array","splice","array","start","count","elements","maxStepSize","stepSize","maxElems","out","RangeError","pad","str","maxLen","fillString","len","diff","padStart","padEnd","isCollection","bubbleUp","index","compareFn","parentIndex","floor","parent","heapify","i","sinkDown","childIndex","child","skewMerge","heaps","lists","push","list","tree","right","compare","a","b","tail","pop","mergeKSorted","heap","node","left","BinaryHeap","this","addAll","element","indexOf","last","size","curElement","newElement","inOrderTraverse","preOrderTraverse","removeStack","stack","dir","edge","to","temp","successorStack","predecessorStack","from","label","clone","assign","leftmost","leftmostStack","rightmostStack","rightmost","search","comp","searchStack","dupeWeight","paths","toBinaryTree","nodes","par","SkewHeap","merge","comparator","ArrayList","copyWithin","callback","prev","shift","slice","sort","unshift","arguments","linkedMergeSort","isDoubly","lens","ceil","heads","tails","linkedMergeSorted","DoublyLinkedList","_addAll","_get","nodeA","nodeB","head","view","LinkedList","_copyWithin","nodeC","nodeD","remove","deleted","newTail","add","bitsSet","invert","msp","u32","isPow2","lsb","lsp","lsps","msb","msps","reverse","ArrayQueue","LinkedQueue","clear","InOrderSegmentTree","combine","build","mask","MAX_SIZE","set","offset","operation","dc","dp","LevelOrderSegmentTree","level","shrink","grow","aggregate","cap","log2","ArrayStack","LinkedStack","AATree","allowDuplicates","sentinel","skew","removed","delete","AVLTree","balanceFactor","balance","rotateR","rotateL","P","R","L"],"mappings":"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","file":"dastal.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Dastal\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Dastal\"] = factory();\n\telse\n\t\troot[\"Dastal\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Get an iterator that always returns a given value.\n */\nexport function always<T = any>(fn: () => T): Iterator<T> {\n    return { next: () => ({ done: false, value: fn() }) };\n}\n/**\n * Get an iterator that returns a value a given amount of times.\n */\nexport function fill<T = any>(length: number, fn: () => T): Iterator<T> {\n    return {\n        next: () => {\n            if (length < 1) {\n                return { done: true, value: undefined };\n            }\n            --length;\n            return { done: false, value: fn() };\n        },\n    };\n}\n/**\n * Iterate through the first num elements of an iterator.\n *\n * @param n - The number of elements to iterate.\n * @param iterator - The iterator.\n *\n * @returns - An iterator limited to the next n elements.\n */\nexport function first<T = any>(n: number, iterator: Iterator<T>): Iterator<T> {\n    return {\n        next: () => {\n            if (n < 1) {\n                return { done: true, value: undefined };\n            }\n            const res = iterator.next();\n            n = res.done ? 0 : n - 1;\n            return res;\n        },\n    };\n}\n/**\n * Join multiple iterators into one.\n *\n * @param iterators - The iterators to join.\n */\nexport function join<T = any>(iterators: Iterator<Iterator<T>>): Iterator<T> {\n    let iterator: Iterator<T> | undefined = { next: () => ({ done: true, value: undefined }) };\n    return {\n        next: () => {\n            if (iterator == null) {\n                return { done: true, value: undefined };\n            }\n            let res = iterator.next();\n            while (res.done) {\n                const res2 = iterators.next();\n                if (res2.done) {\n                    iterator = undefined;\n                    return { done: true, value: undefined };\n                }\n                iterator = res2.value;\n                res = iterator.next();\n            }\n            return res;\n        },\n    };\n}\n/**\n * Get an empty iterator.\n */\nexport function never<T = any>(): Iterator<T> {\n    return { next: () => ({ done: true, value: undefined }) };\n}\n/**\n * Wrap a value in an iterator.\n */\nexport function once<T = any>(fn: () => T): Iterator<T> {\n    let done = false;\n    return {\n        next: () => {\n            const res = { done, value: fn() };\n            done = true;\n            fn = () => undefined!;\n            return res;\n        },\n    };\n}\n/**\n * Skip the next num elements of an iterator.\n *\n * @param n - The number of elements to skip.\n * @param iterator - The iterator.\n *\n * @returns - The iterator after skipping n elements.\n */\nexport function skip<T = any>(n: number, iterator: Iterator<T>): Iterator<T> {\n    let fn = () => {\n        let res: IteratorResult<T> = { done: false, value: undefined! };\n        while (n-- > 0 && !res.done) {\n            res = iterator.next();\n        }\n        fn = iterator.next.bind(iterator);\n        return res;\n    };\n    return { next: () => fn() };\n}\n/**\n * Split an iterator into multiple iterators of a given length.\n *\n * @param length - The length of each iterator.\n * @param iterator - The iterator to split.\n *\n * @returns - An iterator of the resulting iterators.\n */\nexport function split<T = any>(length: number, iterator: Iterator<T>): Iterator<Iterator<T>> {\n    if (length < 1) {\n        return { next: () => ({ done: true, value: undefined }) };\n    }\n    let done = false;\n    return {\n        next: () => {\n            if (done) {\n                return { done, value: undefined };\n            }\n            const iter = first(length, iterator);\n            const res = iter.next();\n            if (res.done) {\n                done = true;\n                return { done, value: undefined };\n            }\n            return { done, value: join([once(() => res.value), iter][Symbol.iterator]()) };\n        },\n    };\n}\n","/**\n * Limits a number to be within a given range.\n *\n * f(x, min, max) = y, where min <= y <= max\n *\n * @param num - The number to clamp\n * @param min - The minimum result value, inclusive\n * @param max - The maximum result value, inclusive\n *\n * @returns The clamped number\n */\nexport function clamp(num: number, min: number, max: number): number {\n    return Math.min(max, Math.max(min, num));\n}\n/**\n * Wraps a number if below a given range\n *\n * f(x, min, max) = {\n *    x, where x >= min\n *    max - (min - x), where x < min\n * }\n *\n * @param num - The number to wrap\n * @param min - The minimum result value, inclusive\n * @param max - The maximum result value, inclusive\n *\n * @returns - The wrapped number\n */\nexport function wrapLeft(num: number, min: number, max: number): number {\n    return num < min ? max - min + num : num;\n}\n/**\n * Wraps a number if above a given range\n *\n * f(x, min, max) = {\n *    x, where x <= max\n *    min + (x - max), where x > max\n * }\n *\n * @param num - The number to wrap\n * @param min - The minimum result value, inclusive\n * @param max - The maximum result value, inclusive\n *\n * @returns - The wrapped number\n */\nexport function wrapRight(num: number, min: number, max: number): number {\n    return num > max ? min + (num - max) : num;\n}\n/**\n * Wraps a number if outside a given range\n *\n * @param num - The number to wrap\n * @param min - The minimum result value, inclusive\n * @param max - The maximum result value, inclusive\n *\n * @returns - The wrapped number\n */\nexport function wrap(num: number, min: number, max: number): number {\n    return num < min ? max - min + num : wrapRight(num, min, max);\n}\n","import { first } from 'src/collection/iteratorUtils';\nimport { clamp, wrapLeft } from 'src/math/numberUtils';\n\n/**\n * The maximum length of an array.\n *\n * According to the [ECMA-262](https://tc39.es/ecma262/#array-index):\n *     0 <= array.length <= 2^32 - 1\n *\n * If this value should be updated, please\n * submit a pull request with details supporting a new max length.\n */\nexport const MAX_ARRAY_LENGTH = 4294967295;\n/**\n * The maximum number of arguments that can be safely accepted by a function.\n *\n * According to the [ECMA-262](https://tc39.es/ecma262/#sec-list-and-record-specification-type), there is no maximum. In practice, different\n * environments impose their own limit ([source](https://stackoverflow.com/questions/22747068/is-there-a-max-number-of-arguments-javascript-functions-can-accept)).\n *\n * This value was chosen through research, local testing and iteration. The actual number of arguments\n * accepted in an environment may be larger but hopefully not smaller. If errors are raised,\n * please submit a bug with your environment details and a new max length.\n */\nexport const MAX_SAFE_ARGUMENT_LENGTH = 32767;\n/**\n * Check if a value is an Array or TypedArray.\n *\n * @param obj - The value to check.\n *\n * @returns `true` if an Array or TypedArray, otherwise `false`.\n */\nexport function isArray<T = any>(obj: unknown): obj is T[] {\n    return obj instanceof Array || isTypedArray(obj);\n}\n/**\n * Check if a value is a TypedArray.\n *\n * See [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)\n * for more details.\n *\n * @param obj - The value to check.\n *\n * @returns `true` if a TypedArray, otherwise `false`.\n */\nexport const isTypedArray = (() => {\n    const TypedArray = Object.getPrototypeOf(Uint8Array);\n    return function isTypedArray<T = any>(obj: unknown): obj is T[] {\n        return obj instanceof TypedArray;\n    };\n})();\n/**\n * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n *\n * Contrary to Array.splice, this will not throw an error if too many new elements are given as arguments.\n *\n * @param array - The array to splice.\n * @param start - The zero-based location in the array from which to start removing elements.\n * @param count - The number of elements to remove.\n * @param elements - The new elements to splice in.\n *\n * @returns - An array containing the elements that were deleted.\n */\nexport function splice<T>(array: T[], start?: number, count?: number, elements?: Iterable<T>): T[] {\n    start = clamp(wrapLeft(start ?? 0, 0, array.length), 0, array.length);\n    count = clamp(count ?? array.length, 0, array.length - start);\n\n    // Base case\n    if (elements == null) {\n        return array.splice(start, count);\n    }\n\n    const maxStepSize = MAX_SAFE_ARGUMENT_LENGTH - 2;\n    const iterator = elements[Symbol.iterator]();\n\n    // Perform the initial splice\n    let stepSize = array.length - count;\n    const maxElems = MAX_ARRAY_LENGTH - stepSize;\n    let n = Math.min(maxStepSize, maxElems);\n    const out = array.splice(start, count, ...{ [Symbol.iterator]: () => first(n, iterator) });\n    stepSize = array.length - stepSize;\n    start += stepSize;\n\n    // Splice in new elements as long as there is space in the array\n    for (n = maxElems - stepSize; n >= maxStepSize && stepSize >= maxStepSize; n -= stepSize) {\n        stepSize = array.length;\n        array.splice(start, 0, ...{ [Symbol.iterator]: () => first(maxStepSize, iterator) });\n        stepSize = array.length - stepSize;\n        start += stepSize;\n    }\n    if (n > 0 && stepSize >= maxStepSize) {\n        array.splice(start, 0, ...{ [Symbol.iterator]: () => first(n, iterator) });\n    }\n\n    // If maximum array capacity reached\n    if (iterator.next().done != true) {\n        throw new RangeError('Invalid array length');\n    }\n\n    return out;\n}\n","/**\n * Pad a string from both sides.\n */\nexport function pad(str: string, maxLen: number, fillString: string): string {\n    const len = str.length;\n    if (len >= maxLen) {\n        return str;\n    }\n    const diff = maxLen - len;\n    return str.padStart(len + diff / 2, fillString).padEnd(len + diff, fillString);\n}\n","import { Collection } from './collection';\n\nexport * as ArrayUtils from './arrayUtils';\nexport * from './collection';\nexport * as IteratorUtils from './iteratorUtils';\nexport * as StringUtils from './stringUtils';\n\n/**\n * Check if a value is a {@link Collection}.\n *\n * @param obj - The value to check.\n *\n * @returns - `true` if obj is a Collection, `false` otherwise.\n */\nexport function isCollection(obj: any): obj is Collection<unknown> {\n    return (\n        obj != null && typeof obj['size'] === 'number' && typeof obj[Symbol.iterator] === 'function'\n    );\n}\n","import { LinkedNode } from 'src/list';\nimport { BinaryTreeNode } from 'src/tree/binaryTreeNode';\nimport { CompareFn } from '..';\n\n/**\n * @internal\n */\nexport function bubbleUp<T>(index: number, compareFn: CompareFn<T>, array: Array<T>): void {\n    const value = array[index];\n\n    // Until we reach the top of the heap\n    while (index > 0) {\n        // Get the parent\n        const parentIndex = Math.floor((index + 1) / 2) - 1;\n        const parent = array[parentIndex]!;\n\n        // If the parent is above or equal to value, the heap is in order\n        if (compareFn(parent, value) <= 0) {\n            break;\n        }\n\n        // Swap the parent with value and continue\n        array[parentIndex] = value;\n        array[index] = parent;\n        index = parentIndex;\n    }\n}\n/**\n * @internal\n */\nexport function heapify<T>(compareFn: CompareFn<T>, array: T[]): void {\n    for (let i = (array.length + 1) >>> 1; i > 0; sinkDown(--i, compareFn, array)) {}\n}\n/**\n * @internal\n */\nexport function mergeKSorted<T>(compareFn: CompareFn<T>, lists: LinkedNode<T>[]): LinkedNode<T> {\n    // Heapify the list of lists based on\n    // the value at the head of each list.\n    const compare: CompareFn<LinkedNode<T>> = (a, b) => compareFn(a.value, b.value);\n    heapify(compare, lists);\n\n    // Combine the lists into a single list.\n    const list: LinkedNode<T> = lists[0];\n    for (let tail = list; lists.length > 1; tail = tail.next) {\n        lists[0] = lists[0].next ?? lists.pop()!;\n        sinkDown(0, compare, lists);\n        tail.next = lists[0];\n    }\n\n    return list;\n}\n/**\n * @internal\n */\nexport function sinkDown<T>(index: number, compareFn: CompareFn<T>, array: Array<T>): void {\n    const n = array.length;\n    const value = array[index];\n    do {\n        // Compute the left child's index\n        let childIndex = 2 * index + 1;\n\n        // If no children exist\n        if (childIndex >= n) {\n            break;\n        }\n\n        // Decide which child to compare with\n        let child = array[childIndex];\n        if (childIndex + 1 < n && compareFn(array[childIndex + 1], child) <= 0) {\n            child = array[++childIndex]!;\n        }\n\n        // If value <= child\n        if (compareFn(value, child) <= 0) {\n            break;\n        }\n\n        // Swap value and child\n        array[index] = child;\n        array[childIndex] = value;\n        index = childIndex;\n    } while (true);\n}\n/**\n * See: https://en.wikipedia.org/wiki/Skew_heap#Merging_two_heaps\n *\n * @param compareFn - A function used to determine the order of the heap.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n * @param heaps - An iterable of heaps to merge\n *\n * @returns The new heap\n */\nexport function skewMerge<T>(\n    compareFn: CompareFn<T>,\n    heaps: (BinaryTreeNode<T> | undefined)[],\n): BinaryTreeNode<T> | undefined {\n    // Remove undefineds and initialize a list for each heap\n    const lists: LinkedNode<BinaryTreeNode<T>>[] = [];\n    for (let i = 0; i < heaps.length; ++i) {\n        if (heaps[i] != null) {\n            lists.push({ value: heaps[i]! });\n        }\n    }\n\n    // Check if nothing to merge with\n    if (lists.length < 2) {\n        return lists[0]?.value;\n    }\n\n    // Split each heap into subheaps by cutting every right path; From the root\n    // node, sever the right node to make the right child its own heap. Repeat\n    // until you can't go right. This will turn each heap into a list of heaps\n    // where the root either only has a left child or no children at all. The\n    // lists of heaps will be in desc order (from bottom to top).\n    for (let i = 0; i < lists.length; ++i) {\n        let list = lists[i];\n        let tree: BinaryTreeNode<T> | undefined = list.value;\n        while ((tree = tree.right)) {\n            list = { next: list, value: tree };\n        }\n        lists[i] = list;\n    }\n\n    // Combine the lists into a single list in desc order\n    let list: LinkedNode<BinaryTreeNode<T>> | undefined = mergeKSorted(\n        (a, b) => compareFn(b.value, a.value),\n        lists,\n    );\n\n    // While there are still multiple heaps, iteratively combine\n    // the first two (from left to right). If the root of the second-to-first\n    // subtree has a left child, swap it to be the right child. Link the root\n    // of the last subtree as the left child of the second-to-first subtree.\n    let heap = list.value;\n    while ((list = list.next)) {\n        const node = list.value;\n        node.right = node.left;\n        node.left = heap;\n        heap = node;\n    }\n\n    return heap;\n}\n","import { isArray, MAX_ARRAY_LENGTH } from 'src/collection/arrayUtils';\nimport { CompareFn } from '..';\nimport { Heap } from './heap';\nimport { bubbleUp, heapify, sinkDown } from './utils';\n\n/**\n * A binary heap is a heap implemented as a binary tree with an additional shape property\n * ([source](https://en.wikipedia.org/wiki/Binary_heap)).\n *\n * **Shape property**: Must be a complete binary tree. This means all levels of the tree\n * (except possibly the last one) are fully filled. If the last level of the tree is incomplete,\n * the nodes of that level are filled from left to right.\n *\n * #### Complexity\n *\n * | Property | Average | Worst |\n * | :------- | :------ | :---- |\n * | Space    | O(n)    | O(n)\n * | Push     | O(1)    | O(log n)\n * | Peek     | O(1)\t| O(1)\n * | Pop      | O(log n)| O(log n)\n * | Search   | O(n)    | O(n)\n */\nexport class BinaryHeap<T> implements Heap<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * Instantiate a heap.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>) {\n        this.compare = compareFn;\n        this.array = [];\n        this.addAll(elements ?? []);\n    }\n\n    addAll(elements: Iterable<T>): number {\n        const array = this.array;\n        const length = array.length;\n\n        if (isArray(elements)) {\n            if (array.length + elements.length > MAX_ARRAY_LENGTH) {\n                throw new RangeError('Invalid heap length');\n            }\n            for (let i = 0; i < elements.length; ++i) {\n                array.push(elements[i]);\n            }\n        } else {\n            for (const element of elements) {\n                if (array.length >= MAX_ARRAY_LENGTH) {\n                    throw new RangeError('Invalid heap length');\n                }\n                array.push(element);\n            }\n        }\n\n        // Update the heap\n        if (length < array.length) {\n            heapify(this.compare, array);\n        }\n\n        return array.length;\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        return this.array.indexOf(element) >= 0;\n    }\n\n    delete(element: T): boolean {\n        const index = this.array.indexOf(element);\n        if (index < 0) {\n            return false;\n        }\n\n        // If deleting the last value\n        const last = this.array.pop()!;\n        if (index >= this.array.length) {\n            return true;\n        }\n\n        // Add the last value to the\n        // deleted index and update the heap\n        this.array[index] = last;\n        sinkDown(index, this.compare, this.array);\n        bubbleUp(index, this.compare, this.array);\n        return true;\n    }\n\n    merge(heap: Heap<T>): this {\n        const array = this.array;\n\n        if (heap.size < 1) {\n            return this;\n        }\n\n        if (array.length + heap.size > MAX_ARRAY_LENGTH) {\n            throw new RangeError('Invalid heap length');\n        }\n\n        for (const element of heap) {\n            array.push(element);\n        }\n\n        heapify(this.compare, array);\n        return this;\n    }\n\n    peek(): T | undefined {\n        return this.array.length > 0 ? this.array[0] : undefined;\n    }\n\n    pop(): T | undefined {\n        if (this.array.length < 1) {\n            return undefined;\n        }\n\n        // Get the root and the last value\n        const value = this.array[0];\n        const last = this.array.pop();\n\n        // If value != last\n        if (this.array.length > 0) {\n            // Move the last value to the root and update the heap\n            this.array[0] = last!;\n            sinkDown(0, this.compare, this.array);\n        }\n\n        return value;\n    }\n\n    push(value: T): number {\n        // Add new value to the end of the heap\n        this.array.push(value);\n\n        // Update the heap\n        bubbleUp(this.array.length - 1, this.compare, this.array);\n        return this.size;\n    }\n\n    pushPop(value: T): T {\n        // If empty or value is <= to root\n        if (this.array.length < 1 || this.compare(value, this.array[0]) <= 0) {\n            return value;\n        }\n\n        // Swap the root and value\n        const root = this.array[0];\n        this.array[0] = value;\n        sinkDown(0, this.compare, this.array);\n        return root;\n    }\n\n    replace(value: T): T | undefined {\n        // If empty\n        if (this.array.length < 1) {\n            this.array.push(value);\n            return undefined;\n        }\n\n        // Swap the root with value\n        const root = this.array[0];\n        this.array[0] = value;\n        value = root;\n\n        // Update the heap\n        sinkDown(0, this.compare, this.array);\n        return value;\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    *sorted(): Iterable<T> {\n        if (this.array.length < 1) {\n            return;\n        }\n        const array = this.array;\n        const heap = new BinaryHeap<number>((a, b) => this.compare(array[a], array[b]), [0]);\n        do {\n            let index = heap.pop()!;\n            if (index < array.length) {\n                yield array[index];\n                index = 2 * index + 1;\n                index < array.length && heap.push(index);\n                ++index < array.length && heap.push(index);\n            }\n        } while (heap.size > 0);\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        const index = this.array.indexOf(curElement);\n        if (index < 0) {\n            return false;\n        }\n        this.array[index] = newElement;\n        sinkDown(index, this.compare, this.array);\n        bubbleUp(index, this.compare, this.array);\n        return true;\n    }\n}\n","import { pad } from 'src/collection/stringUtils';\nimport { LinkedNode } from 'src/list';\nimport { CompareFn } from '..';\nimport { BinaryTreeNode } from './binaryTreeNode';\n\n/**\n * @internal\n */\nexport interface Edge<Node extends BinaryTreeNode<unknown>> {\n    label?: 'left' | 'right';\n    from?: Node;\n    to?: Node;\n}\n/**\n * [source](https://stackoverflow.com/questions/51419176/how-to-get-a-subset-of-keyof-t-whose-value-tk-are-callable-functions-in-typ)\n * \n * @internal\n *\nexport type KeyOfType<T, U> = {[K in keyof T]: T[K] extends U ? K: never}[keyof T];\n*/\n/**\n * @internal\n */\nexport function debug<N extends BinaryTreeNode<T>, T = any>(\n    root: N | undefined,\n    mapFn?: (node: N) => any,\n): void {\n    mapFn = mapFn == null ? (n) => n.value : mapFn;\n\n    // Turn the tree into an array in level-order\n    const array: string[] = [];\n    for (const node of levelOrderTraverse(root, true)) {\n        array.push(node ? `${mapFn(node)}` : '?');\n    }\n\n    // If empty\n    if (array.length < 1) {\n        console.log('<empty>\\n');\n        return;\n    }\n\n    // Find the longest value string\n    const lenV = array.reduce((p, c) => Math.max(p, c.length), 0);\n\n    // Pad each value\n    for (let i = 0; i < array.length; ++i) {\n        array[i] = pad(array[i], lenV, ' ');\n    }\n\n    // Split values into levels\n    const levels = [];\n    for (let n = 1; array.length > 0; n *= 2) {\n        levels.push(array.splice(0, n));\n    }\n\n    // Initialize formatting variables\n    let branch = '_'.repeat(1 + lenV / 2);\n    let offset = '';\n    const offsetOffset = ' '.repeat(branch.length);\n    let separator = ' '.repeat(1 + ((lenV - 1) & 1));\n    const separatorOffset = ' '.repeat(lenV);\n\n    // Build the last level\n    array.length = levels.length;\n    array[array.length - 1] = levels.pop()!.join(separator);\n\n    // Build remaining levels in reverse\n    for (let n = levels.length - 1; n >= 0; --n) {\n        const level = levels.pop()!;\n        for (let j = 0; j < level.length; ++j) {\n            level[j] = branch + level[j] + branch;\n        }\n        array[n] = offset + level.join(separator);\n        branch += branch;\n        offset += offset + offsetOffset;\n        separator += separator + separatorOffset;\n    }\n\n    // Output\n    console.log(array.join('\\n'), '\\n');\n}\n/**\n * @internal\n */\nexport function removeStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n    dir = true,\n): LinkedNode<Edge<Node>> {\n    let edge = stack.value;\n    let node = edge.to;\n\n    // Input check\n    if (node == null) {\n        return stack;\n    }\n\n    // Find the replacement\n    if (node.right == null) {\n        // If no right child, replace with left\n        node = node.left;\n    } else if (node.left == null) {\n        // If no left child, replace with right\n        node = node.right;\n    } else if (dir) {\n        // Replace with the successor\n        stack = successorStack(stack);\n        edge = stack.value;\n        const temp = edge.to!;\n        node.value = temp.value;\n        node = temp.right;\n    } else {\n        // Replace with the predecessor\n        stack = predecessorStack(stack);\n        edge = stack.value;\n        const temp = edge.to!;\n        node.value = temp.value;\n        node = temp.left;\n    }\n\n    // Make the replacement / update the tree\n    edge.to = node;\n    if (edge.from) {\n        edge.from[edge.label!] = edge.to = node;\n    }\n\n    return stack;\n}\n/**\n * @internal\n */\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: undefined): undefined;\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: Node): Node;\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: Node | undefined): Node | undefined;\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: Node | undefined): Node | undefined {\n    if (node == null) {\n        return undefined;\n    }\n    const out: Node = Object.assign({}, node);\n    let stack: LinkedNode<Node> | undefined = { value: out };\n    do {\n        node = stack.value;\n        stack = stack.next;\n        if (node.left) {\n            stack = { next: stack, value: (node.left = Object.assign({}, node.left)) };\n        }\n        if (node.right) {\n            stack = { next: stack, value: (node.right = Object.assign({}, node.right)) };\n        }\n    } while (stack);\n    return out;\n}\n/**\n * @internal\n */\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(node: undefined): undefined;\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(node: Node): Node;\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined;\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined {\n    if (node == null) {\n        return undefined;\n    }\n    while (node.left) {\n        node = node.left;\n    }\n    return node;\n}\n/**\n * @internal\n */\nexport function leftmostStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    let node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    while (node.left) {\n        stack = { next: stack, value: { label: 'left', from: node, to: node.left } };\n        node = node.left;\n    }\n    return stack;\n}\n/**\n * @internal\n */\nexport function* inOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    let stack: LinkedNode<Node> | undefined = undefined;\n\n    while (node) {\n        stack = { next: stack, value: node };\n        node = node.left;\n    }\n\n    while (stack) {\n        node = stack.value;\n        stack = stack.next;\n        yield node;\n        node = node.right;\n        while (node) {\n            stack = { next: stack, value: node };\n            node = node.left;\n        }\n    }\n}\n/**\n * @internal\n */\nexport function levelOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n    padded?: false,\n): Generator<Node>;\nexport function levelOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n    padded: true,\n): Generator<Node | undefined>;\nexport function* levelOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n    padded = false,\n): Generator<Node | undefined> {\n    const nil = {} as LinkedNode<Node | undefined>;\n    let head: LinkedNode<Node | undefined> = { value: node };\n    let tail = head;\n    for (let cont = node != null; cont; head = head.next!) {\n        tail = tail.next = nil;\n        for (cont = false; head !== nil; head = head.next!) {\n            node = head.value;\n            if (node) {\n                yield node;\n                cont ||= node.left != null || node.right != null;\n                tail = tail.next = { value: node.left };\n                tail = tail.next = { value: node.right };\n            } else if (padded) {\n                yield undefined;\n                tail = tail.next = { value: undefined };\n                tail = tail.next = { value: undefined };\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nexport function* postOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    interface Meta {\n        seen: boolean;\n        node?: Node;\n    }\n    let stack: LinkedNode<Meta> | undefined = { value: { seen: false, node } };\n    do {\n        const meta = stack.value;\n        stack = stack.next;\n        if (meta.node) {\n            if (meta.seen) {\n                yield meta.node;\n            } else {\n                meta.seen = true;\n                stack = { next: stack, value: meta };\n                stack = { next: stack, value: { seen: false, node: meta.node.right } };\n                stack = { next: stack, value: { seen: false, node: meta.node.left } };\n            }\n        }\n    } while (stack);\n}\n/**\n * @internal\n */\nexport function predecessor<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined {\n    return node == null ? undefined : rightmost(node.left);\n}\n/**\n * @internal\n */\nexport function predecessorStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    const node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    stack = { next: stack, value: { label: 'left', from: node, to: node.left } };\n    return rightmostStack(stack);\n}\n/**\n * @internal\n */\nexport function* preOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    let stack: LinkedNode<Node | undefined> | undefined = { value: node };\n    do {\n        node = stack.value;\n        stack = stack.next;\n        if (node) {\n            yield node;\n            stack = { next: stack, value: node.right };\n            stack = { next: stack, value: node.left };\n        }\n    } while (stack);\n}\n/**\n * @internal\n */\nexport function reverse<Node extends BinaryTreeNode<unknown>>(root?: Node): void {\n    if (root == null) {\n        return;\n    }\n    for (const node of preOrderTraverse(root)) {\n        const left = node.left;\n        node.left = node.right;\n        node.right = left;\n    }\n}\n/**\n * @internal\n */\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(node: undefined): undefined;\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(node: Node): Node;\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined;\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined {\n    if (node == null) {\n        return undefined;\n    }\n    while (node.right) {\n        node = node.right;\n    }\n    return node;\n}\n/**\n * @internal\n */\nexport function rightmostStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    let node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    while (node.right) {\n        stack = { next: stack, value: { label: 'right', from: node, to: node.right } };\n        node = node.right;\n    }\n    return stack;\n}\n/**\n * Assumes sorted by compareFn\n * @internal\n */\nexport function search<T, Node extends BinaryTreeNode<T>>(\n    element: T,\n    node: Node | undefined,\n    compareFn: CompareFn<T>,\n): Node | undefined {\n    while (node) {\n        const comp: number = compareFn(element, node.value);\n        if (comp == 0) {\n            break;\n        }\n        node = comp < 0 ? node.left : node.right;\n    }\n    return node;\n}\n/**\n * Assumes sorted by compareFn\n * @internal\n */\nexport function searchStack<T, Node extends BinaryTreeNode<T>>(\n    element: T,\n    stack: LinkedNode<Edge<Node>>,\n    compareFn: CompareFn<T>,\n    dupeWeight = 0,\n): LinkedNode<Edge<Node>> {\n    const paths: ['left', 'right'] = ['left', 'right'];\n    let node = stack.value.to;\n    while (node) {\n        const comp: number = compareFn(element, node.value) || dupeWeight;\n        if (comp === 0) {\n            break;\n        }\n        const label = paths[+(comp > 0)];\n        stack = { next: stack, value: { label, from: node, to: node[label] } };\n        node = node[label]!;\n    }\n    return stack;\n}\n/**\n * @internal\n */\nexport function successor<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined {\n    return node == null ? undefined : leftmost(node.right);\n}\n/**\n * @internal\n */\nexport function successorStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    const node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    stack = { next: stack, value: { label: 'right', from: node, to: node.right } };\n    return leftmostStack(stack);\n}\n/**\n * Turn an array into a binary tree. Assumes elements are in level-order.\n *\n * @internal\n */\nexport function toBinaryTree<T>(\n    elements: (T | undefined)[] | undefined,\n): BinaryTreeNode<T> | undefined {\n    if (elements == null || elements.length < 1 || elements[0] == null) {\n        return undefined;\n    }\n    const n = elements.length;\n    const nodes: BinaryTreeNode<T>[] = new Array(n);\n    nodes[0] = { value: elements[0] };\n    for (let i = 1; i < n; ++i) {\n        if (elements[i] == null) {\n            continue;\n        }\n        const par = nodes[(i - 1) >>> 1];\n        const node = { value: elements[i]! };\n        nodes[i] = node;\n        if (i & 1) {\n            par.left = node;\n        } else {\n            par.right = node;\n        }\n    }\n    return nodes[0];\n}\n","import { isArray } from 'src/collection/arrayUtils';\nimport { BinaryTreeNode } from 'src/tree/binaryTreeNode';\nimport { clone, preOrderTraverse, toBinaryTree } from 'src/tree/binaryTreeUtils';\nimport { CompareFn } from '..';\nimport { BinaryHeap } from './binaryHeap';\nimport { Heap } from './heap';\nimport { skewMerge } from './utils';\n\n/**\n * A skew heap is a heap implemented as a binary tree\n * ([source](https://en.wikipedia.org/wiki/Skew_heap)).\n *\n * A skew heap is a self-adjusting heap which attempts to maintain balance\n * by unconditionally swapping all nodes in the merge path when merging two heaps. Every\n * operation that modifies the heap (e.g. push, pop, merge) is considered a merge and is done\n * by using a skew heap merge.\n *\n * Skew heaps can merge more quickly than binary heaps. This can seem contradictory, since\n * skew heaps have no structural constraints and no guarantee that the height of the tree is\n * logarithmic (i.e. balanced). However, amortized complexity analysis can demonstrate that\n * all operations on a skew heap can be done in O(log(n). More specifically, the\n * amortized complexity is known to be log<sub>φ</sub>(n) where φ is the golden ratio. This is\n * approximately 1.44*log<sub>2</sub>(n).\n *\n * #### Complexity\n *\n * | Property | Average  | Worst |\n * | :------- | :------  | :---- |\n * | Space    | O(n)     | O(n)\n * | Push     | O(log n) | O(log n)\n * | Peek     | O(1)\t | O(1)\n * | Pop      | O(log n) | O(log n)\n * | Search   | O(n)     | O(n)\n */\nexport class SkewHeap<T> implements Heap<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The node at the \"top\" of the heap.\n     */\n    protected root: BinaryTreeNode<T> | undefined;\n    /**\n     * Instantiate a heap.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the heap with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>) {\n        this.compare = compareFn;\n        this.length = 0;\n        this.addAll(elements ?? []);\n    }\n\n    addAll(elements: Iterable<T>): number {\n        if (isArray(elements)) {\n            for (let i = 0; i < elements.length; ++i) {\n                this.push(elements[i]);\n            }\n        } else if (elements instanceof SkewHeap || elements instanceof BinaryHeap) {\n            this.merge(elements);\n        } else {\n            for (const element of elements) {\n                this.push(element);\n            }\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.root = undefined;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        for (const node of preOrderTraverse(this.root)) {\n            if (element === node.value) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    delete(element: T): boolean {\n        if (this.root == null) {\n            return false;\n        }\n        if (this.root.value === element) {\n            this.pop()!;\n            return true;\n        }\n        for (const par of preOrderTraverse(this.root)) {\n            const key: keyof BinaryTreeNode<T> | undefined =\n                par.left && par.left.value === element\n                    ? 'left'\n                    : par.right && par.right.value === element\n                    ? 'right'\n                    : undefined;\n            if (key != null) {\n                const node = par[key]!;\n                par[key] = skewMerge(this.compare, [node.left, node.right]);\n                --this.length;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    merge(heap: Heap<T>): this {\n        if (this.compare !== heap.comparator()) {\n            this.addAll(heap);\n        } else if (heap instanceof SkewHeap) {\n            this.root = skewMerge(this.compare, [this.root, clone(heap.root)]);\n            this.length += heap.size;\n        } else if (heap instanceof BinaryHeap) {\n            this.root = skewMerge(this.compare, [this.root, toBinaryTree(heap['array'])!]);\n            this.length += heap.size;\n        } else {\n            this.addAll(heap);\n        }\n        return this;\n    }\n\n    peek(): T | undefined {\n        return this.root?.value;\n    }\n\n    pop(): T | undefined {\n        if (this.root == null) {\n            return undefined;\n        }\n        const value = this.root.value;\n        this.root = skewMerge(this.compare, [this.root.left, this.root.right]);\n        --this.length;\n        return value;\n    }\n\n    push(value: T): number {\n        this.root = skewMerge(this.compare, [this.root, { value }]);\n        return ++this.length;\n    }\n\n    pushPop(value: T): T {\n        this.push(value);\n        return this.pop()!;\n    }\n\n    replace(value: T): T | undefined {\n        if (this.root == null) {\n            this.root = { value };\n            this.length = 1;\n            return undefined;\n        }\n        const out = this.root.value;\n        this.root = skewMerge(this.compare, [this.root.left, this.root.right, { value }]);\n        return out;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        if (this.root == null) {\n            return;\n        }\n        const heap = new SkewHeap<BinaryTreeNode<T>>(\n            (a, b) => this.compare(a.value, b.value),\n            [this.root],\n        );\n        do {\n            const node = heap.pop()!;\n            yield node.value;\n            node.left && heap.push(node.left);\n            node.right && heap.push(node.right);\n        } while (heap.size > 0);\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.root == null) {\n            return false;\n        }\n\n        if (this.root.value === curElement) {\n            this.root = skewMerge(this.compare, [\n                this.root.left,\n                this.root.right,\n                { value: newElement },\n            ]);\n            return true;\n        }\n\n        let node: BinaryTreeNode<T> | undefined = undefined;\n        for (const par of preOrderTraverse(this.root)) {\n            if (par.left && par.left.value === curElement) {\n                node = par.left;\n                par.left = undefined;\n                break;\n            }\n            if (par.right && par.right.value === curElement) {\n                node = par.right;\n                par.right = undefined;\n                break;\n            }\n        }\n\n        if (node == null) {\n            return false;\n        }\n\n        this.root = skewMerge(this.compare, [\n            this.root,\n            node.left,\n            node.right,\n            { value: newElement },\n        ]);\n        return true;\n    }\n}\n","import { splice } from 'src/collection/arrayUtils';\nimport { clamp, wrapLeft } from 'src/math/numberUtils';\nimport { CompareFn } from '..';\nimport { List } from './list';\n\n/**\n * An implementation of the {@link List} interface using an array\n */\nexport class ArrayList<T> implements List<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: Array<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    add(index: number, element: T): number {\n        if (index >= 0 && index <= this.size) {\n            this.array.splice(index, 0, element);\n        }\n        return this.size;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.size) {\n            splice(this.array, index, 0, elements);\n        }\n        return this.size;\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    concat(...lists: Iterable<T>[]): ArrayList<T> {\n        const out = new ArrayList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        index = clamp(wrapLeft(index, 0, this.size), 0, this.size);\n        min = clamp(wrapLeft(min ?? 0, 0, this.size), 0, this.size);\n        max = clamp(wrapLeft(max ?? this.size, 0, this.size), 0, this.size);\n        this.array.copyWithin(index, min, max);\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.size), 0, this.size);\n        max = clamp(wrapLeft(max ?? this.size, 0, this.size), 0, this.size);\n        this.array.fill(element, min, max);\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array[index];\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        let value: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            value = this.array[index];\n            this.array[index] = callback(value);\n        }\n        return value;\n    }\n\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n\n    push(element: T): number {\n        return this.array.push(element);\n    }\n\n    remove(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array.splice(index, 1)[0];\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.size), 0, this.size);\n        max = clamp(wrapLeft(max ?? this.size, 0, this.size), 0, this.size) - 1;\n        while (min < max) {\n            const temp = this.array[min];\n            this.array[min++] = this.array[max];\n            this.array[max--] = temp;\n        }\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        let prev: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            prev = this.array[index];\n            this.array[index] = element;\n        }\n        return prev;\n    }\n\n    shift(): T | undefined {\n        return this.array.shift();\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    slice(min?: number, max?: number): ArrayList<T> {\n        return new ArrayList(this.array.slice(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        return new ArrayList(splice(this.array, start, count, elements));\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        this.array.sort(compareFn);\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n\n    unshift(element: T): number {\n        return this.array.unshift(element);\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = clamp(wrapLeft((min as number) ?? 0, 0, this.size), 0, this.size);\n        max = clamp(wrapLeft((max as number) ?? this.size, 0, this.size), 0, this.size);\n        while (min < max) {\n            this.array[min] = callback(this.array[min], min);\n            ++min;\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = clamp(wrapLeft(min ?? 0, 0, this.size), 0, this.size);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.size;\n        } else if (max >= 0) {\n            len = () => Math.min(max, this.size);\n        } else {\n            len = () => this.size + max;\n        }\n\n        while (min < len()) {\n            yield this.array[min++];\n        }\n    }\n}\n","import { CompareFn } from '..';\nimport { DoublyLinkedNode } from './doublyLinkedNode';\nimport { LinkedNode } from './linkedNode';\n\n/**\n * Sorts a list in place.\n *\n * Works on complete lists as well as sublists and circular lists:\n * - Linked lists will keep the link to the next node beyond the sorted section\n * - Doubly linked lists will keep links to the prev and next nodes outside the sorted section\n *\n * @param node - The head of the list\n * @param len - The length of the list beginning from node\n * @param isDoubly - Whether node is a doubly linked node\n * @param compareFn - A function used to determine the order of elements.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n *\n * @returns The new head and tail of the sorted list\n *\n * @internal\n */\nexport function linkedMergeSort<T, Node extends LinkedNode<T>>(\n    node: Node,\n    len: number,\n    isDoubly: boolean,\n    compareFn: CompareFn<T>,\n): [Node, Node] {\n    // Base case\n    if (len < 2) {\n        return [node, node];\n    }\n\n    // Split the list into two halves and sort them\n    len = len / 2;\n    const lens: [number, number] = [Math.ceil(len), Math.floor(len)];\n    const heads = linkedMergeSort(node, lens[0], isDoubly, compareFn);\n    const tails = linkedMergeSort(heads[1].next as Node, lens[1], isDoubly, compareFn);\n\n    // Group the heads and tails together\n    node = heads[1];\n    heads[1] = tails[0];\n    tails[0] = node;\n    tails[0].next = tails[1].next;\n\n    // Merge the sorted halves\n    const prev = (heads[0] as DoublyLinkedNode<T>).prev;\n    node = linkedMergeSorted(heads, lens, isDoubly, compareFn);\n    if (isDoubly) {\n        (node as DoublyLinkedNode<T>).prev = prev;\n    }\n\n    // Return the head and tail\n    return [node, tails[+(lens[0] < 1)]];\n}\n/**\n * Merges two sorted lists.\n *\n * @param nodes - The heads of the lists\n * @param lens - The lengths of the lists\n * @param isDoubly - Whether the lists are a doubly linked\n * @param compareFn - A function used to determine the order of elements.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n *\n * @returns The new head of the sorted list\n *\n * @internal\n */\nexport function linkedMergeSorted<T, Node extends LinkedNode<T>>(\n    heads: [Node, Node],\n    lens: [number, number],\n    isDoubly: boolean,\n    compareFn: CompareFn<T>,\n): Node {\n    const root = {} as Node;\n\n    let node = root;\n    do {\n        const index = +(compareFn(heads[0].value, heads[1].value) > 0);\n        node.next = heads[index];\n        if (isDoubly) {\n            (node.next as DoublyLinkedNode<T>).prev = node;\n        }\n        node = node.next as Node;\n        heads[index] = node.next as Node;\n        --lens[index];\n    } while (lens[0] > 0 && lens[1] > 0);\n\n    // Add any remaining nodes\n    node.next = heads[+(lens[0] < 1)];\n    if (isDoubly && node.next) {\n        (node.next as DoublyLinkedNode<T>).prev = node;\n    }\n    return root.next as Node;\n}\n","import { clamp, wrapLeft } from 'src/math/numberUtils';\nimport { CompareFn } from '..';\nimport { DoublyLinkedNode } from './doublyLinkedNode';\nimport { List } from './list';\nimport { linkedMergeSort } from './utils';\n\n/**\n * A (circular) doubly-linked list implementation of the {@link List} interface.\n *\n * Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.\n */\nexport class DoublyLinkedList<T> implements List<T> {\n    /**\n     * The number of elements in the list\n     */\n    protected length: number;\n    /**\n     * The sentinel node at the fron of the list\n     */\n    protected root: DoublyLinkedNode<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as DoublyLinkedNode<T>;\n        this.root.prev = this.root.next = this.root;\n        this._addAll(this.root, elements ?? []);\n    }\n\n    add(index: number, value: T): number {\n        if (index < 0 || index > this.length) {\n            return this.length;\n        }\n        const prev = this._get(index - 1);\n        const node = { next: prev.next, prev, value };\n        prev.next = node;\n        node.next!.prev = node;\n        return ++this.length;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.length) {\n            this._addAll(this._get(index), elements);\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.root.prev = this.root.next = this.root;\n    }\n\n    concat(...lists: Iterable<T>[]): DoublyLinkedList<T> {\n        const out = new DoublyLinkedList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to the same section\n        index = clamp(wrapLeft(index, 0, this.length), 0, this.length);\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Check for overlap edge case\n        if (min < index && index < max) {\n            let nodeA = this._get(max);\n            let nodeB = this._get(index + (max - min));\n            do {\n                nodeA = nodeA.prev!;\n                nodeB = nodeB.prev!;\n                nodeB.value = nodeA.value;\n            } while (++min < max);\n            return this;\n        }\n\n        // Copy the section to the destination\n        let nodeA = this._get(min);\n        let nodeB = this._get(index);\n        do {\n            nodeB.value = nodeA.value;\n            nodeA = nodeA.next!;\n            nodeB = nodeB.next!;\n        } while (++min < max);\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.length ? undefined : this._get(index).value;\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const tail = this.root.prev!;\n        tail.prev!.next = this.root;\n        this.root.prev = tail.prev;\n        --this.length;\n        return tail.value;\n    }\n\n    push(value: T): number {\n        const prev = this.root.prev!;\n        const node = { next: this.root, prev, value };\n        prev.next = this.root.prev = node;\n        return ++this.length;\n    }\n\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        node.prev!.next = node.next;\n        node.next!.prev = node.prev;\n        --this.length;\n        return node.value;\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        const tail = root.next!;\n        let node = tail;\n        do {\n            const temp = node.next!;\n            node.next = node.prev;\n            node.prev = temp;\n            root.next = node;\n            node = temp;\n        } while (++min < max);\n        tail.next = node;\n        node.prev = tail;\n        root.next!.prev = root;\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n\n    shift(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const head = this.root.next!;\n        head.next!.prev = this.root;\n        this.root.next = head.next;\n        --this.length;\n        return head.value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    slice(min?: number, max?: number): DoublyLinkedList<T> {\n        return new DoublyLinkedList(this.view(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = clamp(wrapLeft(start ?? 0, 0, this.length), 0, this.length);\n        count = clamp(count ?? this.size, 0, this.size - start);\n\n        // If not modifying the list\n        const list = new DoublyLinkedList<T>();\n        if (elements == null && count < 1) {\n            return list;\n        }\n\n        // Delete elements\n        let node = this._get(start);\n        while (count-- > 0) {\n            list.push(node.value);\n            node.prev!.next = node.next!;\n            node.next!.prev = node.prev!;\n            node = node.next!;\n            --this.length;\n        }\n\n        // Add elements\n        this._addAll(node, elements ?? []);\n\n        return list;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        if (this.length > 1) {\n            const [head, tail] = linkedMergeSort(this.root.next!, this.length, true, compareFn);\n            this.root.next = head;\n            tail.next!.prev = tail;\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let node = this.root.next!; node !== this.root; node = node.next!) {\n            yield node.value;\n        }\n    }\n\n    unshift(value: T): number {\n        const head = this.root.next!;\n        const node = { next: head, prev: this.root, value };\n        this.root.next = head.prev = node;\n        return ++this.length;\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = clamp(wrapLeft((min as number) ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft((max as number) ?? this.length, 0, this.length), 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.length;\n        } else if (max >= 0) {\n            len = () => max;\n        } else {\n            len = () => this.length + max;\n        }\n\n        if (min < len()) {\n            let node = this._get(min);\n            do {\n                yield node.value;\n                node = node.next!;\n            } while (++min < len() && node !== this.root);\n        }\n    }\n    /**\n     *\n     */\n    protected _addAll(next: DoublyLinkedNode<T>, elements: Iterable<T>): void {\n        let prev = next.prev!;\n        for (const value of elements) {\n            const node = { prev, value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        next.prev = prev;\n    }\n    /**\n     * A helper method to iterate and return the node at the given index.\n     *\n     * Depending on the index, the list will be traversed from beginning or end; whichever is closest to the specified index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number): DoublyLinkedNode<T> {\n        let node = this.root;\n        if (index < this.length / 2) {\n            while (index-- >= 0) {\n                node = node.next!;\n            }\n        } else {\n            for (index = this.length - index; index > 0; --index) {\n                node = node.prev!;\n            }\n        }\n        return node;\n    }\n}\n","import { clamp, wrapLeft } from 'src/math/numberUtils';\nimport { CompareFn } from '..';\nimport { LinkedNode } from './linkedNode';\nimport { List } from './list';\nimport { linkedMergeSort } from './utils';\n\n/**\n * A (circular) linked list implementation of the {@link List} interface.\n */\nexport class LinkedList<T> implements List<T> {\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The sentinel node at the front of the list.\n     */\n    protected root: LinkedNode<T>;\n    /**\n     * The last node of the list.\n     */\n    protected tail: LinkedNode<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as LinkedNode<T>;\n        this.root.next = this.root;\n        this.tail = this._addAll(this.root, elements ?? []);\n    }\n\n    add(index: number, value: T): number {\n        if (index >= 0 && index < this.length) {\n            const prev = this._get(index - 1);\n            prev.next = { value, next: prev.next };\n            ++this.length;\n        } else if (index === this.length) {\n            this.push(value);\n        }\n        return this.length;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index < this.length) {\n            this._addAll(this._get(index - 1), elements);\n        } else if (index === this.length) {\n            this.tail = this._addAll(this.tail, elements);\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.tail = this.root.next = this.root;\n    }\n\n    concat(...lists: Iterable<T>[]): LinkedList<T> {\n        const out = new LinkedList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to itself\n        index = clamp(wrapLeft(index, 0, this.length), 0, this.length);\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Copy to earlier in the list\n        if (index < min) {\n            const node = this._get(index - 1);\n            this._copyWithin(this._get(min - index - 1, node), node, max - min);\n            return this;\n        }\n\n        // Copy to later in the list\n        if (index > max) {\n            const node = this._get(min - 1);\n            this._copyWithin(node, this._get(index - min - 1, node), max - min);\n            return this;\n        }\n\n        // Copy to overlapping destination\n        const nodeA = this._get(min - 1);\n        const nodeC = this._get(max - min - 1, nodeA);\n        const nodeD = this._copyWithin(nodeA, nodeC, index - min);\n        if (index + (max - min) >= this.length) {\n            this.tail = nodeC;\n        }\n        const temp = nodeA.next;\n        nodeA.next = nodeC.next;\n        nodeC.next = nodeD.next;\n        nodeD.next = temp;\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        return index < this.length - 1 ? this._get(index).value : this.tail.value;\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = index < this.length - 1 ? this._get(index) : this.tail;\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const value = this.tail.value;\n        this.tail = this._get(this.length - 2);\n        this.tail.next = this.root;\n        --this.length;\n        return value;\n    }\n\n    push(value: T): number {\n        const tail: LinkedNode<T> = { next: this.root, value };\n        this.tail.next = tail;\n        this.tail = tail;\n        return ++this.length;\n    }\n\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const prev = this._get(index - 1);\n        const node = prev.next!;\n        prev.next = node.next;\n        if (index === --this.length) {\n            this.tail = prev;\n        }\n        return node.value;\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        this.tail = max >= this.length ? root.next! : this.tail;\n        const tail = root.next!;\n        let prev = tail;\n        let node = tail.next!;\n        while (++min < max) {\n            const next = node.next!;\n            node.next = prev;\n            prev = node;\n            node = next;\n        }\n        root.next = prev;\n        tail.next = node;\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n\n    shift(): T | undefined {\n        return this.remove(0);\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    slice(min?: number, max?: number): LinkedList<T> {\n        return new LinkedList(this.view(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = clamp(wrapLeft(start ?? 0, 0, this.length), 0, this.length);\n        count = clamp(count ?? this.size, 0, this.size - start);\n\n        // If not modifying the list\n        const deleted = new LinkedList<T>();\n        if (elements == null && count < 1) {\n            return deleted;\n        }\n\n        // Delete elements\n        let prev = this._get(start - 1);\n        const newTail = start + count >= this.size;\n        while (count-- > 0) {\n            const node = prev.next!;\n            deleted.push(node.value);\n            prev.next = node.next;\n            --this.length;\n        }\n\n        // Add elements\n        prev = this._addAll(prev, elements ?? []);\n        this.tail = newTail ? prev : this.tail;\n\n        return deleted;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        if (this.length > 1) {\n            const [head, tail] = linkedMergeSort(this.root.next!, this.length, false, compareFn);\n            this.root.next = head;\n            this.tail = tail;\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let node = this.root.next!; node !== this.root; node = node.next!) {\n            yield node.value;\n        }\n    }\n\n    unshift(value: T): number {\n        return this.add(0, value);\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = clamp(wrapLeft((min as number) ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft((max as number) ?? this.length, 0, this.length), 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.length;\n        } else if (max >= 0) {\n            len = () => max;\n        } else {\n            len = () => this.length + max;\n        }\n\n        if (min < len()) {\n            let node = this._get(min);\n            do {\n                yield node.value;\n                node = node.next!;\n            } while (++min < len() && node !== this.root);\n        }\n    }\n\n    protected _addAll(prev: LinkedNode<T>, elements: Iterable<T>): LinkedNode<T> {\n        const next = prev.next!;\n        for (const value of elements) {\n            const node = { value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        return prev;\n    }\n    /**\n     * Copy values from 'from' to 'to'.\n     *\n     * @param from - The initial node to copy from\n     * @param prev - The root of the initial node to copy to\n     * @param count - The number of values to copy\n     */\n    protected _copyWithin(from: LinkedNode<T>, to: LinkedNode<T>, count: number): LinkedNode<T> {\n        while (count-- > 0) {\n            from = from.next!;\n            to = to.next!;\n            to.value = from.value;\n        }\n        return to;\n    }\n    /**\n     * Get the node at the given index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number, root: LinkedNode<T> = this.root): LinkedNode<T> {\n        let node = root!;\n        while (index-- >= 0) {\n            node = node.next!;\n        }\n        return node;\n    }\n}\n","/**\n * Bit hacks for 32-bit unsigned numbers.\n */\n\n/**\n * Get the number of bits set of a 32-bit unsigned number ([source](https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan))\n *\n * @param a\n */\nexport function bitsSet(a: number): number {\n    let b = 0;\n    while (a) {\n        ++b;\n        a &= a - 1;\n    }\n    return b;\n}\n/**\n * Invert the bits of a 32-bit unsigned number.\n *\n * Example: 11 (1011) -> 4 (0100)\n *\n * @param a The number to invert\n *\n * @returns The inverted number\n */\nexport function invert(a: number): number {\n    const b = msp(a);\n    return u32(a ^ (b | (b - 1)));\n}\n/**\n * Check whether a 32-bit unsigned number is a power of 2.\n *\n * Example: 8 (1000) -> true\n *\n * @param a The number to check\n */\nexport function isPow2(a: number): boolean {\n    return (a & (a - 1)) === 0;\n}\n/**\n * Get the Least Significant Bit of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns The lowest bit set\n */\nexport function lsb(a: number): number {\n    let b = -1;\n    for (a = lsp(a); a; a >>>= 1) {\n        ++b;\n    }\n    return b;\n}\n/**\n * Get the Least Significant Power of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns 2**lsb(a)\n */\nexport function lsp(a: number): number {\n    return u32(a & -a);\n}\n/**\n * Get the Least Significant Power Set of a 32-bit unsigned number.\n *\n * Example: 54 (110110) -> 6 (000110)\n *\n * @param a\n */\nexport function lsps(a: number): number {\n    return u32(a & (lsp(a + lsp(a)) - 1));\n}\n/**\n * Get the Most Significant Power of the Least Significant Power Set of a 32-bit unsigned number.\n *\n * Example: 54 (110110) -> 4 (000100)\n *\n * @param a\n */ /*\nexport function mlsp(a: number): number {\n    return (lsp(a + lsp(a)) >>> 1) || u32(0x80000000 & a);\n}\n*/\n/**\n * Get the Most Significant Bit of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns ⌊log2(a)⌋ : the highest bit set\n */\nexport function msb(a: number): number {\n    let b = -1;\n    while (a !== 0) {\n        ++b;\n        a >>>= 1;\n    }\n    return b;\n}\n/**\n * Get the Most Significant Power of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns 2**msb(a)\n */\nexport function msp(a: number): number {\n    let b = a & -a;\n    while (a != b) {\n        a ^= b;\n        b = a & -a;\n    }\n    return u32(b);\n}\n/**\n * Get the Most Significant Power Set of a 32-bit unsigned number.\n *\n * Example: 50 (110010) -> 48 (110000)\n *\n * @param a\n */\nexport function msps(a: number): number {\n    let b = a & -a;\n    while (a & (a + b)) {\n        a ^= b;\n        b = a & -a;\n    }\n    return u32(a);\n}\n/**\n * Reverse a 32-bit unsigned number.\n *\n * Example: 50 (110010) -> 19 (010011)\n *\n * @param a\n */\nexport function reverse(a: number): number {\n    a = ((a & 0xaaaaaaaa) >>> 1) | ((a & 0x55555555) << 1);\n    a = ((a & 0xcccccccc) >>> 2) | ((a & 0x33333333) << 2);\n    a = ((a & 0xf0f0f0f0) >>> 4) | ((a & 0x0f0f0f0f) << 4);\n    a = ((a & 0xff00ff00) >>> 8) | ((a & 0x00ff00ff) << 8);\n    return u32((a >>> 16) | (a << 16));\n}\n/**\n * Turn a number into an unsigned 32-bit number\n *\n * @param a\n */\nexport function u32(a: number): number {\n    return a >>> 0;\n}\n","import { Queue } from './queue';\n\n/**\n * An implementation of the {@link Queue} interface using an array\n */\nexport class ArrayQueue<T> implements Queue<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * Instantiate the queue.\n     *\n     * @param elements - A set of elements to initialize the queue with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    dequeue(): T | undefined {\n        return this.size < 1 ? undefined : this.array.shift();\n    }\n\n    enqueue(element: T): number {\n        return this.array.push(element);\n    }\n\n    peek(): T | undefined {\n        return this.size < 1 ? undefined : this.array[0];\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Queue } from './queue';\n\n/**\n * A linked list implementation of the {@link Queue} interface\n */\nexport class LinkedQueue<T> implements Queue<T> {\n    /**\n     * The list containing every element.\n     */\n    protected list: List<T>;\n    /**\n     * Instantiate the queue.\n     *\n     * @param elements - A set of elements to initialize the queue with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList(elements);\n    }\n\n    clear(): void {\n        this.list.clear();\n    }\n\n    dequeue(): T | undefined {\n        return this.list.shift();\n    }\n\n    enqueue(element: T): number {\n        return this.list.push(element);\n    }\n\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","import { lsb, lsp, msb, msp } from '../math/u32';\nimport { CombineFn } from '..';\nimport { MAX_ARRAY_LENGTH } from 'src/collection/arrayUtils';\nimport { SegmentTree } from './segmentTree';\n\n/*\n    mca(a, b) = lsp(a | msp(b - a)) ; // where a <= b\n    left(i) = i - (lsp(i + 1) >>> 1)\n    right(i) = i + (lsp(i + 1) >>> 1)\n    parent(i) =\n        offset = lsp(i + 1)\n        i + offset - ((i & 2*offset) >>> 0)\n*/\n\n/**\n * A {@link SegmentTree} with entries stored in in-order traversal.\n * Inspired by [Tristan Hume's IForestIndex](https://thume.ca/2021/03/14/iforests) ([github](https://github.com/trishume/gigatrace))\n */\nexport class InOrderSegmentTree<T> implements SegmentTree<T> {\n    /**\n     * The maximum amount of elements that can be added.\n     *\n     * n elements require 2n memory.\n     */\n    static readonly MAX_SIZE: number = Math.floor(MAX_ARRAY_LENGTH / 2);\n    /**\n     * The set of elements and aggregation nodes for the tree\n     */\n    protected array: T[];\n    /**\n     * The function used to aggregate elements\n     */\n    protected combine: CombineFn<T>;\n    /**\n     * Construct a new segment tree\n     *\n     * @param combine - The function used to aggregate segment information\n     * @param elements - A set of elements to add into the initial tree\n     */\n    constructor(combine: CombineFn<T>, elements: Iterable<T> = []) {\n        this.array = [];\n        this.combine = combine;\n        this.build(elements);\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    pop(): T | undefined {\n        // Sanitize range\n        if (this.size < 1) {\n            return undefined;\n        }\n\n        // Un-complete aggregation nodes\n        const i = this.array.length - 1;\n        for (let mask = 2; i & mask; mask *= 2) {\n            this.array[i - mask] = this.array[i - mask - (mask >>> 1)];\n        }\n\n        // Return element\n        const out = this.array[i - 1];\n        this.array.length -= 2;\n        return out;\n    }\n\n    push(element: T): number {\n        // Sanitize range\n        if (this.size >= InOrderSegmentTree.MAX_SIZE) {\n            throw new RangeError(`Invalid length`);\n        }\n\n        // Add element\n        const i = this.array.length;\n        this.array[i + 1] = this.set(i, element);\n\n        return this.size;\n    }\n\n    query(min: number, max: number): T {\n        // Sanitize range\n        if (min >= max) {\n            throw new RangeError(`Range [${min}..${max}) is empty`);\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min *= 2;\n        max *= 2;\n\n        // Jump to min's highest aggregation node that is fully within the range\n        let offset = lsp(min | msp(max - min));\n        let value = this.array[min - 1 + (offset >>> 1)];\n\n        // Continue jumping aggregation nodes until max is reached\n        for (min += offset; min < max; min += offset) {\n            offset = lsp(min | msp(max - min));\n            value = this.combine(value, this.array[min - 1 + (offset >>> 1)]);\n        }\n\n        return value;\n    }\n\n    get size(): number {\n        return this.array.length >>> 1;\n    }\n\n    /**\n     * Return an iterator through the tree's elements\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let i = 0; i < this.array.length; i += 2) {\n            yield this.array[i];\n        }\n    }\n\n    update(min: number, max: number, operation: (element: T, index: number) => T): void {\n        // Sanitize range\n        if (min >= max) {\n            return;\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min *= 2;\n        max *= 2;\n\n        // Update the values\n        let value: T;\n        do {\n            value = this.set(min, operation(this.array[min], min >>> 1));\n            min += 2;\n        } while (min < max);\n\n        // Update remaining aggregation nodes\n        let dc = 0;\n        let dp = lsp(min);\n        max = msb(min ^ this.array.length) - lsb(min);\n        for (--min; max > 0; --max) {\n            value = this.combine(value, this.array[min + (dp >>> 1) - dc]);\n            this.array[min] = value;\n            dc = (min & (2 * dp)) >>> 0;\n            min += dp - dc;\n            dp *= 2;\n        }\n\n        // Update the incomplete aggregation node\n        this.array[min] = value;\n    }\n    /**\n     * A helper method used to build the tree\n     *\n     * @param elements The initial set of elements to add into the tree\n     */\n    protected build(elements: Iterable<T>) {\n        for (const element of elements) {\n            this.push(element);\n        }\n    }\n    /**\n     * A helper method to update complete aggregation nodes for an index\n     */\n    protected set(index: number, element: T): T {\n        // Set the index\n        this.array[index++] = element;\n\n        // Update complete aggregation nodes, from lowest to highest\n        for (let mask = 2; index & mask; mask *= 2) {\n            element = this.combine(this.array[index - mask - (mask >>> 1)], element);\n            this.array[index - mask] = element;\n        }\n\n        return element;\n    }\n}\n","/**\n *  Thanks to [Douglas Wilhelm Harder](https://ece.uwaterloo.ca/~dwharder/aads/Algorithms/Array_resizing/)\n *  for their analysis on array resizing\n */\nimport { isArray, MAX_ARRAY_LENGTH } from 'src/collection/arrayUtils';\nimport { isCollection } from 'src/collection';\nimport { Collection } from 'src/collection/collection';\nimport { CombineFn } from '..';\nimport { lsp, msp } from '../math/u32';\nimport { SegmentTree } from './segmentTree';\n\n/**\n * A {@link SegmentTree} with entries stored in level-order traversal.\n * Memory usage: n elements require between 2n-1 to 4(n-1)-1 entries\n *\n */\nexport class LevelOrderSegmentTree<T> implements SegmentTree<T> {\n    /**\n     * The maximum number of elements that can be added.\n     *\n     * n elements require 2^⌈log2(2n)⌉ - 1 memory:\n     */\n    static readonly MAX_SIZE: number = 2 ** Math.floor(Math.log2(MAX_ARRAY_LENGTH + 1) - 1);\n    /**\n     * The internal array used to store elements and aggregation nodes\n     */\n    protected array: Array<T>;\n    /**\n     * The function used to aggregate elements\n     */\n    protected combine: CombineFn<T>;\n    /**\n     * The used length (size) of our internal array\n     */\n    protected length: number;\n    /**\n     * The start index for the lowest level\n     */\n    protected level: number;\n    /**\n     * Construct a new {@link SegmentTree}\n     *\n     * @param combinFn - The function used to aggregate elements\n     * @param elements - Initial elements to build into the tree\n     */\n    constructor(combine: CombineFn<T>, elements: Iterable<T> = []) {\n        this.array = [];\n        this.combine = combine;\n        this.length = 0;\n        this.level = 0;\n        this.build(elements);\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.level = 0;\n        this.array.length = 0;\n    }\n\n    pop(): T | undefined {\n        // Sanitize range\n        if (this.length <= this.level) {\n            return undefined;\n        }\n\n        // Remove element\n        const out = this.array[--this.length];\n\n        // If level is <= 1/4 full\n        if (this.size <= (this.level + 1) >>> 2) {\n            this.shrink();\n        }\n\n        return out;\n    }\n\n    push(element: T): number {\n        // If array is full\n        if (this.length >= this.array.length) {\n            this.grow();\n        }\n\n        // Add the new element\n        this.array[this.length++] = element;\n\n        // Update aggregation nodes\n        for (let i = this.length; i & 1; this.array[i - 1] = element) {\n            element = this.combine(this.array[i - 2], element);\n            i >>>= 1;\n        }\n\n        return this.size;\n    }\n\n    query(min: number, max: number): T {\n        // Sanitize range\n        if (min >= max) {\n            throw new RangeError(`Range [${min}..${max}) is empty`);\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices and align with powers of 2\n        min += this.level + 1;\n        max += this.level + 1;\n\n        // Take the longest possible jump from min\n        let offset = lsp(min | msp(max - min));\n        let value: T = this.array[min / offset - 1];\n        min += offset;\n\n        // Continue jumping until max\n        while (min < max) {\n            offset = lsp(min | msp(max - min));\n            value = this.combine(value, this.array[min / offset - 1]);\n            min += offset;\n        }\n\n        return value;\n    }\n\n    get size(): number {\n        return this.length - this.level;\n    }\n\n    /**\n     * Return an iterator through the elements\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let i = 0; i < this.size; ++i) {\n            yield this.array[this.level + i];\n        }\n    }\n\n    update(min: number, max: number, operation: (element: T, index: number) => T): void {\n        // Sanitize range\n        if (min >= max) {\n            return;\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min += this.level;\n        max += this.level;\n\n        // Update the range\n        for (let i = min; i < max; ++i) {\n            this.array[i] = operation(this.array[i], i - this.level);\n        }\n\n        // Update the range's aggregation nodes\n        this.aggregate(min, max);\n    }\n    /**\n     * A helper method to aggregate a range of elements\n     */\n    protected aggregate(min: number, max: number): void {\n        // Align indices with powers of 2\n        ++min;\n        ++max;\n\n        // Aggregate elements\n        for (let cap = this.length + 1; min < max; cap >>>= 1) {\n            max += max & ((max - cap) >>> 31);\n            for (let i = (min | 1) >>> 0; i < max; i += 2) {\n                this.array[(i >>> 1) - 1] = this.combine(this.array[i - 2], this.array[i - 1]);\n            }\n            min >>>= 1;\n            max >>>= 1;\n        }\n    }\n    /**\n     * A helper method used to build the tree\n     *\n     * @param elements The initial set of elements to add into the tree\n     */\n    protected build(elements: Collection<T> | Iterable<T>): void {\n        let key: string | undefined = undefined;\n\n        // Check if the iterable's size can be known.\n        if (isArray(elements)) {\n            key = 'length';\n        } else if (isCollection(elements)) {\n            key = 'size';\n        } else {\n            for (const element of elements) {\n                this.push(element);\n            }\n            return;\n        }\n\n        // Get the iterable's size\n        const n: number = (elements as any)[key];\n\n        // Check for base case\n        if (n < 1) {\n            this.array.length = 0;\n            this.length = 0;\n            this.level = 0;\n            return;\n        }\n\n        // Check if max capacity reached\n        if (n >= LevelOrderSegmentTree.MAX_SIZE) {\n            throw new RangeError('Invalid length');\n        }\n\n        // Allocate the array\n        this.level = 2 * msp(n - 1) - 1;\n        this.length = this.level;\n        this.array.length = 2 * this.level + 1;\n\n        // Add the elements\n        for (const element of elements) {\n            this.array[this.length++] = element;\n        }\n\n        // Update aggregation nodes\n        this.aggregate(this.level, this.length);\n    }\n    /**\n     * Shift the tree down a level\n     */\n    protected grow(): void {\n        // Check base case\n        if (this.size < 1) {\n            this.array.length = 1;\n            return;\n        }\n\n        // Check if max capacity reached\n        if (this.size >= LevelOrderSegmentTree.MAX_SIZE) {\n            throw new RangeError('Invalid length');\n        }\n\n        // Extend capacity\n        this.array.length += this.array.length + 1;\n\n        // Shift the tree down a level\n        let min = this.level + 1;\n        for (let max = this.length + 1; min < max; max >>>= 1) {\n            this.array.copyWithin(2 * min - 1, min - 1, max - 1);\n            min >>>= 1;\n        }\n\n        // Update pointers\n        this.length += this.level + 1;\n        this.level += this.level + 1;\n    }\n    /**\n     * Shift the tree to the highest non-full level\n     */\n    protected shrink(): void {\n        const length = this.length - this.level;\n\n        // Check base case\n        if (length < 2) {\n            this.array.copyWithin(0, this.level, this.length);\n            this.level = 0;\n            this.length = length;\n            this.array.length = length;\n            return;\n        }\n\n        // Get the highest node\n        let min = this.level + 1;\n        let mask = msp(length);\n        min = min / lsp(min | mask) - 1;\n\n        // Check if shrinking is possible\n        if (min < 2) {\n            return;\n        }\n\n        // Update the tree\n        this.level = 0;\n        for (let max = min + 1; mask; min += min + 1) {\n            this.level += this.level + 1;\n            this.array.copyWithin(this.level, min, max);\n            mask >>>= 1;\n            max += max + 2 + +((length & mask) > 0);\n        }\n\n        // Update pointers\n        this.length = this.level + length;\n        this.array.length = 2 * this.level + 1;\n    }\n}\n","import { Stack } from './stack';\n\n/**\n * An implementation of the {@link Stack} interface using an array\n */\nexport class ArrayStack<T> implements Stack<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * Instantiate the stack.\n     *\n     * @param elements - A set of elements to initialize the stack with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    peek(): T | undefined {\n        return this.array[this.array.length - 1];\n    }\n\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n\n    push(element: T): number {\n        return this.array.push(element);\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        const array = this.array;\n        for (let i = array.length; i > 0; yield array[--i]) {}\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Stack } from './stack';\n\n/**\n * A linked list implementation of the {@link Stack} interface\n */\nexport class LinkedStack<T> implements Stack<T> {\n    /**\n     * The list containing every element.\n     */\n    protected list: List<T>;\n    /**\n     * Instantiate the stack.\n     *\n     * @param elements - A set of elements to initialize the stack with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList();\n        for (const element of elements || []) {\n            this.push(element);\n        }\n    }\n\n    clear(): void {\n        this.list.clear();\n    }\n\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n\n    pop(): T | undefined {\n        return this.list.shift();\n    }\n\n    push(element: T): number {\n        return this.list.unshift(element);\n    }\n\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","import { CompareFn } from '..';\nimport { AATreeNode } from './aaTreeNode';\nimport {\n    clone,\n    search,\n    Edge,\n    inOrderTraverse,\n    leftmost,\n    leftmostStack,\n    preOrderTraverse,\n    removeStack,\n    rightmost,\n    rightmostStack,\n    searchStack,\n    debug,\n} from './binaryTreeUtils';\nimport { SortedTree } from './sortedTree';\nimport { isArray } from 'src/collection/arrayUtils';\nimport { LinkedNode } from 'src/list';\n\n/**\n * An AA tree is a form of balanced tree used for storing and retrieving ordered data efficiently\n * ([source](https://en.wikipedia.org/wiki/AA_tree)).\n *\n * AA trees are named for Arne Andersson, their inventor. They are a variation of the red–black tree,\n * which supports efficient addition and deletion of entries. Unlike red–black trees, additional\n * constraints on the balancing mechanism greatly simplifies the implementation as well as\n * maintenance operations; While a red–black tree needs to consider seven different shapes\n * to properly balance the tree, an AA tree only needs to consider two shapes.\n *\n * The performance of an AA tree is equivalent to the performance of a red–black tree.\n * While an AA tree makes more rotations than a red-black tree, the simpler algorithms\n * tend to be faster, which balances out to similar performance. A red-black tree is\n * more consistent in its performance, but an AA tree tends to be flatter, which results\n * in slightly faster search times.\n */\nexport class AATree<T> implements SortedTree<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * Indicates how to handle duplicates:\n     * - < 0 : Add to left subtree\n     * - = 0 : Do now allow duplicates\n     * - > 0 : Add to right subtree\n     */\n    protected dupeWeight: number;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The node at the \"top\" of the heap.\n     */\n    protected root: AATreeNode<T> | undefined;\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>);\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param allowDuplicates - Whether to allow duplicates\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, allowDuplicates: boolean, elements?: Iterable<T>);\n    constructor(\n        compareFn: CompareFn<T>,\n        allowDuplicates?: boolean | Iterable<T>,\n        elements?: Iterable<T>,\n    ) {\n        if (typeof allowDuplicates !== 'boolean') {\n            elements = allowDuplicates;\n            allowDuplicates = true;\n        }\n        this.compare = compareFn;\n        this.dupeWeight = +allowDuplicates;\n        this.length = 0;\n        this.build(elements ?? []);\n    }\n\n    add(element: T): this {\n        // Find the element\n        const sentinel = { left: this.root } as AATreeNode<T>;\n        let edge: Edge<AATreeNode<T>> = { from: sentinel, label: 'left', to: this.root };\n        let stack = searchStack(element, { value: edge }, this.compare, this.dupeWeight);\n\n        // If element already exists\n        if (stack.value.to != null) {\n            return this;\n        }\n\n        // Add element\n        edge = stack.value;\n        let label = edge.label;\n        edge.from![label!] = { level: 1, value: element };\n\n        // Balance the tree\n        while (stack.next) {\n            stack = stack.next;\n            edge = stack.value;\n            edge.to = split(skew(edge.to));\n            edge.from![(label = edge.label!)] = edge.to;\n        }\n\n        // Update state\n        ++this.length;\n        this.root = sentinel.left;\n        return this;\n    }\n\n    clear(): void {\n        this.root = undefined;\n        this.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    delete(element: T): boolean {\n        // Remove the element if found\n        const sentinel = { left: this.root } as AATreeNode<T>;\n        const edge: Edge<AATreeNode<T>> = { from: sentinel, label: 'left', to: this.root };\n        const stack = searchStack(element, { value: edge }, this.compare, 0);\n        const removed = remove(stack);\n\n        // Update state\n        this.root = sentinel.left;\n        this.length -= +removed;\n        return removed;\n    }\n\n    has(element: T): boolean {\n        return search(element, this.root, this.compare) != null;\n    }\n\n    max(): T | undefined {\n        return rightmost(this.root)?.value;\n    }\n\n    min(): T | undefined {\n        return leftmost(this.root)?.value;\n    }\n\n    pop(): T | undefined {\n        // Find the maximum value\n        const sentinel = { left: this.root } as AATreeNode<T>;\n        const edge: Edge<AATreeNode<T>> = { from: sentinel, label: 'left', to: this.root };\n        const stack = rightmostStack({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.root = sentinel.left;\n        this.length -= +removed;\n        return value;\n    }\n\n    shift(): T | undefined {\n        // Find the minimum value\n        const sentinel = { left: this.root } as AATreeNode<T>;\n        const edge: Edge<AATreeNode<T>> = { from: sentinel, label: 'left', to: this.root };\n        const stack = leftmostStack({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.root = sentinel.left;\n        this.length -= +removed;\n        return value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        for (const node of inOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.delete(curElement)) {\n            this.add(newElement);\n            return true;\n        }\n        return false;\n    }\n\n    protected build(obj: Iterable<T>): void {\n        if (isArray(obj)) {\n            for (let i = 0; i < obj.length; ++i) {\n                this.add(obj[i]);\n            }\n        } else if (obj instanceof AATree && this.compare === obj.compare) {\n            this.root = clone(obj.root);\n            this.length = obj.size;\n        } else {\n            for (const element of obj) {\n                this.add(element);\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nexport function remove<T>(stack: LinkedNode<Edge<AATreeNode<T>>>): boolean {\n    let edge = stack.value;\n    let node = edge.to;\n\n    // If not found\n    if (node == null) {\n        return false;\n    }\n\n    // Remove the node\n    stack = removeStack(stack);\n\n    // Update the tree\n    while (stack.next) {\n        stack = stack.next;\n        edge = stack.value;\n        node = edge.to!;\n\n        // Decrease levels\n        const level = 1 + Math.min(node.left?.level ?? 0, node.right?.level ?? 0);\n        if (level < node.level) {\n            node.level = level;\n            if (node.right != null && level < node.right.level) {\n                node.right.level = level;\n            }\n        }\n\n        // Balance\n        node = skew(node);\n        node.right = skew(node.right);\n        if (node.right != null) {\n            node.right.right = skew(node.right.right);\n        }\n        node = split(node);\n        node.right = split(node.right);\n\n        // Make the update\n        edge.from![edge.label!] = edge.to = node;\n    }\n\n    return true;\n}\n/**\n * @internal\n */\nexport function skew<T>(node?: undefined): undefined;\nexport function skew<T>(node: AATreeNode<T>): AATreeNode<T>;\nexport function skew<T>(node?: AATreeNode<T>): AATreeNode<T> | undefined;\nexport function skew<T>(node?: AATreeNode<T>): AATreeNode<T> | undefined {\n    if (node == null || node.left == null || node.level != node.left.level) {\n        return node;\n    }\n    const left = node.left;\n    node.left = left.right;\n    left.right = node;\n    return left;\n}\n/**\n * @internal\n */\nexport function split<T>(node?: undefined): undefined;\nexport function split<T>(node: AATreeNode<T>): AATreeNode<T>;\nexport function split<T>(node?: AATreeNode<T>): AATreeNode<T> | undefined;\nexport function split<T>(node?: AATreeNode<T>): AATreeNode<T> | undefined {\n    if (\n        node == null ||\n        node.right == null ||\n        node.right.right == null ||\n        node.level != node.right.right.level\n    ) {\n        return node;\n    }\n    const right = node.right;\n    node.right = right.left;\n    right.left = node;\n    ++right.level;\n    return right;\n}\n","import { CompareFn } from 'src';\nimport { AVLTreeNode } from './avlTreeNode';\nimport {\n    clone,\n    search,\n    Edge,\n    inOrderTraverse,\n    leftmost,\n    leftmostStack,\n    preOrderTraverse,\n    rightmost,\n    rightmostStack,\n    searchStack,\n    removeStack,\n} from './binaryTreeUtils';\nimport { SortedTree } from './sortedTree';\nimport { isArray } from 'src/collection/arrayUtils';\nimport { LinkedNode } from 'src/list';\n\n/**\n * An AVL tree is a self-balancing binary search tree ([source](https://en.wikipedia.org/wiki/AVL_tree)).\n *\n * It is named after inventors Georgy Adelson-Velsky and Evgenii Landis and was the first such\n * data structure to be invented. In an AVL tree, the heights of the two child\n * subtrees of any node differ by at most one; if at any time they differ by more\n * than one, rebalancing is done to restore this property.\n *\n * Lookup, insertion, and deletion all take O(log(n)) time in both the average and worst cases,\n * where n is the number of nodes in the tree prior to the operation. Insertions and deletions\n * may require the tree to be rebalanced by one or more tree rotations.\n *\n * AVL trees are often compared with red–black trees as both take O(log(n))\n * time for the basic operations. For lookup-intensive applications, AVL trees are\n * faster than red–black trees because they are more strictly balanced.\n * Similar to red–black trees, AVL trees are height-balanced.\n */\nexport class AVLTree<T> implements SortedTree<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * Indicates how to handle duplicates:\n     * - < 0 : Add to left subtree\n     * - = 0 : Do now allow duplicates\n     * - > 0 : Add to right subtree\n     */\n    protected dupeWeight: number;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The root of the tree.\n     */\n    protected root: AVLTreeNode<T>;\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>);\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param allowDuplicates - Whether to allow duplicates\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, allowDuplicates: boolean, elements?: Iterable<T>);\n    constructor(\n        compareFn: CompareFn<T>,\n        allowDuplicates?: boolean | Iterable<T>,\n        elements?: Iterable<T>,\n    ) {\n        if (typeof allowDuplicates !== 'boolean') {\n            elements = allowDuplicates;\n            allowDuplicates = true;\n        }\n        this.compare = compareFn;\n        this.dupeWeight = +allowDuplicates;\n        this.length = 0;\n        this.root = {} as AVLTreeNode<T>;\n        this.build(elements ?? []);\n    }\n\n    add(element: T): this {\n        // Find the element\n        let edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        let stack = searchStack(element, { value: edge }, this.compare, this.dupeWeight);\n\n        // If element already exists\n        if (stack.value.to != null) {\n            return this;\n        }\n\n        // Add element\n        edge = stack.value;\n        let label = edge.label;\n        edge.from![label!] = { balanceFactor: 0, value: element };\n\n        // Balance the tree\n        while (stack.next) {\n            stack = stack.next;\n            edge = stack.value;\n            edge.to!.balanceFactor += label === 'left' ? -1 : 1;\n            edge.to = balance(edge.to!);\n            edge.from![(label = edge.label!)] = edge.to;\n            if (edge.to!.balanceFactor === 0) {\n                break;\n            }\n        }\n\n        // Update state\n        ++this.length;\n        return this;\n    }\n\n    clear(): void {\n        this.root.left = undefined;\n        this.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    delete(element: T): boolean {\n        // Remove the element if found\n        const edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        const stack = searchStack(element, { value: edge }, this.compare, 0);\n        const removed = remove(stack);\n\n        // Update state\n        this.length -= +removed;\n        return removed;\n    }\n\n    has(element: T): boolean {\n        return search(element, this.root.left, this.compare) != null;\n    }\n\n    max(): T | undefined {\n        return rightmost(this.root.left)?.value;\n    }\n\n    min(): T | undefined {\n        return leftmost(this.root.left)?.value;\n    }\n\n    pop(): T | undefined {\n        // Find the maximum value\n        const edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        const stack = rightmostStack({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.length -= +removed;\n        return value;\n    }\n\n    shift(): T | undefined {\n        // Find the minimum value\n        const edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        const stack = leftmostStack({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.length -= +removed;\n        return value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        for (const node of inOrderTraverse(this.root.left)) {\n            yield node.value;\n        }\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root.left)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.delete(curElement)) {\n            this.add(newElement);\n            return true;\n        }\n        return false;\n    }\n\n    protected build(obj: Iterable<T>): void {\n        if (isArray(obj)) {\n            for (let i = 0; i < obj.length; ++i) {\n                this.add(obj[i]);\n            }\n        } else if (obj instanceof AVLTree && this.compare === obj.compare) {\n            this.root = clone(obj.root);\n            this.length = obj.size;\n        } else {\n            for (const element of obj) {\n                this.add(element);\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nexport function balance<T>(node: AVLTreeNode<T>): AVLTreeNode<T> {\n    if (node.balanceFactor > 1) {\n        if (node.right!.balanceFactor < 0) {\n            node.right = rotateR(node.right!);\n        }\n        node = rotateL(node);\n    } else if (node.balanceFactor < -1) {\n        if (node.left!.balanceFactor > 0) {\n            node.left = rotateL(node.left!);\n        }\n        node = rotateR(node);\n    }\n    return node;\n}\n/**\n * @internal\n */\nexport function remove<T>(stack: LinkedNode<Edge<AVLTreeNode<T>>>): boolean {\n    let edge = stack.value;\n    const node = edge.to;\n\n    // If not found\n    if (node == null) {\n        return false;\n    }\n\n    // Remove the node\n    stack = removeStack(stack);\n\n    // Balance the tree\n    let label = stack.value.label;\n    while (stack.next) {\n        stack = stack.next;\n        edge = stack.value;\n        edge.to!.balanceFactor -= label === 'left' ? -1 : 1;\n        edge.to = balance(edge.to!);\n        edge.from![(label = edge.label)!] = edge.to;\n        if (edge.to!.balanceFactor !== 0) {\n            break;\n        }\n    }\n\n    return true;\n}\n/**\n * @internal\n */\nexport function rotateL<T>(P: AVLTreeNode<T>): AVLTreeNode<T> {\n    const R = P.right!;\n    P.right = R.left;\n    R.left = P;\n    P.balanceFactor -= 1 + Math.max(0, R.balanceFactor);\n    R.balanceFactor -= 1 - Math.min(0, P.balanceFactor);\n    return R;\n}\n/**\n * @internal\n */\nexport function rotateR<T>(P: AVLTreeNode<T>): AVLTreeNode<T> {\n    const L = P.left!;\n    P.left = L.right;\n    L.right = P;\n    P.balanceFactor += 1 - Math.min(0, L.balanceFactor);\n    L.balanceFactor += 1 + Math.max(0, P.balanceFactor);\n    return L;\n}\n"],"sourceRoot":""}