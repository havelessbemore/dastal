{"version":3,"sources":["webpack://Dastal/webpack/universalModuleDefinition","webpack://Dastal/webpack/bootstrap","webpack://Dastal/webpack/runtime/define property getters","webpack://Dastal/webpack/runtime/hasOwnProperty shorthand","webpack://Dastal/webpack/runtime/make namespace object","webpack://Dastal/./src/collection/index.ts","webpack://Dastal/./src/math/numberUtils.ts","webpack://Dastal/./src/env/utils.ts","webpack://Dastal/./src/env/index.ts","webpack://Dastal/./src/utils/arrayUtils.ts","webpack://Dastal/./src/heap/utils.ts","webpack://Dastal/./src/heap/binaryHeap.ts","webpack://Dastal/./src/tree/binaryTreeUtils.ts","webpack://Dastal/./src/heap/skewHeap.ts","webpack://Dastal/./src/list/arrayList.ts","webpack://Dastal/./src/list/utils.ts","webpack://Dastal/./src/list/doublyLinkedList.ts","webpack://Dastal/./src/list/linkedList.ts","webpack://Dastal/./src/math/u32.ts","webpack://Dastal/./src/queue/arrayQueue.ts","webpack://Dastal/./src/queue/linkedQueue.ts","webpack://Dastal/./src/segmentTree/inOrderSegmentTree.ts","webpack://Dastal/./src/segmentTree/levelOrderSegmentTree.ts","webpack://Dastal/./src/stack/arrayStack.ts","webpack://Dastal/./src/stack/linkedStack.ts","webpack://Dastal/./src/tree/aaTree.ts","webpack://Dastal/./src/tree/avlTree.ts","webpack://Dastal/./src/utils/iteratorUtils.ts","webpack://Dastal/./src/utils/stringUtils.ts"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","isCollection","iterator","clamp","num","min","max","Math","wrapLeft","wrapRight","wrap","getMaxArgumentsLength","accuracy","a1","a2","b1","b2","test","length","i","fn","Array","fill","err","floor","MAX_ARRAY_LENGTH","compareFn","mid","ceil","cmp","search","Number","MAX_SAFE_INTEGER","e","isArray","isTypedArray","TypedArray","getPrototypeOf","Uint8Array","splice","array","start","count","elements","numArgs","args","slice","out","bind","apply","n","bubbleUp","index","parentIndex","parent","heapify","sinkDown","childIndex","child","skewMerge","heaps","lists","push","list","tree","right","next","compare","a","b","tail","pop","mergeKSorted","heap","node","left","BinaryHeap","this","addAll","RangeError","element","indexOf","last","size","undefined","curElement","newElement","inOrderTraverse","preOrderTraverse","removeStack","stack","dir","edge","to","temp","successorStack","predecessorStack","from","label","clone","assign","leftmost","leftmostStack","rightmostStack","rightmost","comp","searchStack","dupeWeight","paths","toBinaryTree","nodes","par","SkewHeap","merge","comparator","ArrayList","copyWithin","callback","prev","shift","sort","unshift","arguments","len","linkedMergeSort","isDoubly","lens","heads","tails","linkedMergeSorted","DoublyLinkedList","_addAll","_get","nodeA","nodeB","head","view","LinkedList","_copyWithin","nodeC","nodeD","remove","deleted","newTail","add","bitsSet","invert","msp","u32","isPow2","lsb","log2","lsp","lsps","lzb","lzp","msb","msps","reverse","ArrayQueue","LinkedQueue","clear","InOrderSegmentTree","combine","aggregate","offset","operation","dc","dp","mask","LevelOrderSegmentTree","level","build","shrink","grow","cap","ArrayStack","LinkedStack","AATree","allowDuplicates","sentinel","split","skew","removed","delete","AVLTree","balanceFactor","balance","rotateR","rotateL","P","R","L","always","done","first","res","join","iterators","res2","never","once","skip","iter","pad","str","maxLen","fillString","diff","padStart","padEnd"],"mappings":"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","file":"dastal.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Dastal\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Dastal\"] = factory();\n\telse\n\t\troot[\"Dastal\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Collection } from './collection';\n\nexport * from './collection';\n\n/**\n * Check if a value is a {@link Collection}.\n *\n * @param obj - The value to check.\n *\n * @returns - `true` if obj is a Collection, `false` otherwise.\n */\nexport function isCollection(obj: any): obj is Collection<unknown> {\n    return (\n        obj != null && typeof obj['size'] === 'number' && typeof obj[Symbol.iterator] === 'function'\n    );\n}\n","/**\n * Limits a number to be within a given range.\n *\n * f(x, min, max) = y, where min <= y <= max\n *\n * @param num - The number to clamp\n * @param min - The minimum result value, inclusive\n * @param max - The maximum result value, inclusive\n *\n * @returns The clamped number\n */\nexport function clamp(num: number, min: number, max: number): number {\n    return Math.min(max, Math.max(min, num));\n}\n/**\n * Wraps a number if below a given range\n *\n * f(x, min, max) = {\n *    x, where x >= min\n *    max - (min - x), where x < min\n * }\n *\n * @param num - The number to wrap\n * @param min - The minimum result value, inclusive\n * @param max - The maximum result value, inclusive\n *\n * @returns - The wrapped number\n */\nexport function wrapLeft(num: number, min: number, max: number): number {\n    return num < min ? max - min + num : num;\n}\n/**\n * Wraps a number if above a given range\n *\n * f(x, min, max) = {\n *    x, where x <= max\n *    min + (x - max), where x > max\n * }\n *\n * @param num - The number to wrap\n * @param min - The minimum result value, inclusive\n * @param max - The maximum result value, inclusive\n *\n * @returns - The wrapped number\n */\nexport function wrapRight(num: number, min: number, max: number): number {\n    return num > max ? min + (num - max) : num;\n}\n/**\n * Wraps a number if outside a given range\n *\n * @param num - The number to wrap\n * @param min - The minimum result value, inclusive\n * @param max - The maximum result value, inclusive\n *\n * @returns - The wrapped number\n */\nexport function wrap(num: number, min: number, max: number): number {\n    return num < min ? max - min + num : wrapRight(num, min, max);\n}\n","import { clamp } from 'src/math/numberUtils';\n\n/**\n * Find the intended value given a comparison function. If not found,\n * finds the closest intended value.\n *\n * @param min - The minimum value\n * @param max - The maximum value\n * @param compareFn - The comparison function\n */\nexport function search(min: number, max: number, compareFn: (index: number) => number): number {\n    while (min < max) {\n        const mid = min + Math.ceil((max - min) / 2);\n        const cmp = compareFn(mid);\n        if (cmp < 0) {\n            max = mid - 1;\n        } else if (cmp > 0) {\n            min = mid;\n        } else {\n            return mid;\n        }\n    }\n    return min;\n}\n/**\n * Get the maximum number of arguments that\n * can be passed to a simple function.\n *\n * According to the [ECMA-262](https://tc39.es/ecma262/#sec-list-and-record-specification-type),\n * there is no maximum. In practice, different environments impose their own\n * limit. The limit closely depends on available stack memory.\n *\n * @param accuracy - A number from  0 - 1 to determine\n * if calculation prioritizes speed vs accuracy, with 1\n * being most accurate and 0 being speediest. Be default,\n * speed is preferred.\n *\n * **Note 1**: The output depends on the available\n * stack memory at the time this function is called.\n * For that reason, any output should be used as soon\n * as possible and in its original context.\n *\n * **Note 2**: When `accuracy = 1`, the output has\n * an error margin of +- 0.85% from the actual maximum.\n * When `accuracy = 0`, the output has an error margin of -25%.\n *\n * **Note 3**: Even with a simple function, it may\n * still cause a stack overflow if `accuracy` is high.\n * The margin of error should be taken into account\n * before usage, such as multiplying the output\n * by <= 1 - error_margin (for example: `0.99*output`).\n *\n * **Note 4**: The actual maximum depends on the\n * amount of stack memory to be used by the intended function.\n * For that reason, the actual maximum may be lower\n * than this function's output. The output should only be\n * used as an upper bound / starting point for\n * an actual maximum.\n *\n *    - The simplest way to do this\n * is to decrease the multiple mentioned in note 3 (such as\n * to 80%). This should work for most usage, as most functions\n * are relatively flat (little to no nested function calls)\n * and/or use a reasonable amount of variables.\n *\n *    - For more accuracy, the intended function can be\n * profiled to come up with a more exact estimate.\n */\nexport function getMaxArgumentsLength(accuracy = 0): number {\n    /**\n     * Let:\n     * - T = total stack memory\n     * - U = used stack memory\n     * - F = size of a function call in the stack\n     * - V = size of a variable in the stack\n     *\n     * Then:\n     *    T ~= aF + bV + U\n     *\n     * If we set the number of variables `b`, we can find `a`\n     * by calling the function recursively until the stack overflows:\n     *    1: T ~= a_1F + b_1V + U\n     *\n     * If we change `b` to a different number:\n     *    2: T ~= a_2F + b_2V + U\n     *\n     * Putting them together:\n     *    a_1F + b_1V + U ~= a_2F + b_2V + U\n     *    a_1F + b_1V ~= a_2F + b_2V\n     *    (a_1 - a_2)F ~= (b_2 - b_1)V\n     *    F ~= ((b_2 - b_1) / (a_1 - a_2))V\n     *\n     * Replacing F in #1, we can find the maximum number of variables\n     * given the available stack memory:\n     *    T ~= a_1F + b_1V + U\n     *    T ~= a_1*((b_2 - b_1) / (a_1 - a_2))V + b_1V + U\n     *    T - U ~= (a_1*((b_2 - b_1) / (a_1 - a_2)) + b_1)V\n     *    (T - U) / V ~= (a_1*((b_2 - b_1) / (a_1 - a_2)) + b_1)\n     *\n     * Note: The stack will overflow on a whole number of functions. So\n     * the larger `b` is, the smaller and less accurate 'a' is. So\n     * the result is more accurate for lower number of variables.\n     * But less variables take longer to overflow the stack.\n     * The tradeoff between quick vs accuracy is thus decided\n     * via an input parameter.\n     */\n    accuracy = 7 * (1 - clamp(accuracy, 0, 1));\n    let a1 = 0,\n        a2 = 0,\n        b1 = 0,\n        b2 = 0;\n    function test(length: number): number {\n        let i = 0;\n        try {\n            (function fn(...args: number[]) {\n                ++i;\n                fn(...args);\n            })(...new Array(length).fill(0));\n        } catch (err) {}\n        return i;\n    }\n    do {\n        b2 = 2 << accuracy;\n        b1 = b2 - 1;\n        a1 = test(b1);\n        a2 = test(b2);\n    } while (a1 === a2 && --accuracy >= 0);\n    if (a1 === a2) {\n        return 0;\n    }\n    return Math.floor(((a1 + 2) * (a2 * b2 - a1 * b1)) / (a1 - a2) + a1 * b1 + 10);\n}\n/**\n * Get the maximum length of an array.\n *\n * At the time of implementation, the [ECMA-262](https://tc39.es/ecma262/#array-index)\n * defines the maximum as: `0 <= array.length <= 2**32 - 1`\n *\n * That said, the actual maximum may change over time and/or unique environments.\n */\nexport function getMaxArrayLength(): number {\n    return search(0, Number.MAX_SAFE_INTEGER, (i) => {\n        try {\n            new Array(i);\n            return 1;\n        } catch (e) {\n            return -1;\n        }\n    });\n}\n","import { getMaxArrayLength } from './utils';\n\nexport { getMaxArgumentsLength } from './utils';\nexport const MAX_ARRAY_LENGTH: number = getMaxArrayLength();\n","import { getMaxArgumentsLength } from 'src/env';\nimport { clamp, wrapLeft } from 'src/math/numberUtils';\n\n/**\n * Check if a value is an Array or TypedArray.\n *\n * @param obj - The value to check.\n *\n * @returns `true` if an Array or TypedArray, otherwise `false`.\n */\nexport function isArray<T = any>(obj: unknown): obj is T[] {\n    return obj instanceof Array || isTypedArray(obj);\n}\n/**\n * Check if a value is a TypedArray.\n *\n * See [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)\n * for more details.\n *\n * @param obj - The value to check.\n *\n * @returns `true` if a TypedArray, otherwise `false`.\n */\nexport const isTypedArray = (() => {\n    const TypedArray = Object.getPrototypeOf(Uint8Array);\n    return function isTypedArray<T = any>(obj: unknown): obj is T[] {\n        return obj instanceof TypedArray;\n    };\n})();\n/**\n * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n *\n * Contrary to Array.splice, this will not throw an error if too many new elements are given as arguments.\n *\n * @param array - The array to splice.\n * @param start - The zero-based location in the array from which to start removing elements.\n * @param count - The number of elements to remove.\n * @param elements - The new elements to splice in.\n *\n * @returns - An array containing the deleted elements.\n */\nexport function splice<T>(array: T[], start?: number, count?: number, elements?: T[]): T[] {\n    start = clamp(wrapLeft(start ?? 0, 0, array.length), 0, array.length);\n    count = clamp(count ?? array.length, 0, array.length - start);\n\n    // Base case.\n    if (elements == null) {\n        return array.splice(start, count);\n    }\n\n    // Perform the initial splice.\n    const numArgs = Math.floor(0.8 * getMaxArgumentsLength(0) - 2);\n    let args = elements.slice(0, numArgs);\n    const out = array.splice.bind(array, start, count).apply(array, args);\n\n    // Splice in new elements as long as there is space in the array\n    const n = elements.length;\n    for (let i = args.length; i < n; i += args.length) {\n        args = elements.splice(i, numArgs);\n        array.splice.bind(array, start + i, 0).apply(array, args);\n    }\n\n    // Return deleted elements.\n    return out;\n}\n","import { LinkedNode } from 'src/list';\nimport { BinaryTreeNode } from 'src/tree/binaryTreeNode';\nimport { CompareFn } from '..';\n\n/**\n * @internal\n */\nexport function bubbleUp<T>(index: number, compareFn: CompareFn<T>, array: Array<T>): void {\n    const value = array[index];\n\n    // Until we reach the top of the heap\n    while (index > 0) {\n        // Get the parent\n        const parentIndex = Math.floor((index + 1) / 2) - 1;\n        const parent = array[parentIndex]!;\n\n        // If the parent is above or equal to value, the heap is in order\n        if (compareFn(parent, value) <= 0) {\n            break;\n        }\n\n        // Swap the parent with value and continue\n        array[parentIndex] = value;\n        array[index] = parent;\n        index = parentIndex;\n    }\n}\n/**\n * @internal\n */\nexport function heapify<T>(compareFn: CompareFn<T>, array: T[]): void {\n    for (let i = (array.length + 1) >>> 1; i > 0; sinkDown(--i, compareFn, array)) {}\n}\n/**\n * @internal\n */\nexport function mergeKSorted<T>(compareFn: CompareFn<T>, lists: LinkedNode<T>[]): LinkedNode<T> {\n    // Heapify the list of lists based on\n    // the value at the head of each list.\n    const compare: CompareFn<LinkedNode<T>> = (a, b) => compareFn(a.value, b.value);\n    heapify(compare, lists);\n\n    // Combine the lists into a single list.\n    const list: LinkedNode<T> = lists[0];\n    for (let tail = list; lists.length > 1; tail = tail.next) {\n        lists[0] = lists[0].next ?? lists.pop()!;\n        sinkDown(0, compare, lists);\n        tail.next = lists[0];\n    }\n\n    return list;\n}\n/**\n * @internal\n */\nexport function sinkDown<T>(index: number, compareFn: CompareFn<T>, array: Array<T>): void {\n    const n = array.length;\n    const value = array[index];\n    do {\n        // Compute the left child's index\n        let childIndex = 2 * index + 1;\n\n        // If no children exist\n        if (childIndex >= n) {\n            break;\n        }\n\n        // Decide which child to compare with\n        let child = array[childIndex];\n        if (childIndex + 1 < n && compareFn(array[childIndex + 1], child) <= 0) {\n            child = array[++childIndex]!;\n        }\n\n        // If value <= child\n        if (compareFn(value, child) <= 0) {\n            break;\n        }\n\n        // Swap value and child\n        array[index] = child;\n        array[childIndex] = value;\n        index = childIndex;\n    } while (true);\n}\n/**\n * See: https://en.wikipedia.org/wiki/Skew_heap#Merging_two_heaps\n *\n * @param compareFn - A function used to determine the order of the heap.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n * @param heaps - An iterable of heaps to merge\n *\n * @returns The new heap\n */\nexport function skewMerge<T>(\n    compareFn: CompareFn<T>,\n    heaps: (BinaryTreeNode<T> | undefined)[],\n): BinaryTreeNode<T> | undefined {\n    // Remove undefineds and initialize a list for each heap\n    const lists: LinkedNode<BinaryTreeNode<T>>[] = [];\n    for (let i = 0; i < heaps.length; ++i) {\n        if (heaps[i] != null) {\n            lists.push({ value: heaps[i]! });\n        }\n    }\n\n    // Check if nothing to merge with\n    if (lists.length < 2) {\n        return lists[0]?.value;\n    }\n\n    // Split each heap into subheaps by cutting every right path; From the root\n    // node, sever the right node to make the right child its own heap. Repeat\n    // until you can't go right. This will turn each heap into a list of heaps\n    // where the root either only has a left child or no children at all. The\n    // lists of heaps will be in desc order (from bottom to top).\n    for (let i = 0; i < lists.length; ++i) {\n        let list = lists[i];\n        let tree: BinaryTreeNode<T> | undefined = list.value;\n        while ((tree = tree.right)) {\n            list = { next: list, value: tree };\n        }\n        lists[i] = list;\n    }\n\n    // Combine the lists into a single list in desc order\n    let list: LinkedNode<BinaryTreeNode<T>> | undefined = mergeKSorted(\n        (a, b) => compareFn(b.value, a.value),\n        lists,\n    );\n\n    // While there are still multiple heaps, iteratively combine\n    // the first two (from left to right). If the root of the second-to-first\n    // subtree has a left child, swap it to be the right child. Link the root\n    // of the last subtree as the left child of the second-to-first subtree.\n    let heap = list.value;\n    while ((list = list.next)) {\n        const node = list.value;\n        node.right = node.left;\n        node.left = heap;\n        heap = node;\n    }\n\n    return heap;\n}\n","import { isArray } from 'src/utils/arrayUtils';\nimport { MAX_ARRAY_LENGTH } from 'src/env';\nimport { CompareFn } from '..';\nimport { Heap } from './heap';\nimport { bubbleUp, heapify, sinkDown } from './utils';\n\n/**\n * A binary heap is a heap implemented as a binary tree with an additional shape property\n * ([source](https://en.wikipedia.org/wiki/Binary_heap)).\n *\n * **Shape property**: Must be a complete binary tree. This means all levels of the tree\n * (except possibly the last one) are fully filled. If the last level of the tree is incomplete,\n * the nodes of that level are filled from left to right.\n *\n * #### Complexity\n *\n * | Property | Average | Worst |\n * | :------- | :------ | :---- |\n * | Space    | O(n)    | O(n)\n * | Push     | O(1)    | O(log n)\n * | Peek     | O(1)\t| O(1)\n * | Pop      | O(log n)| O(log n)\n * | Search   | O(n)    | O(n)\n */\nexport class BinaryHeap<T> implements Heap<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * Instantiate a heap.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>) {\n        this.compare = compareFn;\n        this.array = [];\n        this.addAll(elements ?? []);\n    }\n\n    addAll(elements: Iterable<T>): number {\n        const array = this.array;\n        const length = array.length;\n\n        if (isArray(elements)) {\n            if (array.length + elements.length > MAX_ARRAY_LENGTH) {\n                throw new RangeError('Invalid heap length');\n            }\n            for (let i = 0; i < elements.length; ++i) {\n                array.push(elements[i]);\n            }\n        } else {\n            for (const element of elements) {\n                if (array.length >= MAX_ARRAY_LENGTH) {\n                    throw new RangeError('Invalid heap length');\n                }\n                array.push(element);\n            }\n        }\n\n        // Update the heap\n        if (length < array.length) {\n            heapify(this.compare, array);\n        }\n\n        return array.length;\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        return this.array.indexOf(element) >= 0;\n    }\n\n    delete(element: T): boolean {\n        const index = this.array.indexOf(element);\n        if (index < 0) {\n            return false;\n        }\n\n        // If deleting the last value\n        const last = this.array.pop()!;\n        if (index >= this.array.length) {\n            return true;\n        }\n\n        // Add the last value to the\n        // deleted index and update the heap\n        this.array[index] = last;\n        sinkDown(index, this.compare, this.array);\n        bubbleUp(index, this.compare, this.array);\n        return true;\n    }\n\n    merge(heap: Heap<T>): this {\n        const array = this.array;\n\n        if (heap.size < 1) {\n            return this;\n        }\n\n        if (array.length + heap.size > MAX_ARRAY_LENGTH) {\n            throw new RangeError('Invalid heap length');\n        }\n\n        for (const element of heap) {\n            array.push(element);\n        }\n\n        heapify(this.compare, array);\n        return this;\n    }\n\n    peek(): T | undefined {\n        return this.array.length > 0 ? this.array[0] : undefined;\n    }\n\n    pop(): T | undefined {\n        if (this.array.length < 1) {\n            return undefined;\n        }\n\n        // Get the root and the last value\n        const value = this.array[0];\n        const last = this.array.pop();\n\n        // If value != last\n        if (this.array.length > 0) {\n            // Move the last value to the root and update the heap\n            this.array[0] = last!;\n            sinkDown(0, this.compare, this.array);\n        }\n\n        return value;\n    }\n\n    push(value: T): number {\n        // Add new value to the end of the heap\n        this.array.push(value);\n\n        // Update the heap\n        bubbleUp(this.array.length - 1, this.compare, this.array);\n        return this.size;\n    }\n\n    pushPop(value: T): T {\n        // If empty or value is <= to root\n        if (this.array.length < 1 || this.compare(value, this.array[0]) <= 0) {\n            return value;\n        }\n\n        // Swap the root and value\n        const root = this.array[0];\n        this.array[0] = value;\n        sinkDown(0, this.compare, this.array);\n        return root;\n    }\n\n    replace(value: T): T | undefined {\n        // If empty\n        if (this.array.length < 1) {\n            this.array.push(value);\n            return undefined;\n        }\n\n        // Swap the root with value\n        const root = this.array[0];\n        this.array[0] = value;\n        value = root;\n\n        // Update the heap\n        sinkDown(0, this.compare, this.array);\n        return value;\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    *sorted(): Iterable<T> {\n        if (this.array.length < 1) {\n            return;\n        }\n        const array = this.array;\n        const heap = new BinaryHeap<number>((a, b) => this.compare(array[a], array[b]), [0]);\n        do {\n            let index = heap.pop()!;\n            if (index < array.length) {\n                yield array[index];\n                index = 2 * index + 1;\n                index < array.length && heap.push(index);\n                ++index < array.length && heap.push(index);\n            }\n        } while (heap.size > 0);\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        const index = this.array.indexOf(curElement);\n        if (index < 0) {\n            return false;\n        }\n        this.array[index] = newElement;\n        sinkDown(index, this.compare, this.array);\n        bubbleUp(index, this.compare, this.array);\n        return true;\n    }\n}\n","import { pad } from 'src/utils/stringUtils';\nimport { LinkedNode } from 'src/list';\nimport { CompareFn } from '..';\nimport { BinaryTreeNode } from './binaryTreeNode';\n\n/**\n * @internal\n */\nexport interface Edge<Node extends BinaryTreeNode<unknown>> {\n    label?: 'left' | 'right';\n    from?: Node;\n    to?: Node;\n}\n/**\n * [source](https://stackoverflow.com/questions/51419176/how-to-get-a-subset-of-keyof-t-whose-value-tk-are-callable-functions-in-typ)\n * \n * @internal\n *\nexport type KeyOfType<T, U> = {[K in keyof T]: T[K] extends U ? K: never}[keyof T];\n*/\n/**\n * @internal\n */\nexport function debug<N extends BinaryTreeNode<T>, T = any>(\n    root: N | undefined,\n    mapFn?: (node: N) => any,\n): void {\n    mapFn = mapFn == null ? (n) => n.value : mapFn;\n\n    // Turn the tree into an array in level-order\n    const array: string[] = [];\n    for (const node of levelOrderTraverse(root, true)) {\n        array.push(node ? `${mapFn(node)}` : '?');\n    }\n\n    // If empty\n    if (array.length < 1) {\n        console.log('<empty>\\n');\n        return;\n    }\n\n    // Find the longest value string\n    const lenV = array.reduce((p, c) => Math.max(p, c.length), 0);\n\n    // Pad each value\n    for (let i = 0; i < array.length; ++i) {\n        array[i] = pad(array[i], lenV, ' ');\n    }\n\n    // Split values into levels\n    const levels = [];\n    for (let n = 1; array.length > 0; n *= 2) {\n        levels.push(array.splice(0, n));\n    }\n\n    // Initialize formatting variables\n    let branch = '_'.repeat(1 + lenV / 2);\n    let offset = '';\n    const offsetOffset = ' '.repeat(branch.length);\n    let separator = ' '.repeat(1 + ((lenV - 1) & 1));\n    const separatorOffset = ' '.repeat(lenV);\n\n    // Build the last level\n    array.length = levels.length;\n    array[array.length - 1] = levels.pop()!.join(separator);\n\n    // Build remaining levels in reverse\n    for (let n = levels.length - 1; n >= 0; --n) {\n        const level = levels.pop()!;\n        for (let j = 0; j < level.length; ++j) {\n            level[j] = branch + level[j] + branch;\n        }\n        array[n] = offset + level.join(separator);\n        branch += branch;\n        offset += offset + offsetOffset;\n        separator += separator + separatorOffset;\n    }\n\n    // Output\n    console.log(array.join('\\n'), '\\n');\n}\n/**\n * @internal\n */\nexport function removeStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n    dir = true,\n): LinkedNode<Edge<Node>> {\n    let edge = stack.value;\n    let node = edge.to;\n\n    // Input check\n    if (node == null) {\n        return stack;\n    }\n\n    // Find the replacement\n    if (node.right == null) {\n        // If no right child, replace with left\n        node = node.left;\n    } else if (node.left == null) {\n        // If no left child, replace with right\n        node = node.right;\n    } else if (dir) {\n        // Replace with the successor\n        stack = successorStack(stack);\n        edge = stack.value;\n        const temp = edge.to!;\n        node.value = temp.value;\n        node = temp.right;\n    } else {\n        // Replace with the predecessor\n        stack = predecessorStack(stack);\n        edge = stack.value;\n        const temp = edge.to!;\n        node.value = temp.value;\n        node = temp.left;\n    }\n\n    // Make the replacement / update the tree\n    edge.to = node;\n    if (edge.from) {\n        edge.from[edge.label!] = edge.to = node;\n    }\n\n    return stack;\n}\n/**\n * @internal\n */\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: undefined): undefined;\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: Node): Node;\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: Node | undefined): Node | undefined;\nexport function clone<T, Node extends BinaryTreeNode<T>>(node: Node | undefined): Node | undefined {\n    if (node == null) {\n        return undefined;\n    }\n    const out: Node = Object.assign({}, node);\n    let stack: LinkedNode<Node> | undefined = { value: out };\n    do {\n        node = stack.value;\n        stack = stack.next;\n        if (node.left) {\n            stack = { next: stack, value: (node.left = Object.assign({}, node.left)) };\n        }\n        if (node.right) {\n            stack = { next: stack, value: (node.right = Object.assign({}, node.right)) };\n        }\n    } while (stack);\n    return out;\n}\n/**\n * @internal\n */\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(node: undefined): undefined;\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(node: Node): Node;\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined;\nexport function leftmost<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined {\n    if (node == null) {\n        return undefined;\n    }\n    while (node.left) {\n        node = node.left;\n    }\n    return node;\n}\n/**\n * @internal\n */\nexport function leftmostStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    let node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    while (node.left) {\n        stack = { next: stack, value: { label: 'left', from: node, to: node.left } };\n        node = node.left;\n    }\n    return stack;\n}\n/**\n * @internal\n */\nexport function* inOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    let stack: LinkedNode<Node> | undefined = undefined;\n\n    while (node) {\n        stack = { next: stack, value: node };\n        node = node.left;\n    }\n\n    while (stack) {\n        node = stack.value;\n        stack = stack.next;\n        yield node;\n        node = node.right;\n        while (node) {\n            stack = { next: stack, value: node };\n            node = node.left;\n        }\n    }\n}\n/**\n * @internal\n */\nexport function levelOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n    padded?: false,\n): Generator<Node>;\nexport function levelOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n    padded: true,\n): Generator<Node | undefined>;\nexport function* levelOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n    padded = false,\n): Generator<Node | undefined> {\n    const nil = {} as LinkedNode<Node | undefined>;\n    let head: LinkedNode<Node | undefined> = { value: node };\n    let tail = head;\n    for (let cont = node != null; cont; head = head.next!) {\n        tail = tail.next = nil;\n        for (cont = false; head !== nil; head = head.next!) {\n            node = head.value;\n            if (node) {\n                yield node;\n                cont ||= node.left != null || node.right != null;\n                tail = tail.next = { value: node.left };\n                tail = tail.next = { value: node.right };\n            } else if (padded) {\n                yield undefined;\n                tail = tail.next = { value: undefined };\n                tail = tail.next = { value: undefined };\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nexport function* postOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    interface Meta {\n        seen: boolean;\n        node?: Node;\n    }\n    let stack: LinkedNode<Meta> | undefined = { value: { seen: false, node } };\n    do {\n        const meta = stack.value;\n        stack = stack.next;\n        if (meta.node) {\n            if (meta.seen) {\n                yield meta.node;\n            } else {\n                meta.seen = true;\n                stack = { next: stack, value: meta };\n                stack = { next: stack, value: { seen: false, node: meta.node.right } };\n                stack = { next: stack, value: { seen: false, node: meta.node.left } };\n            }\n        }\n    } while (stack);\n}\n/**\n * @internal\n */\nexport function predecessor<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined {\n    return node == null ? undefined : rightmost(node.left);\n}\n/**\n * @internal\n */\nexport function predecessorStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    const node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    stack = { next: stack, value: { label: 'left', from: node, to: node.left } };\n    return rightmostStack(stack);\n}\n/**\n * @internal\n */\nexport function* preOrderTraverse<T, Node extends BinaryTreeNode<T>>(\n    node: Node | undefined,\n): Generator<Node> {\n    let stack: LinkedNode<Node | undefined> | undefined = { value: node };\n    do {\n        node = stack.value;\n        stack = stack.next;\n        if (node) {\n            yield node;\n            stack = { next: stack, value: node.right };\n            stack = { next: stack, value: node.left };\n        }\n    } while (stack);\n}\n/**\n * @internal\n */\nexport function reverse<Node extends BinaryTreeNode<unknown>>(root?: Node): void {\n    if (root == null) {\n        return;\n    }\n    for (const node of preOrderTraverse(root)) {\n        const left = node.left;\n        node.left = node.right;\n        node.right = left;\n    }\n}\n/**\n * @internal\n */\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(node: undefined): undefined;\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(node: Node): Node;\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined;\nexport function rightmost<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined {\n    if (node == null) {\n        return undefined;\n    }\n    while (node.right) {\n        node = node.right;\n    }\n    return node;\n}\n/**\n * @internal\n */\nexport function rightmostStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    let node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    while (node.right) {\n        stack = { next: stack, value: { label: 'right', from: node, to: node.right } };\n        node = node.right;\n    }\n    return stack;\n}\n/**\n * Assumes sorted by compareFn\n * @internal\n */\nexport function search<T, Node extends BinaryTreeNode<T>>(\n    element: T,\n    node: Node | undefined,\n    compareFn: CompareFn<T>,\n): Node | undefined {\n    while (node) {\n        const comp: number = compareFn(element, node.value);\n        if (comp == 0) {\n            break;\n        }\n        node = comp < 0 ? node.left : node.right;\n    }\n    return node;\n}\n/**\n * Assumes sorted by compareFn\n * @internal\n */\nexport function searchStack<T, Node extends BinaryTreeNode<T>>(\n    element: T,\n    stack: LinkedNode<Edge<Node>>,\n    compareFn: CompareFn<T>,\n    dupeWeight = 0,\n): LinkedNode<Edge<Node>> {\n    const paths: ['left', 'right'] = ['left', 'right'];\n    let node = stack.value.to;\n    while (node) {\n        const comp: number = compareFn(element, node.value) || dupeWeight;\n        if (comp === 0) {\n            break;\n        }\n        const label = paths[+(comp > 0)];\n        stack = { next: stack, value: { label, from: node, to: node[label] } };\n        node = node[label]!;\n    }\n    return stack;\n}\n/**\n * @internal\n */\nexport function successor<Node extends BinaryTreeNode<unknown>>(\n    node: Node | undefined,\n): Node | undefined {\n    return node == null ? undefined : leftmost(node.right);\n}\n/**\n * @internal\n */\nexport function successorStack<Node extends BinaryTreeNode<unknown>>(\n    stack: LinkedNode<Edge<Node>>,\n): LinkedNode<Edge<Node>> {\n    const node = stack.value.to;\n    if (node == null) {\n        return stack;\n    }\n    stack = { next: stack, value: { label: 'right', from: node, to: node.right } };\n    return leftmostStack(stack);\n}\n/**\n * Turn an array into a binary tree. Assumes elements are in level-order.\n *\n * @internal\n */\nexport function toBinaryTree<T>(\n    elements: (T | undefined)[] | undefined,\n): BinaryTreeNode<T> | undefined {\n    if (elements == null || elements.length < 1 || elements[0] == null) {\n        return undefined;\n    }\n    const n = elements.length;\n    const nodes: BinaryTreeNode<T>[] = new Array(n);\n    nodes[0] = { value: elements[0] };\n    for (let i = 1; i < n; ++i) {\n        if (elements[i] == null) {\n            continue;\n        }\n        const par = nodes[(i - 1) >>> 1];\n        const node = { value: elements[i]! };\n        nodes[i] = node;\n        if (i & 1) {\n            par.left = node;\n        } else {\n            par.right = node;\n        }\n    }\n    return nodes[0];\n}\n","import { isArray } from 'src/utils/arrayUtils';\nimport { BinaryTreeNode } from 'src/tree/binaryTreeNode';\nimport { clone, preOrderTraverse, toBinaryTree } from 'src/tree/binaryTreeUtils';\nimport { CompareFn } from '..';\nimport { BinaryHeap } from './binaryHeap';\nimport { Heap } from './heap';\nimport { skewMerge } from './utils';\n\n/**\n * A skew heap is a heap implemented as a binary tree\n * ([source](https://en.wikipedia.org/wiki/Skew_heap)).\n *\n * A skew heap is a self-adjusting heap which attempts to maintain balance\n * by unconditionally swapping all nodes in the merge path when merging two heaps. Every\n * operation that modifies the heap (e.g. push, pop, merge) is considered a merge and is done\n * by using a skew heap merge.\n *\n * Skew heaps can merge more quickly than binary heaps. This can seem contradictory, since\n * skew heaps have no structural constraints and no guarantee that the height of the tree is\n * logarithmic (i.e. balanced). However, amortized complexity analysis can demonstrate that\n * all operations on a skew heap can be done in O(log(n). More specifically, the\n * amortized complexity is known to be log<sub>φ</sub>(n) where φ is the golden ratio. This is\n * approximately 1.44*log<sub>2</sub>(n).\n *\n * #### Complexity\n *\n * | Property | Average  | Worst |\n * | :------- | :------  | :---- |\n * | Space    | O(n)     | O(n)\n * | Push     | O(log n) | O(log n)\n * | Peek     | O(1)\t | O(1)\n * | Pop      | O(log n) | O(log n)\n * | Search   | O(n)     | O(n)\n */\nexport class SkewHeap<T> implements Heap<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The node at the \"top\" of the heap.\n     */\n    protected root: BinaryTreeNode<T> | undefined;\n    /**\n     * Instantiate a heap.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the heap with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>) {\n        this.compare = compareFn;\n        this.length = 0;\n        this.addAll(elements ?? []);\n    }\n\n    addAll(elements: Iterable<T>): number {\n        if (isArray(elements)) {\n            for (let i = 0; i < elements.length; ++i) {\n                this.push(elements[i]);\n            }\n        } else if (elements instanceof SkewHeap || elements instanceof BinaryHeap) {\n            this.merge(elements);\n        } else {\n            for (const element of elements) {\n                this.push(element);\n            }\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.root = undefined;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    contains(element: T): boolean {\n        for (const node of preOrderTraverse(this.root)) {\n            if (element === node.value) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    delete(element: T): boolean {\n        if (this.root == null) {\n            return false;\n        }\n        if (this.root.value === element) {\n            this.pop()!;\n            return true;\n        }\n        for (const par of preOrderTraverse(this.root)) {\n            const key: keyof BinaryTreeNode<T> | undefined =\n                par.left && par.left.value === element\n                    ? 'left'\n                    : par.right && par.right.value === element\n                    ? 'right'\n                    : undefined;\n            if (key != null) {\n                const node = par[key]!;\n                par[key] = skewMerge(this.compare, [node.left, node.right]);\n                --this.length;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    merge(heap: Heap<T>): this {\n        if (this.compare !== heap.comparator()) {\n            this.addAll(heap);\n        } else if (heap instanceof SkewHeap) {\n            this.root = skewMerge(this.compare, [this.root, clone(heap.root)]);\n            this.length += heap.size;\n        } else if (heap instanceof BinaryHeap) {\n            this.root = skewMerge(this.compare, [this.root, toBinaryTree(heap['array'])!]);\n            this.length += heap.size;\n        } else {\n            this.addAll(heap);\n        }\n        return this;\n    }\n\n    peek(): T | undefined {\n        return this.root?.value;\n    }\n\n    pop(): T | undefined {\n        if (this.root == null) {\n            return undefined;\n        }\n        const value = this.root.value;\n        this.root = skewMerge(this.compare, [this.root.left, this.root.right]);\n        --this.length;\n        return value;\n    }\n\n    push(value: T): number {\n        this.root = skewMerge(this.compare, [this.root, { value }]);\n        return ++this.length;\n    }\n\n    pushPop(value: T): T {\n        this.push(value);\n        return this.pop()!;\n    }\n\n    replace(value: T): T | undefined {\n        if (this.root == null) {\n            this.root = { value };\n            this.length = 1;\n            return undefined;\n        }\n        const out = this.root.value;\n        this.root = skewMerge(this.compare, [this.root.left, this.root.right, { value }]);\n        return out;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        if (this.root == null) {\n            return;\n        }\n        const heap = new SkewHeap<BinaryTreeNode<T>>(\n            (a, b) => this.compare(a.value, b.value),\n            [this.root],\n        );\n        do {\n            const node = heap.pop()!;\n            yield node.value;\n            node.left && heap.push(node.left);\n            node.right && heap.push(node.right);\n        } while (heap.size > 0);\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.root == null) {\n            return false;\n        }\n\n        if (this.root.value === curElement) {\n            this.root = skewMerge(this.compare, [\n                this.root.left,\n                this.root.right,\n                { value: newElement },\n            ]);\n            return true;\n        }\n\n        let node: BinaryTreeNode<T> | undefined = undefined;\n        for (const par of preOrderTraverse(this.root)) {\n            if (par.left && par.left.value === curElement) {\n                node = par.left;\n                par.left = undefined;\n                break;\n            }\n            if (par.right && par.right.value === curElement) {\n                node = par.right;\n                par.right = undefined;\n                break;\n            }\n        }\n\n        if (node == null) {\n            return false;\n        }\n\n        this.root = skewMerge(this.compare, [\n            this.root,\n            node.left,\n            node.right,\n            { value: newElement },\n        ]);\n        return true;\n    }\n}\n","import { splice } from 'src/utils/arrayUtils';\nimport { clamp, wrapLeft } from 'src/math/numberUtils';\nimport { CompareFn } from '..';\nimport { List } from './list';\n\n/**\n * An implementation of the {@link List} interface using an array\n */\nexport class ArrayList<T> implements List<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: Array<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    add(index: number, element: T): number {\n        if (index >= 0 && index <= this.size) {\n            this.array.splice(index, 0, element);\n        }\n        return this.size;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.size) {\n            splice(this.array, index, 0, Array.from(elements));\n        }\n        return this.size;\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    concat(...lists: Iterable<T>[]): ArrayList<T> {\n        const out = new ArrayList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        index = clamp(wrapLeft(index, 0, this.size), 0, this.size);\n        min = clamp(wrapLeft(min ?? 0, 0, this.size), 0, this.size);\n        max = clamp(wrapLeft(max ?? this.size, 0, this.size), 0, this.size);\n        this.array.copyWithin(index, min, max);\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.size), 0, this.size);\n        max = clamp(wrapLeft(max ?? this.size, 0, this.size), 0, this.size);\n        this.array.fill(element, min, max);\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array[index];\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        let value: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            value = this.array[index];\n            this.array[index] = callback(value);\n        }\n        return value;\n    }\n\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n\n    push(element: T): number {\n        return this.array.push(element);\n    }\n\n    remove(index: number): T | undefined {\n        return index < 0 || index >= this.size ? undefined : this.array.splice(index, 1)[0];\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.size), 0, this.size);\n        max = clamp(wrapLeft(max ?? this.size, 0, this.size), 0, this.size) - 1;\n        while (min < max) {\n            const temp = this.array[min];\n            this.array[min++] = this.array[max];\n            this.array[max--] = temp;\n        }\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        let prev: T | undefined = undefined;\n        if (index >= 0 && index < this.size) {\n            prev = this.array[index];\n            this.array[index] = element;\n        }\n        return prev;\n    }\n\n    shift(): T | undefined {\n        return this.array.shift();\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    slice(min?: number, max?: number): ArrayList<T> {\n        return new ArrayList(this.array.slice(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        return new ArrayList(splice(this.array, start, count, Array.from(elements || [])));\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        this.array.sort(compareFn);\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n\n    unshift(element: T): number {\n        return this.array.unshift(element);\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = clamp(wrapLeft((min as number) ?? 0, 0, this.size), 0, this.size);\n        max = clamp(wrapLeft((max as number) ?? this.size, 0, this.size), 0, this.size);\n        while (min < max) {\n            this.array[min] = callback(this.array[min], min);\n            ++min;\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = clamp(wrapLeft(min ?? 0, 0, this.size), 0, this.size);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.size;\n        } else if (max >= 0) {\n            len = () => Math.min(max, this.size);\n        } else {\n            len = () => this.size + max;\n        }\n\n        while (min < len()) {\n            yield this.array[min++];\n        }\n    }\n}\n","import { CompareFn } from '..';\nimport { DoublyLinkedNode } from './doublyLinkedNode';\nimport { LinkedNode } from './linkedNode';\n\n/**\n * Sorts a list in place.\n *\n * Works on complete lists as well as sublists and circular lists:\n * - Linked lists will keep the link to the next node beyond the sorted section\n * - Doubly linked lists will keep links to the prev and next nodes outside the sorted section\n *\n * @param node - The head of the list\n * @param len - The length of the list beginning from node\n * @param isDoubly - Whether node is a doubly linked node\n * @param compareFn - A function used to determine the order of elements.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n *\n * @returns The new head and tail of the sorted list\n *\n * @internal\n */\nexport function linkedMergeSort<T, Node extends LinkedNode<T>>(\n    node: Node,\n    len: number,\n    isDoubly: boolean,\n    compareFn: CompareFn<T>,\n): [Node, Node] {\n    // Base case\n    if (len < 2) {\n        return [node, node];\n    }\n\n    // Split the list into two halves and sort them\n    len = len / 2;\n    const lens: [number, number] = [Math.ceil(len), Math.floor(len)];\n    const heads = linkedMergeSort(node, lens[0], isDoubly, compareFn);\n    const tails = linkedMergeSort(heads[1].next as Node, lens[1], isDoubly, compareFn);\n\n    // Group the heads and tails together\n    node = heads[1];\n    heads[1] = tails[0];\n    tails[0] = node;\n    tails[0].next = tails[1].next;\n\n    // Merge the sorted halves\n    const prev = (heads[0] as DoublyLinkedNode<T>).prev;\n    node = linkedMergeSorted(heads, lens, isDoubly, compareFn);\n    if (isDoubly) {\n        (node as DoublyLinkedNode<T>).prev = prev;\n    }\n\n    // Return the head and tail\n    return [node, tails[+(lens[0] < 1)]];\n}\n/**\n * Merges two sorted lists.\n *\n * @param nodes - The heads of the lists\n * @param lens - The lengths of the lists\n * @param isDoubly - Whether the lists are a doubly linked\n * @param compareFn - A function used to determine the order of elements.\n *\n * It is expected to return:\n * - A negative value if first argument < second argument\n * - Zero if first argument == second argument\n * - A positive value if first argument > second argument\n *\n * @returns The new head of the sorted list\n *\n * @internal\n */\nexport function linkedMergeSorted<T, Node extends LinkedNode<T>>(\n    heads: [Node, Node],\n    lens: [number, number],\n    isDoubly: boolean,\n    compareFn: CompareFn<T>,\n): Node {\n    const root = {} as Node;\n\n    let node = root;\n    do {\n        const index = +(compareFn(heads[0].value, heads[1].value) > 0);\n        node.next = heads[index];\n        if (isDoubly) {\n            (node.next as DoublyLinkedNode<T>).prev = node;\n        }\n        node = node.next as Node;\n        heads[index] = node.next as Node;\n        --lens[index];\n    } while (lens[0] > 0 && lens[1] > 0);\n\n    // Add any remaining nodes\n    node.next = heads[+(lens[0] < 1)];\n    if (isDoubly && node.next) {\n        (node.next as DoublyLinkedNode<T>).prev = node;\n    }\n    return root.next as Node;\n}\n","import { clamp, wrapLeft } from 'src/math/numberUtils';\nimport { CompareFn } from '..';\nimport { DoublyLinkedNode } from './doublyLinkedNode';\nimport { List } from './list';\nimport { linkedMergeSort } from './utils';\n\n/**\n * A (circular) doubly-linked list implementation of the {@link List} interface.\n *\n * Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.\n */\nexport class DoublyLinkedList<T> implements List<T> {\n    /**\n     * The number of elements in the list\n     */\n    protected length: number;\n    /**\n     * The sentinel node at the fron of the list\n     */\n    protected root: DoublyLinkedNode<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as DoublyLinkedNode<T>;\n        this.root.prev = this.root.next = this.root;\n        this._addAll(this.root, elements ?? []);\n    }\n\n    add(index: number, value: T): number {\n        if (index < 0 || index > this.length) {\n            return this.length;\n        }\n        const prev = this._get(index - 1);\n        const node = { next: prev.next, prev, value };\n        prev.next = node;\n        node.next!.prev = node;\n        return ++this.length;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index <= this.length) {\n            this._addAll(this._get(index), elements);\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.root.prev = this.root.next = this.root;\n    }\n\n    concat(...lists: Iterable<T>[]): DoublyLinkedList<T> {\n        const out = new DoublyLinkedList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to the same section\n        index = clamp(wrapLeft(index, 0, this.length), 0, this.length);\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Check for overlap edge case\n        if (min < index && index < max) {\n            let nodeA = this._get(max);\n            let nodeB = this._get(index + (max - min));\n            do {\n                nodeA = nodeA.prev!;\n                nodeB = nodeB.prev!;\n                nodeB.value = nodeA.value;\n            } while (++min < max);\n            return this;\n        }\n\n        // Copy the section to the destination\n        let nodeA = this._get(min);\n        let nodeB = this._get(index);\n        do {\n            nodeB.value = nodeA.value;\n            nodeA = nodeA.next!;\n            nodeB = nodeB.next!;\n        } while (++min < max);\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        return index < 0 || index >= this.length ? undefined : this._get(index).value;\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const tail = this.root.prev!;\n        tail.prev!.next = this.root;\n        this.root.prev = tail.prev;\n        --this.length;\n        return tail.value;\n    }\n\n    push(value: T): number {\n        const prev = this.root.prev!;\n        const node = { next: this.root, prev, value };\n        prev.next = this.root.prev = node;\n        return ++this.length;\n    }\n\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        node.prev!.next = node.next;\n        node.next!.prev = node.prev;\n        --this.length;\n        return node.value;\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        const tail = root.next!;\n        let node = tail;\n        do {\n            const temp = node.next!;\n            node.next = node.prev;\n            node.prev = temp;\n            root.next = node;\n            node = temp;\n        } while (++min < max);\n        tail.next = node;\n        node.prev = tail;\n        root.next!.prev = root;\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n\n    shift(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const head = this.root.next!;\n        head.next!.prev = this.root;\n        this.root.next = head.next;\n        --this.length;\n        return head.value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    slice(min?: number, max?: number): DoublyLinkedList<T> {\n        return new DoublyLinkedList(this.view(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = clamp(wrapLeft(start ?? 0, 0, this.length), 0, this.length);\n        count = clamp(count ?? this.size, 0, this.size - start);\n\n        // If not modifying the list\n        const list = new DoublyLinkedList<T>();\n        if (elements == null && count < 1) {\n            return list;\n        }\n\n        // Delete elements\n        let node = this._get(start);\n        while (count-- > 0) {\n            list.push(node.value);\n            node.prev!.next = node.next!;\n            node.next!.prev = node.prev!;\n            node = node.next!;\n            --this.length;\n        }\n\n        // Add elements\n        this._addAll(node, elements ?? []);\n\n        return list;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        if (this.length > 1) {\n            const [head, tail] = linkedMergeSort(this.root.next!, this.length, true, compareFn);\n            this.root.next = head;\n            tail.next!.prev = tail;\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let node = this.root.next!; node !== this.root; node = node.next!) {\n            yield node.value;\n        }\n    }\n\n    unshift(value: T): number {\n        const head = this.root.next!;\n        const node = { next: head, prev: this.root, value };\n        this.root.next = head.prev = node;\n        return ++this.length;\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = clamp(wrapLeft((min as number) ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft((max as number) ?? this.length, 0, this.length), 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.length;\n        } else if (max >= 0) {\n            len = () => max;\n        } else {\n            len = () => this.length + max;\n        }\n\n        if (min < len()) {\n            let node = this._get(min);\n            do {\n                yield node.value;\n                node = node.next!;\n            } while (++min < len() && node !== this.root);\n        }\n    }\n    /**\n     *\n     */\n    protected _addAll(next: DoublyLinkedNode<T>, elements: Iterable<T>): void {\n        let prev = next.prev!;\n        for (const value of elements) {\n            const node = { prev, value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        next.prev = prev;\n    }\n    /**\n     * A helper method to iterate and return the node at the given index.\n     *\n     * Depending on the index, the list will be traversed from beginning or end; whichever is closest to the specified index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number): DoublyLinkedNode<T> {\n        let node = this.root;\n        if (index < this.length / 2) {\n            while (index-- >= 0) {\n                node = node.next!;\n            }\n        } else {\n            for (index = this.length - index; index > 0; --index) {\n                node = node.prev!;\n            }\n        }\n        return node;\n    }\n}\n","import { clamp, wrapLeft } from 'src/math/numberUtils';\nimport { CompareFn } from '..';\nimport { LinkedNode } from './linkedNode';\nimport { List } from './list';\nimport { linkedMergeSort } from './utils';\n\n/**\n * A (circular) linked list implementation of the {@link List} interface.\n */\nexport class LinkedList<T> implements List<T> {\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The sentinel node at the front of the list.\n     */\n    protected root: LinkedNode<T>;\n    /**\n     * The last node of the list.\n     */\n    protected tail: LinkedNode<T>;\n    /**\n     * Instantiate the list.\n     *\n     * @param elements - A set of elements to initialize the list with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.length = 0;\n        this.root = {} as LinkedNode<T>;\n        this.root.next = this.root;\n        this.tail = this._addAll(this.root, elements ?? []);\n    }\n\n    add(index: number, value: T): number {\n        if (index >= 0 && index < this.length) {\n            const prev = this._get(index - 1);\n            prev.next = { value, next: prev.next };\n            ++this.length;\n        } else if (index === this.length) {\n            this.push(value);\n        }\n        return this.length;\n    }\n\n    addAll(index: number, elements: Iterable<T>): number {\n        if (index >= 0 && index < this.length) {\n            this._addAll(this._get(index - 1), elements);\n        } else if (index === this.length) {\n            this.tail = this._addAll(this.tail, elements);\n        }\n        return this.length;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.tail = this.root.next = this.root;\n    }\n\n    concat(...lists: Iterable<T>[]): LinkedList<T> {\n        const out = new LinkedList(this);\n        for (const list of lists) {\n            out.addAll(out.size, list);\n        }\n        return out;\n    }\n\n    copyWithin(index: number, min?: number, max?: number): this {\n        // Check if copying to itself\n        index = clamp(wrapLeft(index, 0, this.length), 0, this.length);\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        if (min === index) {\n            return this;\n        }\n\n        // Check if the section to copy has no length\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        max = min + Math.min(max - min, this.length - index);\n        if (min >= max) {\n            return this;\n        }\n\n        // Copy to earlier in the list\n        if (index < min) {\n            const node = this._get(index - 1);\n            this._copyWithin(this._get(min - index - 1, node), node, max - min);\n            return this;\n        }\n\n        // Copy to later in the list\n        if (index > max) {\n            const node = this._get(min - 1);\n            this._copyWithin(node, this._get(index - min - 1, node), max - min);\n            return this;\n        }\n\n        // Copy to overlapping destination\n        const nodeA = this._get(min - 1);\n        const nodeC = this._get(max - min - 1, nodeA);\n        const nodeD = this._copyWithin(nodeA, nodeC, index - min);\n        if (index + (max - min) >= this.length) {\n            this.tail = nodeC;\n        }\n        const temp = nodeA.next;\n        nodeA.next = nodeC.next;\n        nodeC.next = nodeD.next;\n        nodeD.next = temp;\n        return this;\n    }\n\n    fill(element: T, min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = element;\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    get(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        return index < this.length - 1 ? this._get(index).value : this.tail.value;\n    }\n\n    getSet(index: number, callback: (element: T) => T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = index < this.length - 1 ? this._get(index) : this.tail;\n        const value = node.value;\n        node.value = callback(node.value);\n        return value;\n    }\n\n    pop(): T | undefined {\n        if (this.length < 1) {\n            return undefined;\n        }\n        const value = this.tail.value;\n        this.tail = this._get(this.length - 2);\n        this.tail.next = this.root;\n        --this.length;\n        return value;\n    }\n\n    push(value: T): number {\n        const tail: LinkedNode<T> = { next: this.root, value };\n        this.tail.next = tail;\n        this.tail = tail;\n        return ++this.length;\n    }\n\n    remove(index: number): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const prev = this._get(index - 1);\n        const node = prev.next!;\n        prev.next = node.next;\n        if (index === --this.length) {\n            this.tail = prev;\n        }\n        return node.value;\n    }\n\n    reverse(min?: number, max?: number): this {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft(max ?? this.length, 0, this.length), 0, this.length);\n        if (max - min < 2) {\n            return this;\n        }\n        const root = this._get(min - 1);\n        this.tail = max >= this.length ? root.next! : this.tail;\n        const tail = root.next!;\n        let prev = tail;\n        let node = tail.next!;\n        while (++min < max) {\n            const next = node.next!;\n            node.next = prev;\n            prev = node;\n            node = next;\n        }\n        root.next = prev;\n        tail.next = node;\n        return this;\n    }\n\n    set(index: number, element: T): T | undefined {\n        if (index < 0 || index >= this.length) {\n            return undefined;\n        }\n        const node = this._get(index);\n        const value = node.value;\n        node.value = element;\n        return value;\n    }\n\n    shift(): T | undefined {\n        return this.remove(0);\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    slice(min?: number, max?: number): LinkedList<T> {\n        return new LinkedList(this.view(min, max));\n    }\n\n    splice(start?: number, count?: number, elements?: Iterable<T>): List<T> {\n        start = clamp(wrapLeft(start ?? 0, 0, this.length), 0, this.length);\n        count = clamp(count ?? this.size, 0, this.size - start);\n\n        // If not modifying the list\n        const deleted = new LinkedList<T>();\n        if (elements == null && count < 1) {\n            return deleted;\n        }\n\n        // Delete elements\n        let prev = this._get(start - 1);\n        const newTail = start + count >= this.size;\n        while (count-- > 0) {\n            const node = prev.next!;\n            deleted.push(node.value);\n            prev.next = node.next;\n            --this.length;\n        }\n\n        // Add elements\n        prev = this._addAll(prev, elements ?? []);\n        this.tail = newTail ? prev : this.tail;\n\n        return deleted;\n    }\n\n    sort(compareFn: CompareFn<T>): this {\n        if (this.length > 1) {\n            const [head, tail] = linkedMergeSort(this.root.next!, this.length, false, compareFn);\n            this.root.next = head;\n            this.tail = tail;\n        }\n        return this;\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let node = this.root.next!; node !== this.root; node = node.next!) {\n            yield node.value;\n        }\n    }\n\n    unshift(value: T): number {\n        return this.add(0, value);\n    }\n\n    update(callback: (element: T, index: number) => T): this;\n    update(min: number | undefined, callback: (element: T, index: number) => T): this;\n    update(\n        min: number | undefined,\n        max: number | undefined,\n        callback: (element: T, index: number) => T,\n    ): this;\n    update(\n        min: number | undefined | ((element: T, index: number) => T),\n        max?: number | ((element: T, index: number) => T),\n        callback?: (element: T, index: number) => T,\n    ): this {\n        if (callback == null) {\n            if (arguments.length < 2) {\n                callback = min as (element: T, index: number) => T;\n                min = undefined;\n            } else {\n                callback = max as (element: T, index: number) => T;\n                max = undefined;\n            }\n        }\n        min = clamp(wrapLeft((min as number) ?? 0, 0, this.length), 0, this.length);\n        max = clamp(wrapLeft((max as number) ?? this.length, 0, this.length), 0, this.length);\n        if (min < max) {\n            let node = this._get(min);\n            do {\n                node.value = callback(node.value, min);\n                node = node.next!;\n            } while (++min < max);\n        }\n        return this;\n    }\n\n    *view(min?: number, max?: number): Iterable<T> {\n        min = clamp(wrapLeft(min ?? 0, 0, this.length), 0, this.length);\n\n        let len: () => number;\n        if (max == null) {\n            len = () => this.length;\n        } else if (max >= 0) {\n            len = () => max;\n        } else {\n            len = () => this.length + max;\n        }\n\n        if (min < len()) {\n            let node = this._get(min);\n            do {\n                yield node.value;\n                node = node.next!;\n            } while (++min < len() && node !== this.root);\n        }\n    }\n\n    protected _addAll(prev: LinkedNode<T>, elements: Iterable<T>): LinkedNode<T> {\n        const next = prev.next!;\n        for (const value of elements) {\n            const node = { value };\n            prev.next = node;\n            prev = node;\n            ++this.length;\n        }\n        prev.next = next;\n        return prev;\n    }\n    /**\n     * Copy values from 'from' to 'to'.\n     *\n     * @param from - The initial node to copy from\n     * @param prev - The root of the initial node to copy to\n     * @param count - The number of values to copy\n     */\n    protected _copyWithin(from: LinkedNode<T>, to: LinkedNode<T>, count: number): LinkedNode<T> {\n        while (count-- > 0) {\n            from = from.next!;\n            to = to.next!;\n            to.value = from.value;\n        }\n        return to;\n    }\n    /**\n     * Get the node at the given index.\n     *\n     * @param index - The index to retrieve\n     *\n     * @returns The node at the given index\n     */\n    protected _get(index: number, root: LinkedNode<T> = this.root): LinkedNode<T> {\n        let node = root!;\n        while (index-- >= 0) {\n            node = node.next!;\n        }\n        return node;\n    }\n}\n","/**\n * Bit hacks for 32-bit unsigned numbers.\n */\n\n/**\n * Get the number of bits set of a 32-bit unsigned number ([source](https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel))\n *\n * @param a\n */\nexport function bitsSet(a: number): number {\n    a = a - ((a >>> 1) & 0x55555555);\n    a = (a & 0x33333333) + ((a >>> 2) & 0x33333333);\n    return (((a + (a >>> 4)) & 0xf0f0f0f) * 0x1010101) >>> 24;\n}\n/**\n * Invert the bits of a 32-bit unsigned number.\n *\n * Example: 11 (1011) -> 4 (0100)\n *\n * @param a The number to invert\n *\n * @returns The inverted number\n */\nexport function invert(a: number): number {\n    const b = msp(a);\n    return u32(a ^ (b | (b - 1)));\n}\n/**\n * Check whether a 32-bit unsigned number is a power of 2.\n *\n * Example: 8 (1000) -> true\n *\n * @param a The number to check\n */\nexport function isPow2(a: number): boolean {\n    return (a & (a - 1)) === 0;\n}\n/**\n * Get the Least Significant Bit of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns The lowest bit set\n */\nexport function lsb(a: number): number {\n    return a === 0 ? -1 : 0 | Math.log2(lsp(a));\n}\n/**\n * Get the Least Significant Power of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns 2**lsb(a)\n */\nexport function lsp(a: number): number {\n    return u32(a & -a);\n}\n/**\n * Get the Least Significant Power Set of a 32-bit unsigned number.\n *\n * Example: 54 (110110) -> 6 (000110)\n *\n * @param a\n */\nexport function lsps(a: number): number {\n    return u32(a & (lsp(a + lsp(a)) - 1));\n}\n/**\n * Get the Least Zeroed Bit of a 32-bit unsigned number\n *\n * @param a\n */\nexport function lzb(a: number): number {\n    return lsb(lzp(a));\n}\n/**\n * Get the Least Zeroed Power of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns 2**lzb(a)\n */\nexport function lzp(a: number): number {\n    return u32((a + 1) & ~a);\n}\n/**\n * Get the Most Significant Power of the Least Significant Power Set of a 32-bit unsigned number.\n *\n * Example: 54 (110110) -> 4 (000100)\n *\n * @param a\n */ /*\nexport function mlsp(a: number): number {\n    return (lsp(a + lsp(a)) >>> 1) || u32(0x80000000 & a);\n}\n*/\n/**\n * Get the Most Significant Bit of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns ⌊log2(a)⌋ : the highest bit set\n */\nexport function msb(a: number): number {\n    return a === 0 ? -1 : 0 | Math.log2(u32(a));\n}\n/**\n * Get the Most Significant Power of a 32-bit unsigned number\n *\n * @param a\n *\n * @returns 2**msb(a)\n */\nexport function msp(a: number): number {\n    a |= a >>> 1;\n    a |= a >>> 2;\n    a |= a >>> 4;\n    a |= a >>> 8;\n    a |= a >>> 16;\n    return u32((a >>> 1) + (a & 1));\n}\n/**\n * Get the Most Significant Power Set of a 32-bit unsigned number.\n *\n * Example: 50 (110010) -> 48 (110000)\n *\n * @param a\n */\nexport function msps(a: number): number {\n    let b = a & -a;\n    while (a & (a + b)) {\n        a ^= b;\n        b = a & -a;\n    }\n    return u32(a);\n}\n/**\n * Reverse a 32-bit unsigned number.\n *\n * Example: 50 (110010) -> 19 (010011)\n *\n * @param a\n */\nexport function reverse(a: number): number {\n    a = ((a & 0xaaaaaaaa) >>> 1) | ((a & 0x55555555) << 1);\n    a = ((a & 0xcccccccc) >>> 2) | ((a & 0x33333333) << 2);\n    a = ((a & 0xf0f0f0f0) >>> 4) | ((a & 0x0f0f0f0f) << 4);\n    a = ((a & 0xff00ff00) >>> 8) | ((a & 0x00ff00ff) << 8);\n    return u32((a >>> 16) | (a << 16));\n}\n/**\n * Turn a number into an unsigned 32-bit number\n *\n * @param a\n */\nexport function u32(a: number): number {\n    return a >>> 0;\n}\n","import { Queue } from './queue';\n\n/**\n * An implementation of the {@link Queue} interface using an array\n */\nexport class ArrayQueue<T> implements Queue<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * Instantiate the queue.\n     *\n     * @param elements - A set of elements to initialize the queue with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    dequeue(): T | undefined {\n        return this.size < 1 ? undefined : this.array.shift();\n    }\n\n    enqueue(element: T): number {\n        return this.array.push(element);\n    }\n\n    peek(): T | undefined {\n        return this.size < 1 ? undefined : this.array[0];\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.array[Symbol.iterator]();\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Queue } from './queue';\n\n/**\n * A linked list implementation of the {@link Queue} interface\n */\nexport class LinkedQueue<T> implements Queue<T> {\n    /**\n     * The list containing every element.\n     */\n    protected list: List<T>;\n    /**\n     * Instantiate the queue.\n     *\n     * @param elements - A set of elements to initialize the queue with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList(elements);\n    }\n\n    clear(): void {\n        this.list.clear();\n    }\n\n    dequeue(): T | undefined {\n        return this.list.shift();\n    }\n\n    enqueue(element: T): number {\n        return this.list.push(element);\n    }\n\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the queue.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the queue\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","/**\n * Inspired by [Tristan Hume's IForestIndex](https://thume.ca/2021/03/14/iforests) ([github](https://github.com/trishume/gigatrace))\n *\n *                                                                                                                               +\n *                                /''''''''''''''''''''''''''''''+''''''''''''''''''''''''''''''\\                                |\n *                /''''''''''''''+''''''''''''''\\                |               /'''''''''''''''+''''''''''''''\\                |\n *        /''''''+''''''\\        |        /''''''+'''''\\         |        /''''''+'''''\\         |        /''''''+'''''\\         |\n *    /''+''\\    |    /''+''\\    |    /''+''\\    |    /''+''\\    |    /''+''\\    |    /''+''\\    |    /''+''\\    |    /''+''\\    |\n *   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32\n * --------------------------------------------------------------------------------------------------------------------------------------\n *   0   1   0   1   0   1   0   1   0   1   0   1   0   1   0   1   0   1   0   1   0   1   0   1   0   1   0   1   0   1   0   1   0\n *   0   0   1   1   0   0   1   1   0   0   1   1   0   0   1   1   0   0   1   1   0   0   1   1   0   0   1   1   0   0   1   1   0\n *   0   0   0   0   1   1   1   1   0   0   0   0   1   1   1   1   0   0   0   0   1   1   1   1   0   0   0   0   1   1   1   1   0\n *   0   0   0   0   0   0   0   0   1   1   1   1   1   1   1   1   0   0   0   0   0   0   0   0   1   1   1   1   1   1   1   1   0\n *   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   0\n *   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1\n */\nimport { lsb, lsp, msb, msp } from '../math/u32';\nimport { CombineFn } from '..';\nimport { MAX_ARRAY_LENGTH } from 'src/env';\nimport { SegmentTree } from './segmentTree';\n\n/**\n * A {@link SegmentTree} internally represented by a binary tree array, with nodes stored in in-order traversal.\n *\n * Memory usage: n elements require 2n - 1 space.\n *\n */\nexport class InOrderSegmentTree<T> implements SegmentTree<T> {\n    /**\n     * The set of elements and aggregation nodes for the tree\n     */\n    protected array: T[];\n    /**\n     * The function used to aggregate elements\n     */\n    protected combine: CombineFn<T>;\n    /**\n     * Construct a new segment tree\n     *\n     * @param combine - The function used to aggregate segment information\n     * @param elements - A set of elements to add into the initial tree\n     */\n    constructor(combine: CombineFn<T>, elements: Iterable<T> = []) {\n        this.array = [];\n        this.combine = combine;\n        for (const element of elements) {\n            this.push(element);\n        }\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    pop(): T | undefined {\n        // Sanitize range\n        if (this.array.length < 2) {\n            return this.array.pop();\n        }\n\n        // Return element\n        const out = this.array[this.array.length - 1];\n        this.array.length -= 2;\n        return out;\n    }\n\n    push(element: T): number {\n        // Sanitize range\n        if (this.array.length < 1) {\n            this.array[0] = element;\n            return 1;\n        }\n\n        if (this.array.length + 2 > MAX_ARRAY_LENGTH) {\n            throw new RangeError(`Invalid length`);\n        }\n\n        // Add element\n        this.array.push(element, element);\n        this.aggregate(this.array.length - 1);\n        return this.size;\n    }\n\n    query(min: number, max: number): T {\n        // Sanitize range\n        if (min >= max) {\n            throw new RangeError(`Range [${min}..${max}) is empty`);\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min *= 2;\n        max *= 2;\n\n        // Jump to min's highest aggregation node that is fully within the range\n        let offset = lsp(min | msp(max - min));\n        let value = this.array[min - 1 + (offset >>> 1)];\n\n        // Continue jumping top aggregation nodes until max is reached\n        for (min += offset; min < max; min += offset) {\n            offset = lsp(min | msp(max - min));\n            value = this.combine(value, this.array[min - 1 + (offset >>> 1)]);\n        }\n\n        return value;\n    }\n\n    get size(): number {\n        return (this.array.length + 1) >>> 1;\n    }\n\n    /**\n     * Return an iterator through the tree's elements\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let i = 0; i < this.array.length; i += 2) {\n            yield this.array[i];\n        }\n    }\n\n    update(min: number, max: number, operation: (element: T, index: number) => T): void {\n        // Sanitize range\n        if (min >= max) {\n            return;\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min *= 2;\n        max *= 2;\n\n        // Update the values\n        let value: T;\n        do {\n            this.array[min] = operation(this.array[min], min >>> 1);\n            value = this.aggregate(min);\n            min += 2;\n        } while (min < max);\n\n        // Update remaining aggregation nodes\n        let dc = 0;\n        let dp = lsp(min);\n        max = msb(min ^ (this.array.length + 1)) - lsb(min);\n        for (--min; max > 0; --max) {\n            value = this.combine(value, this.array[min + (dp >>> 1) - dc]);\n            this.array[min] = value;\n            dc = (min & (2 * dp)) >>> 0;\n            min += dp - dc;\n            dp *= 2;\n        }\n    }\n    /**\n     * A helper method to update complete aggregation nodes for an index.\n     *\n     * @params index - The index whose aggregation nodes will be updated.\n     *\n     * @returns - The top aggregation node's new value.\n     */\n    protected aggregate(index: number): T {\n        let element = this.array[index++];\n        for (let mask = 2; index & mask; mask *= 2) {\n            element = this.combine(this.array[index - mask - (mask >>> 1)], element);\n            this.array[index - mask] = element;\n        }\n        return element;\n    }\n}\n","/**\n *  Thanks to [Douglas Wilhelm Harder](https://ece.uwaterloo.ca/~dwharder/aads/Algorithms/Array_resizing/)\n *  for their analysis on array resizing\n */\nimport { isArray } from 'src/utils/arrayUtils';\nimport { isCollection } from 'src/collection';\nimport { Collection } from 'src/collection/collection';\nimport { CombineFn } from '..';\nimport { lsp, msp } from '../math/u32';\nimport { SegmentTree } from './segmentTree';\nimport { MAX_ARRAY_LENGTH } from 'src/env';\n\n/**\n * A {@link SegmentTree} with entries stored in level-order traversal.\n *\n * Memory usage: n elements require n - 1 + 2**(⌊log<sub>2</sub>(n-1)⌋ + 1) space.\n *\n */\nexport class LevelOrderSegmentTree<T> implements SegmentTree<T> {\n    /**\n     * The internal array used to store elements and aggregation nodes\n     */\n    protected array: Array<T>;\n    /**\n     * The function used to aggregate elements\n     */\n    protected combine: CombineFn<T>;\n    /**\n     * The used length (size) of our internal array\n     */\n    protected length: number;\n    /**\n     * The start index for the lowest level\n     */\n    protected level: number;\n    /**\n     * Construct a new {@link SegmentTree}\n     *\n     * @param combinFn - The function used to aggregate elements\n     * @param elements - Initial elements to build into the tree\n     */\n    constructor(combine: CombineFn<T>, elements: Iterable<T> = []) {\n        this.array = [];\n        this.combine = combine;\n        this.length = 0;\n        this.level = 0;\n        this.build(elements);\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.level = 0;\n        this.array.length = 0;\n    }\n\n    pop(): T | undefined {\n        // Sanitize range\n        if (this.length <= this.level) {\n            return undefined;\n        }\n\n        // Remove element\n        const out = this.array[--this.length];\n\n        // If level is <= 1/4 full\n        if (this.size <= (this.level + 1) >>> 2) {\n            this.shrink();\n        }\n\n        return out;\n    }\n\n    push(element: T): number {\n        // If array is full\n        if (this.length >= this.array.length) {\n            this.grow();\n        }\n\n        // Add the new element\n        this.array[this.length++] = element;\n\n        // Update aggregation nodes\n        for (let i = this.length; i & 1; this.array[i - 1] = element) {\n            element = this.combine(this.array[i - 2], element);\n            i >>>= 1;\n        }\n\n        return this.size;\n    }\n\n    query(min: number, max: number): T {\n        // Sanitize range\n        if (min >= max) {\n            throw new RangeError(`Range [${min}..${max}) is empty`);\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices and align with powers of 2\n        min += this.level + 1;\n        max += this.level + 1;\n\n        // Take the longest possible jump from min\n        let offset = lsp(min | msp(max - min));\n        let value: T = this.array[min / offset - 1];\n        min += offset;\n\n        // Continue jumping until max\n        while (min < max) {\n            offset = lsp(min | msp(max - min));\n            value = this.combine(value, this.array[min / offset - 1]);\n            min += offset;\n        }\n\n        return value;\n    }\n\n    get size(): number {\n        return this.length - this.level;\n    }\n\n    /**\n     * Return an iterator through the elements\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (let i = 0; i < this.size; ++i) {\n            yield this.array[this.level + i];\n        }\n    }\n\n    update(min: number, max: number, operation: (element: T, index: number) => T): void {\n        // Sanitize range\n        if (min >= max) {\n            return;\n        }\n        if (min < 0 || max > this.size) {\n            throw new RangeError(`Range [${min}..${max}) not in [0..${this.size})`);\n        }\n\n        // Translate range to interior indices\n        min += this.level;\n        max += this.level;\n\n        // Update the range\n        for (let i = min; i < max; ++i) {\n            this.array[i] = operation(this.array[i], i - this.level);\n        }\n\n        // Update the range's aggregation nodes\n        this.aggregate(min, max);\n    }\n    /**\n     * A helper method to aggregate a range of elements\n     */\n    protected aggregate(min: number, max: number): void {\n        // Align indices with powers of 2\n        ++min;\n        ++max;\n\n        // Aggregate elements\n        for (let cap = this.length + 1; min < max; cap >>>= 1) {\n            max += max & ((max - cap) >>> 31);\n            for (let i = (min | 1) >>> 0; i < max; i += 2) {\n                this.array[(i >>> 1) - 1] = this.combine(this.array[i - 2], this.array[i - 1]);\n            }\n            min >>>= 1;\n            max >>>= 1;\n        }\n    }\n    /**\n     * A helper method used to build the tree\n     *\n     * @param elements The initial set of elements to add into the tree\n     */\n    protected build(elements: Collection<T> | Iterable<T>): void {\n        let key: string | undefined = undefined;\n\n        // Check if the iterable's size can be known.\n        if (isArray(elements)) {\n            key = 'length';\n        } else if (isCollection(elements)) {\n            key = 'size';\n        } else {\n            for (const element of elements) {\n                this.push(element);\n            }\n            return;\n        }\n\n        // Get the iterable's size\n        const n: number = (elements as any)[key];\n\n        // Check for base case\n        if (n < 2) {\n            this.level = 0;\n            this.length = n;\n            this.array.length = 0;\n            this.array.push(...elements);\n            return;\n        }\n\n        // Check if max capacity reached\n        const level = 2 * msp(n - 1) - 1;\n        if (level + n > MAX_ARRAY_LENGTH) {\n            throw new RangeError('Invalid length');\n        }\n\n        // Allocate the array\n        this.level = level;\n        this.length = level;\n        this.array.length = Math.min(2 * level + 1, MAX_ARRAY_LENGTH);\n\n        // Add the elements\n        for (const element of elements) {\n            this.array[this.length++] = element;\n        }\n\n        // Update aggregation nodes\n        this.aggregate(this.level, this.length);\n    }\n    /**\n     * Shift the tree down a level\n     */\n    protected grow(): void {\n        // Check if max capacity reached\n        const level = 2 * this.level + 1;\n        if (level + this.size + 1 > MAX_ARRAY_LENGTH) {\n            throw new RangeError('Invalid length');\n        }\n\n        // Check base case\n        if (this.length < 1) {\n            this.array.length = 1;\n            return;\n        }\n\n        // Extend capacity\n        this.array.length = Math.min(2 * level + 1, MAX_ARRAY_LENGTH);\n\n        // Shift the tree down a level\n        let min = this.level + 1;\n        for (let max = this.length + 1; min < max; max >>>= 1) {\n            this.array.copyWithin(2 * min - 1, min - 1, max - 1);\n            min >>>= 1;\n        }\n\n        // Update pointers\n        this.length += this.level + 1;\n        this.level += this.level + 1;\n    }\n    /**\n     * Shift the tree to the highest non-full level\n     */\n    protected shrink(): void {\n        const length = this.length - this.level;\n\n        // Check base case\n        if (length < 2) {\n            this.array.copyWithin(0, this.level, this.length);\n            this.level = 0;\n            this.length = length;\n            this.array.length = length;\n            return;\n        }\n\n        // Get the highest node\n        let min = this.level + 1;\n        let mask = msp(length);\n        min = min / lsp(min | mask) - 1;\n\n        // Check if shrinking is possible\n        if (min < 2) {\n            return;\n        }\n\n        // Update the tree\n        this.level = 0;\n        for (let max = min + 1; mask; min += min + 1) {\n            this.level += this.level + 1;\n            this.array.copyWithin(this.level, min, max);\n            mask >>>= 1;\n            max += max + 2 + +((length & mask) > 0);\n        }\n\n        // Update pointers\n        this.length = this.level + length;\n        this.array.length = 2 * this.level + 1;\n    }\n}\n","import { Stack } from './stack';\n\n/**\n * An implementation of the {@link Stack} interface using an array\n */\nexport class ArrayStack<T> implements Stack<T> {\n    /**\n     * The array containing every element.\n     */\n    protected array: T[];\n    /**\n     * Instantiate the stack.\n     *\n     * @param elements - A set of elements to initialize the stack with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.array = elements ? Array.from(elements) : [];\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    peek(): T | undefined {\n        return this.array[this.array.length - 1];\n    }\n\n    pop(): T | undefined {\n        return this.array.pop();\n    }\n\n    push(element: T): number {\n        return this.array.push(element);\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        const array = this.array;\n        for (let i = array.length; i > 0; yield array[--i]) {}\n    }\n}\n","import { LinkedList, List } from '../list';\nimport { Stack } from './stack';\n\n/**\n * A linked list implementation of the {@link Stack} interface\n */\nexport class LinkedStack<T> implements Stack<T> {\n    /**\n     * The list containing every element.\n     */\n    protected list: List<T>;\n    /**\n     * Instantiate the stack.\n     *\n     * @param elements - A set of elements to initialize the stack with.\n     */\n    constructor(elements?: Iterable<T>) {\n        this.list = new LinkedList();\n        for (const element of elements || []) {\n            this.push(element);\n        }\n    }\n\n    clear(): void {\n        this.list.clear();\n    }\n\n    peek(): T | undefined {\n        return this.list.get(0);\n    }\n\n    pop(): T | undefined {\n        return this.list.shift();\n    }\n\n    push(element: T): number {\n        return this.list.unshift(element);\n    }\n\n    get size(): number {\n        return this.list.size;\n    }\n    /**\n     * Receive an iterator through the stack.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the stack\n     */\n    [Symbol.iterator](): Iterator<T> {\n        return this.list[Symbol.iterator]();\n    }\n}\n","import { CompareFn } from '..';\nimport { AATreeNode } from './aaTreeNode';\nimport {\n    clone,\n    search,\n    Edge,\n    inOrderTraverse,\n    leftmost,\n    leftmostStack,\n    preOrderTraverse,\n    removeStack,\n    rightmost,\n    rightmostStack,\n    searchStack,\n    debug,\n} from './binaryTreeUtils';\nimport { SortedTree } from './sortedTree';\nimport { isArray } from 'src/utils/arrayUtils';\nimport { LinkedNode } from 'src/list';\n\n/**\n * An AA tree is a form of balanced tree used for storing and retrieving ordered data efficiently\n * ([source](https://en.wikipedia.org/wiki/AA_tree)).\n *\n * AA trees are named for Arne Andersson, their inventor. They are a variation of the red–black tree,\n * which supports efficient addition and deletion of entries. Unlike red–black trees, additional\n * constraints on the balancing mechanism greatly simplifies the implementation as well as\n * maintenance operations; While a red–black tree needs to consider seven different shapes\n * to properly balance the tree, an AA tree only needs to consider two shapes.\n *\n * The performance of an AA tree is equivalent to the performance of a red–black tree.\n * While an AA tree makes more rotations than a red-black tree, the simpler algorithms\n * tend to be faster, which balances out to similar performance. A red-black tree is\n * more consistent in its performance, but an AA tree tends to be flatter, which results\n * in slightly faster search times.\n */\nexport class AATree<T> implements SortedTree<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * Indicates how to handle duplicates:\n     * - < 0 : Add to left subtree\n     * - = 0 : Do now allow duplicates\n     * - > 0 : Add to right subtree\n     */\n    protected dupeWeight: number;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The node at the \"top\" of the heap.\n     */\n    protected root: AATreeNode<T> | undefined;\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>);\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param allowDuplicates - Whether to allow duplicates\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, allowDuplicates: boolean, elements?: Iterable<T>);\n    constructor(\n        compareFn: CompareFn<T>,\n        allowDuplicates?: boolean | Iterable<T>,\n        elements?: Iterable<T>,\n    ) {\n        if (typeof allowDuplicates !== 'boolean') {\n            elements = allowDuplicates;\n            allowDuplicates = true;\n        }\n        this.compare = compareFn;\n        this.dupeWeight = +allowDuplicates;\n        this.length = 0;\n        this.build(elements ?? []);\n    }\n\n    add(element: T): this {\n        // Find the element\n        const sentinel = { left: this.root } as AATreeNode<T>;\n        let edge: Edge<AATreeNode<T>> = { from: sentinel, label: 'left', to: this.root };\n        let stack = searchStack(element, { value: edge }, this.compare, this.dupeWeight);\n\n        // If element already exists\n        if (stack.value.to != null) {\n            return this;\n        }\n\n        // Add element\n        edge = stack.value;\n        let label = edge.label;\n        edge.from![label!] = { level: 1, value: element };\n\n        // Balance the tree\n        while (stack.next) {\n            stack = stack.next;\n            edge = stack.value;\n            edge.to = split(skew(edge.to));\n            edge.from![(label = edge.label!)] = edge.to;\n        }\n\n        // Update state\n        ++this.length;\n        this.root = sentinel.left;\n        return this;\n    }\n\n    clear(): void {\n        this.root = undefined;\n        this.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    delete(element: T): boolean {\n        // Remove the element if found\n        const sentinel = { left: this.root } as AATreeNode<T>;\n        const edge: Edge<AATreeNode<T>> = { from: sentinel, label: 'left', to: this.root };\n        const stack = searchStack(element, { value: edge }, this.compare, 0);\n        const removed = remove(stack);\n\n        // Update state\n        this.root = sentinel.left;\n        this.length -= +removed;\n        return removed;\n    }\n\n    has(element: T): boolean {\n        return search(element, this.root, this.compare) != null;\n    }\n\n    max(): T | undefined {\n        return rightmost(this.root)?.value;\n    }\n\n    min(): T | undefined {\n        return leftmost(this.root)?.value;\n    }\n\n    pop(): T | undefined {\n        // Find the maximum value\n        const sentinel = { left: this.root } as AATreeNode<T>;\n        const edge: Edge<AATreeNode<T>> = { from: sentinel, label: 'left', to: this.root };\n        const stack = rightmostStack({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.root = sentinel.left;\n        this.length -= +removed;\n        return value;\n    }\n\n    shift(): T | undefined {\n        // Find the minimum value\n        const sentinel = { left: this.root } as AATreeNode<T>;\n        const edge: Edge<AATreeNode<T>> = { from: sentinel, label: 'left', to: this.root };\n        const stack = leftmostStack({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.root = sentinel.left;\n        this.length -= +removed;\n        return value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        for (const node of inOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.delete(curElement)) {\n            this.add(newElement);\n            return true;\n        }\n        return false;\n    }\n\n    protected build(obj: Iterable<T>): void {\n        if (isArray(obj)) {\n            for (let i = 0; i < obj.length; ++i) {\n                this.add(obj[i]);\n            }\n        } else if (obj instanceof AATree && this.compare === obj.compare) {\n            this.root = clone(obj.root);\n            this.length = obj.size;\n        } else {\n            for (const element of obj) {\n                this.add(element);\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nexport function remove<T>(stack: LinkedNode<Edge<AATreeNode<T>>>): boolean {\n    let edge = stack.value;\n    let node = edge.to;\n\n    // If not found\n    if (node == null) {\n        return false;\n    }\n\n    // Remove the node\n    stack = removeStack(stack);\n\n    // Update the tree\n    while (stack.next) {\n        stack = stack.next;\n        edge = stack.value;\n        node = edge.to!;\n\n        // Decrease levels\n        const level = 1 + Math.min(node.left?.level ?? 0, node.right?.level ?? 0);\n        if (level < node.level) {\n            node.level = level;\n            if (node.right != null && level < node.right.level) {\n                node.right.level = level;\n            }\n        }\n\n        // Balance\n        node = skew(node);\n        node.right = skew(node.right);\n        if (node.right != null) {\n            node.right.right = skew(node.right.right);\n        }\n        node = split(node);\n        node.right = split(node.right);\n\n        // Make the update\n        edge.from![edge.label!] = edge.to = node;\n    }\n\n    return true;\n}\n/**\n * @internal\n */\nexport function skew<T>(node?: undefined): undefined;\nexport function skew<T>(node: AATreeNode<T>): AATreeNode<T>;\nexport function skew<T>(node?: AATreeNode<T>): AATreeNode<T> | undefined;\nexport function skew<T>(node?: AATreeNode<T>): AATreeNode<T> | undefined {\n    if (node == null || node.left == null || node.level != node.left.level) {\n        return node;\n    }\n    const left = node.left;\n    node.left = left.right;\n    left.right = node;\n    return left;\n}\n/**\n * @internal\n */\nexport function split<T>(node?: undefined): undefined;\nexport function split<T>(node: AATreeNode<T>): AATreeNode<T>;\nexport function split<T>(node?: AATreeNode<T>): AATreeNode<T> | undefined;\nexport function split<T>(node?: AATreeNode<T>): AATreeNode<T> | undefined {\n    if (\n        node == null ||\n        node.right == null ||\n        node.right.right == null ||\n        node.level != node.right.right.level\n    ) {\n        return node;\n    }\n    const right = node.right;\n    node.right = right.left;\n    right.left = node;\n    ++right.level;\n    return right;\n}\n","import { CompareFn } from 'src';\nimport { AVLTreeNode } from './avlTreeNode';\nimport {\n    clone,\n    search,\n    Edge,\n    inOrderTraverse,\n    leftmost,\n    leftmostStack,\n    preOrderTraverse,\n    rightmost,\n    rightmostStack,\n    searchStack,\n    removeStack,\n} from './binaryTreeUtils';\nimport { SortedTree } from './sortedTree';\nimport { isArray } from 'src/utils/arrayUtils';\nimport { LinkedNode } from 'src/list';\n\n/**\n * An AVL tree is a self-balancing binary search tree ([source](https://en.wikipedia.org/wiki/AVL_tree)).\n *\n * It is named after inventors Georgy Adelson-Velsky and Evgenii Landis and was the first such\n * data structure to be invented. In an AVL tree, the heights of the two child\n * subtrees of any node differ by at most one; if at any time they differ by more\n * than one, rebalancing is done to restore this property.\n *\n * Lookup, insertion, and deletion all take O(log(n)) time in both the average and worst cases,\n * where n is the number of nodes in the tree prior to the operation. Insertions and deletions\n * may require the tree to be rebalanced by one or more tree rotations.\n *\n * AVL trees are often compared with red–black trees as both take O(log(n))\n * time for the basic operations. For lookup-intensive applications, AVL trees are\n * faster than red–black trees because they are more strictly balanced.\n * Similar to red–black trees, AVL trees are height-balanced.\n */\nexport class AVLTree<T> implements SortedTree<T> {\n    /**\n     * The function to determine the order of elements.\n     */\n    protected compare: CompareFn<T>;\n    /**\n     * Indicates how to handle duplicates:\n     * - < 0 : Add to left subtree\n     * - = 0 : Do now allow duplicates\n     * - > 0 : Add to right subtree\n     */\n    protected dupeWeight: number;\n    /**\n     * The number of elements in the list.\n     */\n    protected length: number;\n    /**\n     * The root of the tree.\n     */\n    protected root: AVLTreeNode<T>;\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, elements?: Iterable<T>);\n    /**\n     * Instantiate a tree.\n     *\n     * @param compareFn - The function to determine the order of elements.\n     * @param allowDuplicates - Whether to allow duplicates\n     * @param elements - A set of elements to initialize the tree with.\n     */\n    constructor(compareFn: CompareFn<T>, allowDuplicates: boolean, elements?: Iterable<T>);\n    constructor(\n        compareFn: CompareFn<T>,\n        allowDuplicates?: boolean | Iterable<T>,\n        elements?: Iterable<T>,\n    ) {\n        if (typeof allowDuplicates !== 'boolean') {\n            elements = allowDuplicates;\n            allowDuplicates = true;\n        }\n        this.compare = compareFn;\n        this.dupeWeight = +allowDuplicates;\n        this.length = 0;\n        this.root = {} as AVLTreeNode<T>;\n        this.build(elements ?? []);\n    }\n\n    add(element: T): this {\n        // Find the element\n        let edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        let stack = searchStack(element, { value: edge }, this.compare, this.dupeWeight);\n\n        // If element already exists\n        if (stack.value.to != null) {\n            return this;\n        }\n\n        // Add element\n        edge = stack.value;\n        let label = edge.label;\n        edge.from![label!] = { balanceFactor: 0, value: element };\n\n        // Balance the tree\n        while (stack.next) {\n            stack = stack.next;\n            edge = stack.value;\n            edge.to!.balanceFactor += label === 'left' ? -1 : 1;\n            edge.to = balance(edge.to!);\n            edge.from![(label = edge.label!)] = edge.to;\n            if (edge.to!.balanceFactor === 0) {\n                break;\n            }\n        }\n\n        // Update state\n        ++this.length;\n        return this;\n    }\n\n    clear(): void {\n        this.root.left = undefined;\n        this.length = 0;\n    }\n\n    comparator(): CompareFn<T> {\n        return this.compare;\n    }\n\n    delete(element: T): boolean {\n        // Remove the element if found\n        const edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        const stack = searchStack(element, { value: edge }, this.compare, 0);\n        const removed = remove(stack);\n\n        // Update state\n        this.length -= +removed;\n        return removed;\n    }\n\n    has(element: T): boolean {\n        return search(element, this.root.left, this.compare) != null;\n    }\n\n    max(): T | undefined {\n        return rightmost(this.root.left)?.value;\n    }\n\n    min(): T | undefined {\n        return leftmost(this.root.left)?.value;\n    }\n\n    pop(): T | undefined {\n        // Find the maximum value\n        const edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        const stack = rightmostStack({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.length -= +removed;\n        return value;\n    }\n\n    shift(): T | undefined {\n        // Find the minimum value\n        const edge: Edge<AVLTreeNode<T>> = { from: this.root, label: 'left', to: this.root.left };\n        const stack = leftmostStack({ value: edge });\n        const value = stack.value.to?.value;\n\n        // Remove the value\n        const removed = remove(stack);\n\n        // Update state\n        this.length -= +removed;\n        return value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    *sorted(): Iterable<T> {\n        for (const node of inOrderTraverse(this.root.left)) {\n            yield node.value;\n        }\n    }\n    /**\n     * Receive an iterator through the list.\n     *\n     * **Note:** Unexpected behavior can occur if the collection is modified during iteration.\n     *\n     * @returns An iterator through the list\n     */\n    *[Symbol.iterator](): Iterator<T> {\n        for (const node of preOrderTraverse(this.root.left)) {\n            yield node.value;\n        }\n    }\n\n    update(curElement: T, newElement: T): boolean {\n        if (this.delete(curElement)) {\n            this.add(newElement);\n            return true;\n        }\n        return false;\n    }\n\n    protected build(obj: Iterable<T>): void {\n        if (isArray(obj)) {\n            for (let i = 0; i < obj.length; ++i) {\n                this.add(obj[i]);\n            }\n        } else if (obj instanceof AVLTree && this.compare === obj.compare) {\n            this.root = clone(obj.root);\n            this.length = obj.size;\n        } else {\n            for (const element of obj) {\n                this.add(element);\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nexport function balance<T>(node: AVLTreeNode<T>): AVLTreeNode<T> {\n    if (node.balanceFactor > 1) {\n        if (node.right!.balanceFactor < 0) {\n            node.right = rotateR(node.right!);\n        }\n        node = rotateL(node);\n    } else if (node.balanceFactor < -1) {\n        if (node.left!.balanceFactor > 0) {\n            node.left = rotateL(node.left!);\n        }\n        node = rotateR(node);\n    }\n    return node;\n}\n/**\n * @internal\n */\nexport function remove<T>(stack: LinkedNode<Edge<AVLTreeNode<T>>>): boolean {\n    let edge = stack.value;\n    const node = edge.to;\n\n    // If not found\n    if (node == null) {\n        return false;\n    }\n\n    // Remove the node\n    stack = removeStack(stack);\n\n    // Balance the tree\n    let label = stack.value.label;\n    while (stack.next) {\n        stack = stack.next;\n        edge = stack.value;\n        edge.to!.balanceFactor -= label === 'left' ? -1 : 1;\n        edge.to = balance(edge.to!);\n        edge.from![(label = edge.label)!] = edge.to;\n        if (edge.to!.balanceFactor !== 0) {\n            break;\n        }\n    }\n\n    return true;\n}\n/**\n * @internal\n */\nexport function rotateL<T>(P: AVLTreeNode<T>): AVLTreeNode<T> {\n    const R = P.right!;\n    P.right = R.left;\n    R.left = P;\n    P.balanceFactor -= 1 + Math.max(0, R.balanceFactor);\n    R.balanceFactor -= 1 - Math.min(0, P.balanceFactor);\n    return R;\n}\n/**\n * @internal\n */\nexport function rotateR<T>(P: AVLTreeNode<T>): AVLTreeNode<T> {\n    const L = P.left!;\n    P.left = L.right;\n    L.right = P;\n    P.balanceFactor += 1 - Math.min(0, L.balanceFactor);\n    L.balanceFactor += 1 + Math.max(0, P.balanceFactor);\n    return L;\n}\n","/**\n * Get an iterator that always returns a given value.\n */\nexport function always<T = any>(fn: () => T): Iterator<T> {\n    return { next: () => ({ done: false, value: fn() }) };\n}\n/**\n * Get an iterator that returns a value a given amount of times.\n */\nexport function fill<T = any>(length: number, fn: () => T): Iterator<T> {\n    return {\n        next: () => {\n            if (length < 1) {\n                return { done: true, value: undefined };\n            }\n            --length;\n            return { done: false, value: fn() };\n        },\n    };\n}\n/**\n * Iterate through the first num elements of an iterator.\n *\n * @param n - The number of elements to iterate.\n * @param iterator - The iterator.\n *\n * @returns - An iterator limited to the next n elements.\n */\nexport function first<T = any>(n: number, iterator: Iterator<T>): Iterator<T> {\n    return {\n        next: () => {\n            if (n < 1) {\n                return { done: true, value: undefined };\n            }\n            const res = iterator.next();\n            n = res.done ? 0 : n - 1;\n            return res;\n        },\n    };\n}\n/**\n * Join multiple iterators into one.\n *\n * @param iterators - The iterators to join.\n */\nexport function join<T = any>(iterators: Iterator<Iterator<T>>): Iterator<T> {\n    let iterator: Iterator<T> | undefined = { next: () => ({ done: true, value: undefined }) };\n    return {\n        next: () => {\n            if (iterator == null) {\n                return { done: true, value: undefined };\n            }\n            let res = iterator.next();\n            while (res.done) {\n                const res2 = iterators.next();\n                if (res2.done) {\n                    iterator = undefined;\n                    return { done: true, value: undefined };\n                }\n                iterator = res2.value;\n                res = iterator.next();\n            }\n            return res;\n        },\n    };\n}\n/**\n * Get an empty iterator.\n */\nexport function never<T = any>(): Iterator<T> {\n    return { next: () => ({ done: true, value: undefined }) };\n}\n/**\n * Wrap a value in an iterator.\n */\nexport function once<T = any>(fn: () => T): Iterator<T> {\n    let done = false;\n    return {\n        next: () => {\n            const res = { done, value: fn() };\n            done = true;\n            fn = () => undefined!;\n            return res;\n        },\n    };\n}\n/**\n * Skip the next num elements of an iterator.\n *\n * @param n - The number of elements to skip.\n * @param iterator - The iterator.\n *\n * @returns - The iterator after skipping n elements.\n */\nexport function skip<T = any>(n: number, iterator: Iterator<T>): Iterator<T> {\n    let fn = () => {\n        let res: IteratorResult<T> = { done: false, value: undefined! };\n        while (n-- > 0 && !res.done) {\n            res = iterator.next();\n        }\n        fn = iterator.next.bind(iterator);\n        return res;\n    };\n    return { next: () => fn() };\n}\n/**\n * Split an iterator into multiple iterators of a given length.\n *\n * @param length - The length of each iterator.\n * @param iterator - The iterator to split.\n *\n * @returns - An iterator of the resulting iterators.\n */\nexport function split<T = any>(length: number, iterator: Iterator<T>): Iterator<Iterator<T>> {\n    if (length < 1) {\n        return { next: () => ({ done: true, value: undefined }) };\n    }\n    let done = false;\n    return {\n        next: () => {\n            if (done) {\n                return { done, value: undefined };\n            }\n            const iter = first(length, iterator);\n            const res = iter.next();\n            if (res.done) {\n                done = true;\n                return { done, value: undefined };\n            }\n            return { done, value: join([once(() => res.value), iter][Symbol.iterator]()) };\n        },\n    };\n}\n","/**\n * Pad a string from both sides.\n */\nexport function pad(str: string, maxLen: number, fillString: string): string {\n    const len = str.length;\n    if (len >= maxLen) {\n        return str;\n    }\n    const diff = maxLen - len;\n    return str.padStart(len + diff / 2, fillString).padEnd(len + diff, fillString);\n}\n"],"sourceRoot":""}